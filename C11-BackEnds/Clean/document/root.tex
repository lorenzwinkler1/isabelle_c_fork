\documentclass[fontsize=11pt,paper=a4,open=right,twoside,abstract=true]{scrreprt}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[numbers, sort&compress, sectionbib]{natbib}
\usepackage{isabelle,isabellesym}
\usepackage[only,bigsqcap]{stmaryrd}
\usepackage{ifthen}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{lstisadof}
\IfFileExists{railsetup.sty}{\usepackage{railsetup}}{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% command

\newenvironment{matharray}[1]{\[\begin{array}{#1}}{\end{array}\]} % from 'iman.sty'
\newcommand{\indexdef}[3]%
{\ifthenelse{\equal{}{#1}}{\index{#3 (#2)|bold}}{\index{#3 (#1\ #2)|bold}}} % from 'isar.sty'
\newcommand{\isactrlC}{{\bf C}}

%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% fix for package declaration to be at the end
\usepackage[pdfpagelabels, pageanchor=false, plainpages=false]{hyperref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% document

\urlstyle{rm}
\isabellestyle{it}

\newcommand{\HOL}{HOL}
\newcommand{\eg}{e.g.}
\newcommand{\ie}{i.e.}

\begin{document}

\title{Clean - An Abstract Imperative Programming Language and its Theory}
\author{%
  \href{https://www.lri.fr/~ftuong/}{Fr\'ed\'eric Tuong}
  \and
  \href{https://www.lri.fr/~wolff/}{Burkhart Wolff} \\
  \and
  (with Contributions of \href{https://www.lri.fr/~keller/}{Chantal Keller})}
\publishers{%
  \mbox{LRI, Univ. Paris-Sud, CNRS, Universit\'e Paris-Saclay} \\
  b\^at. 650 Ada Lovelace, 91405 Orsay, France \texorpdfstring{\\}{}
}

\maketitle

\begin{abstract}
Clean (pronounced as: ``CÃ©line'' [selin]) is based on a simple, abstract execution model for an
imperative target language. ``Abstract'' is understood as contrast to ``Concrete Semantics'';
alternatively, the term ``shallow-style embedding'' could be used.

Clean is based on a ``no-frills'' state-exception monad with the usual definitions of \isa{bind} and
\isa{unit} for the compositional glue of state-based computations. Clean offers conditionals and
loops supporting C-like control-flow operators such as \isa{break} and \isa{return}. The memory
model is fully \HOL{}-typed and based on a construction nesting subsequently extensible
records. Note that the current version only supports monomorphic states and parameters of (directly
recursive) functions.

The design is striving for extreme simplicity. It is geared towards symbolic execution and proven
correct verification tools. The underlying libraries of this package, however, deliberately
restricts itself to the most elementary infrastructure for these tasks. The package is intended to
serve as demonstrator semantic backend for Isabelle/C~\cite{TuongWolff19}, serving as basis for the
test-generation technique described in~\cite{DBLP:conf/tap/Keller18}.
\end{abstract}

\newpage
\tableofcontents

\parindent 0pt\parskip 0.5ex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \input{session}
\newpage
\input{Clean.tex}

\input{Quicksort_concept.tex}

\newpage
\chapter{Appendix : Used Monad Libraries}
\input{MonadSE.tex}

\input{Seq_MonadSE.tex}

\input{Symbex_MonadSE.tex}

\input{SquareRoot_concept.tex}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{abbrvnat}
\bibliography{root}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
