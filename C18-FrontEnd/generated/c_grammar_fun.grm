open C_Ast open C_Grammar_Rule_Lib

type start_happy = (unit, (unit, (unit, (unit, unit) either) either) either) either

fun start_happy4 (x : start_happy) = case x of Right (Right (Right (Left x))) => SOME x | _ => NONE
fun start_happy3 (x : start_happy) = case x of Right (Right (Left x)) => SOME x | _ => NONE
fun start_happy2 (x : start_happy) = case x of Right (Left x) => SOME x | _ => NONE
fun start_happy1 (x : start_happy) = case x of Left x => SOME x | _ => NONE

%%
%pure
%name C_Grammar
%arg (_) : Header.arg
%nodefault

%nonterm start_happy of (unit, (unit, (unit, (unit, unit) either) either) either) either
       | option_COMMA_x5f of unit
       | option___anonymous_x5f_x32_x5f of unit
       | option_abstract_declarator_x5f of unit
       | option_argument_expression_list_x5f of unit
       | option_assignment_expression_x5f of unit
       | option_block_item_list_x5f of unit
       | option_declaration_list_x5f of unit
       | option_declarator_x5f of unit
       | option_designation_x5f of unit
       | option_designator_list_x5f of unit
       | option_direct_abstract_declarator_x5f of unit
       | option_expression_x5f of unit
       | option_general_identifier_x5f of unit
       | option_identifier_list_x5f of unit
       | option_init_declarator_list_declarator_typedefname_x5f_x5f of unit
       | option_init_declarator_list_declarator_varname_x5f_x5f of unit
       | option_pointer_x5f of unit
       | option_scoped_parameter_type_list_x5f_x5f of unit
       | option_struct_declarator_list_x5f of unit
       | option_type_qualifier_list_x5f of unit
       | list___anonymous_x5f_x30_x5f of unit
       | list___anonymous_x5f_x31_x5f of unit
       | list_declaration_specifier_x5f of unit
       | list_eq1_TYPEDEF_declaration_specifier_x5f of unit
       | list_eq1_type_specifier_unique___anonymous_x5f_x30_x5f of unit
       | list_eq1_type_specifier_unique_declaration_specifier_x5f of unit
       | list_ge1_type_specifier_nonunique___anonymous_x5f_x31_x5f of unit
       | list_ge1_type_specifier_nonunique_declaration_specifier_x5f of unit
       | list_eq1_eq1_TYPEDEF_type_specifier_unique_declaration_specifier_x5f of unit
       | list_eq1_ge1_TYPEDEF_type_specifier_nonunique_declaration_specifier_x5f of unit
       | typedef_name of string
       | var_name of string
       | typedef_name_spec of unit
       | general_identifier of string
       | save_context of C_Grammar_Rule_Lib.c_context
       | scoped_compound_statement_x5f of unit
       | scoped_iteration_statement_x5f of unit
       | scoped_parameter_type_list_x5f of C_Grammar_Rule_Lib.c_context
       | scoped_selection_statement_x5f of unit
       | scoped_statement_x5f of unit
       | declarator_varname of C_Grammar_Rule_Lib.c_declarator
       | declarator_typedefname of C_Grammar_Rule_Lib.c_declarator
       | primary_expression of unit
       | generic_selection of unit
       | generic_assoc_list of unit
       | generic_association of unit
       | postfix_expression of unit
       | argument_expression_list of unit
       | unary_expression of unit
       | unary_operator of unit
       | cast_expression of unit
       | multiplicative_operator of unit
       | multiplicative_expression of unit
       | additive_operator of unit
       | additive_expression of unit
       | shift_operator of unit
       | shift_expression of unit
       | relational_operator of unit
       | relational_expression of unit
       | equality_operator of unit
       | equality_expression of unit
       | and_expression of unit
       | exclusive_or_expression of unit
       | inclusive_or_expression of unit
       | logical_and_expression of unit
       | logical_or_expression of unit
       | conditional_expression of unit
       | assignment_expression of unit
       | assignment_operator of unit
       | expression of unit
       | constant_expression of unit
       | declaration of unit
       | declaration_specifier of unit
       | declaration_specifiers of unit
       | declaration_specifiers_typedef of unit
       | init_declarator_list_declarator_typedefname_x5f of unit
       | init_declarator_list_declarator_varname_x5f of unit
       | init_declarator_declarator_typedefname_x5f of unit
       | init_declarator_declarator_varname_x5f of unit
       | storage_class_specifier of unit
       | type_specifier_nonunique of unit
       | type_specifier_unique of unit
       | struct_or_union_specifier of unit
       | struct_or_union of unit
       | struct_declaration_list of unit
       | struct_declaration of unit
       | specifier_qualifier_list of unit
       | struct_declarator_list of unit
       | struct_declarator of unit
       | enum_specifier of unit
       | enumerator_list of unit
       | enumerator of unit
       | enumeration_constant of string
       | atomic_type_specifier of unit
       | type_qualifier of unit
       | function_specifier of unit
       | alignment_specifier of unit
       | declarator of C_Grammar_Rule_Lib.c_declarator
       | direct_declarator of C_Grammar_Rule_Lib.c_declarator
       | pointer of unit
       | type_qualifier_list of unit
       | parameter_type_list of C_Grammar_Rule_Lib.c_context
       | parameter_list of unit
       | parameter_declaration of unit
       | identifier_list of unit
       | type_name of unit
       | abstract_declarator of unit
       | direct_abstract_declarator of unit
       | c_initializer of unit
       | initializer_list of unit
       | designation of unit
       | designator_list of unit
       | designator of unit
       | static_assert_declaration of unit
       | statement of unit
       | labeled_statement of unit
       | compound_statement of unit
       | block_item_list of unit
       | block_item of unit
       | expression_statement of unit
       | selection_statement of unit
       | iteration_statement of unit
       | jump_statement of unit
       | translation_unit of unit
       | external_declaration of unit
       | function_definition_x31 of C_Grammar_Rule_Lib.c_context
       | function_definition of unit
       | declaration_list of unit

%term start_expression
    | start_external_declaration
    | start_statement
    | start_translation_unit
    | below_ELSE
    | error
    | ADD_ASSIGN of unit
    | ALIGNAS of unit
    | ALIGNOF of unit
    | AND of unit
    | ANDAND of unit
    | AND_ASSIGN of unit
    | ATOMIC of unit
    | ATOMIC_LPAREN of unit
    | AUTO of unit
    | BANG of unit
    | BAR of unit
    | BARBAR of unit
    | BOOL of unit
    | BREAK of unit
    | CASE of unit
    | CHAR of unit
    | COLON of unit
    | COMMA of unit
    | COMPLEX of unit
    | CONST of unit
    | CONSTANT of unit
    | CONTINUE of unit
    | DEC of unit
    | DEFAULT of unit
    | DIV_ASSIGN of unit
    | DO of unit
    | DOT of unit
    | DOUBLE of unit
    | ELLIPSIS of unit
    | ELSE of unit
    | ENUM of unit
    | EOF of unit
    | EQ of unit
    | EQEQ of unit
    | EXTERN of unit
    | FLOAT of unit
    | FOR of unit
    | GENERIC of unit
    | GEQ of unit
    | GOTO of unit
    | GT of unit
    | HAT of unit
    | IF of unit
    | IMAGINARY of unit
    | INC of unit
    | INLINE of unit
    | INT of unit
    | LBRACE of unit
    | LBRACK of unit
    | LEFT of unit
    | LEFT_ASSIGN of unit
    | LEQ of unit
    | LONG of unit
    | LPAREN of unit
    | LT of unit
    | MINUS of unit
    | MOD_ASSIGN of unit
    | MUL_ASSIGN of unit
    | NAME of string
    | NEQ of unit
    | NORETURN of unit
    | OR_ASSIGN of unit
    | PERCENT of unit
    | PLUS of unit
    | PTR of unit
    | QUESTION of unit
    | RBRACE of unit
    | RBRACK of unit
    | REGISTER of unit
    | RESTRICT of unit
    | RETURN of unit
    | RIGHT of unit
    | RIGHT_ASSIGN of unit
    | RPAREN of unit
    | SEMICOLON of unit
    | SHORT of unit
    | SIGNED of unit
    | SIZEOF of unit
    | SLASH of unit
    | STAR of unit
    | STATIC of unit
    | STATIC_ASSERT of unit
    | STRING_LITERAL of unit
    | STRUCT of unit
    | SUB_ASSIGN of unit
    | SWITCH of unit
    | THREAD_LOCAL of unit
    | TILDE of unit
    | TYPE of unit
    | TYPEDEF of unit
    | UNION of unit
    | UNSIGNED of unit
    | VARIABLE of unit
    | VOID of unit
    | VOLATILE of unit
    | WHILE of unit
    | XOR_ASSIGN of unit
    | x25_eof

%nonassoc below_ELSE
%nonassoc ELSE


(* fun token_of_string error ty_ClangCVersion ty_cChar ty_cFloat ty_cInteger ty_cString ty_ident ty_string a1 a2 = fn
    | x => let 
    val addassign = ADD_ASSIGN (ty_string, a1, a2)
    val alignas = ALIGNAS (ty_string, a1, a2)
    val alignof = ALIGNOF (ty_string, a1, a2)
    val and = AND (ty_string, a1, a2)
    val andand = ANDAND (ty_string, a1, a2)
    val andassign = AND_ASSIGN (ty_string, a1, a2)
    val atomic = ATOMIC (ty_string, a1, a2)
    val atomiclparen = ATOMIC_LPAREN (ty_string, a1, a2)
    val auto = AUTO (ty_string, a1, a2)
    val bang = BANG (ty_string, a1, a2)
    val bar = BAR (ty_string, a1, a2)
    val barbar = BARBAR (ty_string, a1, a2)
    val bool = BOOL (ty_string, a1, a2)
    val break = BREAK (ty_string, a1, a2)
    val case0 = CASE (ty_string, a1, a2)
    val char = CHAR (ty_string, a1, a2)
    val colon = COLON (ty_string, a1, a2)
    val comma = COMMA (ty_string, a1, a2)
    val complex = COMPLEX (ty_string, a1, a2)
    val const = CONST (ty_string, a1, a2)
    val constant = CONSTANT (ty_string, a1, a2)
    val continue = CONTINUE (ty_string, a1, a2)
    val dec = DEC (ty_string, a1, a2)
    val default = DEFAULT (ty_string, a1, a2)
    val divassign = DIV_ASSIGN (ty_string, a1, a2)
    val do0 = DO (ty_string, a1, a2)
    val dot = DOT (ty_string, a1, a2)
    val double = DOUBLE (ty_string, a1, a2)
    val ellipsis = ELLIPSIS (ty_string, a1, a2)
    val else0 = ELSE (ty_string, a1, a2)
    val enum = ENUM (ty_string, a1, a2)
    val eof = EOF (ty_string, a1, a2)
    val eq = EQ (ty_string, a1, a2)
    val eqeq = EQEQ (ty_string, a1, a2)
    val extern = EXTERN (ty_string, a1, a2)
    val float = FLOAT (ty_string, a1, a2)
    val for0 = FOR (ty_string, a1, a2)
    val generic = GENERIC (ty_string, a1, a2)
    val geq = GEQ (ty_string, a1, a2)
    val goto = GOTO (ty_string, a1, a2)
    val gt = GT (ty_string, a1, a2)
    val hat = HAT (ty_string, a1, a2)
    val if0 = IF (ty_string, a1, a2)
    val imaginary = IMAGINARY (ty_string, a1, a2)
    val inc = INC (ty_string, a1, a2)
    val inline = INLINE (ty_string, a1, a2)
    val int = INT (ty_string, a1, a2)
    val lbrace = LBRACE (ty_string, a1, a2)
    val lbrack = LBRACK (ty_string, a1, a2)
    val left = LEFT (ty_string, a1, a2)
    val leftassign = LEFT_ASSIGN (ty_string, a1, a2)
    val leq = LEQ (ty_string, a1, a2)
    val long = LONG (ty_string, a1, a2)
    val lparen = LPAREN (ty_string, a1, a2)
    val lt = LT (ty_string, a1, a2)
    val minus = MINUS (ty_string, a1, a2)
    val modassign = MOD_ASSIGN (ty_string, a1, a2)
    val mulassign = MUL_ASSIGN (ty_string, a1, a2)
    val name = NAME (ty_string, a1, a2)
    val neq = NEQ (ty_string, a1, a2)
    val noreturn = NORETURN (ty_string, a1, a2)
    val orassign = OR_ASSIGN (ty_string, a1, a2)
    val percent = PERCENT (ty_string, a1, a2)
    val plus = PLUS (ty_string, a1, a2)
    val ptr = PTR (ty_string, a1, a2)
    val question = QUESTION (ty_string, a1, a2)
    val rbrace = RBRACE (ty_string, a1, a2)
    val rbrack = RBRACK (ty_string, a1, a2)
    val register = REGISTER (ty_string, a1, a2)
    val restrict = RESTRICT (ty_string, a1, a2)
    val return0 = RETURN (ty_string, a1, a2)
    val right = RIGHT (ty_string, a1, a2)
    val rightassign = RIGHT_ASSIGN (ty_string, a1, a2)
    val rparen = RPAREN (ty_string, a1, a2)
    val semicolon = SEMICOLON (ty_string, a1, a2)
    val short = SHORT (ty_string, a1, a2)
    val signed = SIGNED (ty_string, a1, a2)
    val sizeof = SIZEOF (ty_string, a1, a2)
    val slash = SLASH (ty_string, a1, a2)
    val star = STAR (ty_string, a1, a2)
    val static = STATIC (ty_string, a1, a2)
    val staticassert = STATIC_ASSERT (ty_string, a1, a2)
    val stringliteral = STRING_LITERAL (ty_string, a1, a2)
    val struct0 = STRUCT (ty_string, a1, a2)
    val subassign = SUB_ASSIGN (ty_string, a1, a2)
    val switch = SWITCH (ty_string, a1, a2)
    val threadlocal = THREAD_LOCAL (ty_string, a1, a2)
    val tilde = TILDE (ty_string, a1, a2)
    val type = TYPE (ty_string, a1, a2)
    val typedef = TYPEDEF (ty_string, a1, a2)
    val union = UNION (ty_string, a1, a2)
    val unsigned = UNSIGNED (ty_string, a1, a2)
    val variable = VARIABLE (ty_string, a1, a2)
    val void = VOID (ty_string, a1, a2)
    val volatile = VOLATILE (ty_string, a1, a2)
    val while0 = WHILE (ty_string, a1, a2)
    val xorassign = XOR_ASSIGN (ty_string, a1, a2)
    in case x of
    (* | _ => error end *)
*)

%eop x25_eof EOF
%pos Position.T
%%

(* production *)
start_happy : start_expression expression ((Left) expression1)
            | start_external_declaration external_declaration ((Right o Left) external_declaration1)
            | start_statement statement ((Right o Right o Left) statement1)
            | start_translation_unit translation_unit ((Right o Right o Right o Left) translation_unit1)

option_COMMA_x5f :  (())
                 | COMMA (())

option___anonymous_x5f_x32_x5f :  (())
                               | COMMA ELLIPSIS (())

option_abstract_declarator_x5f :  (())
                               | abstract_declarator ((fn happy_var_1 => ()) abstract_declarator1)

option_argument_expression_list_x5f :  (())
                                    | argument_expression_list ((fn happy_var_1 => ()) argument_expression_list1)

option_assignment_expression_x5f :  (())
                                 | assignment_expression ((fn happy_var_1 => ()) assignment_expression1)

option_block_item_list_x5f :  (())
                           | block_item_list ((fn happy_var_1 => ()) block_item_list1)

option_declaration_list_x5f :  (())
                            | declaration_list ((fn happy_var_1 => ()) declaration_list1)

option_declarator_x5f :  (())
                      | declarator ((fn happy_var_1 => ()) declarator1)

option_designation_x5f :  (())
                       | designation ((fn happy_var_1 => ()) designation1)

option_designator_list_x5f :  (())
                           | designator_list ((fn happy_var_1 => ()) designator_list1)

option_direct_abstract_declarator_x5f :  (())
                                      | direct_abstract_declarator ((fn happy_var_1 => ()) direct_abstract_declarator1)

option_expression_x5f :  (())
                      | expression ((fn happy_var_1 => ()) expression1)

option_general_identifier_x5f :  (())
                              | general_identifier ((fn happy_var_1 => ()) general_identifier1)

option_identifier_list_x5f :  (())
                           | identifier_list ((fn happy_var_1 => ()) identifier_list1)

option_init_declarator_list_declarator_typedefname_x5f_x5f :  (())
                                                           | init_declarator_list_declarator_typedefname_x5f ((fn happy_var_1 => ()) init_declarator_list_declarator_typedefname_x5f1)

option_init_declarator_list_declarator_varname_x5f_x5f :  (())
                                                       | init_declarator_list_declarator_varname_x5f ((fn happy_var_1 => ()) init_declarator_list_declarator_varname_x5f1)

option_pointer_x5f :  (())
                   | pointer ((fn happy_var_1 => ()) pointer1)

option_scoped_parameter_type_list_x5f_x5f :  (())
                                          | scoped_parameter_type_list_x5f ((fn happy_var_1 => ()) scoped_parameter_type_list_x5f1)

option_struct_declarator_list_x5f :  (())
                                  | struct_declarator_list ((fn happy_var_1 => ()) struct_declarator_list1)

option_type_qualifier_list_x5f :  (())
                               | type_qualifier_list ((fn happy_var_1 => ()) type_qualifier_list1)

list___anonymous_x5f_x30_x5f :  (())
                             | type_qualifier list___anonymous_x5f_x30_x5f ((fn happy_var_1 => fn happy_var_2 => ()) type_qualifier1 list___anonymous_x5f_x30_x5f1)
                             | alignment_specifier list___anonymous_x5f_x30_x5f ((fn happy_var_1 => fn happy_var_2 => ()) alignment_specifier1 list___anonymous_x5f_x30_x5f1)

list___anonymous_x5f_x31_x5f :  (())
                             | type_qualifier list___anonymous_x5f_x31_x5f ((fn happy_var_1 => fn happy_var_2 => ()) type_qualifier1 list___anonymous_x5f_x31_x5f1)
                             | alignment_specifier list___anonymous_x5f_x31_x5f ((fn happy_var_1 => fn happy_var_2 => ()) alignment_specifier1 list___anonymous_x5f_x31_x5f1)

list_declaration_specifier_x5f :  (())
                               | declaration_specifier list_declaration_specifier_x5f ((fn happy_var_1 => fn happy_var_2 => ()) declaration_specifier1 list_declaration_specifier_x5f1)

list_eq1_TYPEDEF_declaration_specifier_x5f : TYPEDEF list_declaration_specifier_x5f ((fn happy_var_2 => ()) list_declaration_specifier_x5f1)
                                           | declaration_specifier list_eq1_TYPEDEF_declaration_specifier_x5f ((fn happy_var_1 => fn happy_var_2 => ()) declaration_specifier1 list_eq1_TYPEDEF_declaration_specifier_x5f1)

list_eq1_type_specifier_unique___anonymous_x5f_x30_x5f : type_specifier_unique list___anonymous_x5f_x30_x5f ((fn happy_var_1 => fn happy_var_2 => ()) type_specifier_unique1 list___anonymous_x5f_x30_x5f1)
                                                       | type_qualifier list_eq1_type_specifier_unique___anonymous_x5f_x30_x5f ((fn happy_var_1 => fn happy_var_2 => ()) type_qualifier1 list_eq1_type_specifier_unique___anonymous_x5f_x30_x5f1)
                                                       | alignment_specifier list_eq1_type_specifier_unique___anonymous_x5f_x30_x5f ((fn happy_var_1 => fn happy_var_2 => ()) alignment_specifier1 list_eq1_type_specifier_unique___anonymous_x5f_x30_x5f1)

list_eq1_type_specifier_unique_declaration_specifier_x5f : type_specifier_unique list_declaration_specifier_x5f ((fn happy_var_1 => fn happy_var_2 => ()) type_specifier_unique1 list_declaration_specifier_x5f1)
                                                         | declaration_specifier list_eq1_type_specifier_unique_declaration_specifier_x5f ((fn happy_var_1 => fn happy_var_2 => ()) declaration_specifier1 list_eq1_type_specifier_unique_declaration_specifier_x5f1)

list_ge1_type_specifier_nonunique___anonymous_x5f_x31_x5f : type_specifier_nonunique list___anonymous_x5f_x31_x5f ((fn happy_var_1 => fn happy_var_2 => ()) type_specifier_nonunique1 list___anonymous_x5f_x31_x5f1)
                                                          | type_specifier_nonunique list_ge1_type_specifier_nonunique___anonymous_x5f_x31_x5f ((fn happy_var_1 => fn happy_var_2 => ()) type_specifier_nonunique1 list_ge1_type_specifier_nonunique___anonymous_x5f_x31_x5f1)
                                                          | type_qualifier list_ge1_type_specifier_nonunique___anonymous_x5f_x31_x5f ((fn happy_var_1 => fn happy_var_2 => ()) type_qualifier1 list_ge1_type_specifier_nonunique___anonymous_x5f_x31_x5f1)
                                                          | alignment_specifier list_ge1_type_specifier_nonunique___anonymous_x5f_x31_x5f ((fn happy_var_1 => fn happy_var_2 => ()) alignment_specifier1 list_ge1_type_specifier_nonunique___anonymous_x5f_x31_x5f1)

list_ge1_type_specifier_nonunique_declaration_specifier_x5f : type_specifier_nonunique list_declaration_specifier_x5f ((fn happy_var_1 => fn happy_var_2 => ()) type_specifier_nonunique1 list_declaration_specifier_x5f1)
                                                            | type_specifier_nonunique list_ge1_type_specifier_nonunique_declaration_specifier_x5f ((fn happy_var_1 => fn happy_var_2 => ()) type_specifier_nonunique1 list_ge1_type_specifier_nonunique_declaration_specifier_x5f1)
                                                            | declaration_specifier list_ge1_type_specifier_nonunique_declaration_specifier_x5f ((fn happy_var_1 => fn happy_var_2 => ()) declaration_specifier1 list_ge1_type_specifier_nonunique_declaration_specifier_x5f1)

list_eq1_eq1_TYPEDEF_type_specifier_unique_declaration_specifier_x5f : TYPEDEF list_eq1_type_specifier_unique_declaration_specifier_x5f ((fn happy_var_2 => ()) list_eq1_type_specifier_unique_declaration_specifier_x5f1)
                                                                     | type_specifier_unique list_eq1_TYPEDEF_declaration_specifier_x5f ((fn happy_var_1 => fn happy_var_2 => ()) type_specifier_unique1 list_eq1_TYPEDEF_declaration_specifier_x5f1)
                                                                     | declaration_specifier list_eq1_eq1_TYPEDEF_type_specifier_unique_declaration_specifier_x5f ((fn happy_var_1 => fn happy_var_2 => ()) declaration_specifier1 list_eq1_eq1_TYPEDEF_type_specifier_unique_declaration_specifier_x5f1)

list_eq1_ge1_TYPEDEF_type_specifier_nonunique_declaration_specifier_x5f : TYPEDEF list_ge1_type_specifier_nonunique_declaration_specifier_x5f ((fn happy_var_2 => ()) list_ge1_type_specifier_nonunique_declaration_specifier_x5f1)
                                                                        | type_specifier_nonunique list_eq1_TYPEDEF_declaration_specifier_x5f ((fn happy_var_1 => fn happy_var_2 => ()) type_specifier_nonunique1 list_eq1_TYPEDEF_declaration_specifier_x5f1)
                                                                        | type_specifier_nonunique list_eq1_ge1_TYPEDEF_type_specifier_nonunique_declaration_specifier_x5f ((fn happy_var_1 => fn happy_var_2 => ()) type_specifier_nonunique1 list_eq1_ge1_TYPEDEF_type_specifier_nonunique_declaration_specifier_x5f1)
                                                                        | declaration_specifier list_eq1_ge1_TYPEDEF_type_specifier_nonunique_declaration_specifier_x5f ((fn happy_var_1 => fn happy_var_2 => ()) declaration_specifier1 list_eq1_ge1_TYPEDEF_type_specifier_nonunique_declaration_specifier_x5f1)

typedef_name : NAME TYPE ((*%*)(fn happy_var_1 => return let val (i, v_2) = (happy_var_1, ()) in (i) end) NAME1)

var_name : NAME VARIABLE ((*%*)(fn happy_var_1 => return let val (i, v_2) = (happy_var_1, ()) in (i) end) NAME1)

typedef_name_spec : typedef_name ((fn happy_var_1 => ()) typedef_name1)

general_identifier : typedef_name ((*%*)(fn happy_var_1 => return let val i = happy_var_1 in (i) end) typedef_name1)
                   | var_name ((*%*)(fn happy_var_1 => return let val i = happy_var_1 in (i) end) var_name1)

save_context :  ((*%*)(save_context ()))

scoped_compound_statement_x5f : save_context compound_statement ((*%*)(fn happy_var_1 => fn happy_var_2 => let val (ctx, x) = (happy_var_1, happy_var_2) in (bind (restore_context ctx) (fn _ => return x)) end) save_context1 compound_statement1)

scoped_iteration_statement_x5f : save_context iteration_statement ((*%*)(fn happy_var_1 => fn happy_var_2 => let val (ctx, x) = (happy_var_1, happy_var_2) in (bind (restore_context ctx) (fn _ => return x)) end) save_context1 iteration_statement1)

scoped_parameter_type_list_x5f : save_context parameter_type_list ((*%*)(fn happy_var_1 => fn happy_var_2 => let val (ctx, x) = (happy_var_1, happy_var_2) in (bind (restore_context ctx) (fn _ => return x)) end) save_context1 parameter_type_list1)

scoped_selection_statement_x5f : save_context selection_statement ((*%*)(fn happy_var_1 => fn happy_var_2 => let val (ctx, x) = (happy_var_1, happy_var_2) in (bind (restore_context ctx) (fn _ => return x)) end) save_context1 selection_statement1)

scoped_statement_x5f : save_context statement ((*%*)(fn happy_var_1 => fn happy_var_2 => let val (ctx, x) = (happy_var_1, happy_var_2) in (bind (restore_context ctx) (fn _ => return x)) end) save_context1 statement1)

declarator_varname : declarator ((*%*)(fn happy_var_1 => let val d = happy_var_1 in (bind (declare_varname (identifier d)) (fn _ => return d)) end) declarator1)

declarator_typedefname : declarator ((*%*)(fn happy_var_1 => let val d = happy_var_1 in (bind (declare_typedefname (identifier d)) (fn _ => return d)) end) declarator1)

primary_expression : var_name ((fn happy_var_1 => ()) var_name1)
                   | CONSTANT (())
                   | STRING_LITERAL (())
                   | LPAREN expression RPAREN ((fn happy_var_2 => ()) expression1)
                   | generic_selection ((fn happy_var_1 => ()) generic_selection1)

generic_selection : GENERIC LPAREN assignment_expression COMMA generic_assoc_list RPAREN ((fn happy_var_3 => fn happy_var_5 => ()) assignment_expression1 generic_assoc_list1)

generic_assoc_list : generic_association ((fn happy_var_1 => ()) generic_association1)
                   | generic_assoc_list COMMA generic_association ((fn happy_var_1 => fn happy_var_3 => ()) generic_assoc_list1 generic_association1)

generic_association : type_name COLON assignment_expression ((fn happy_var_1 => fn happy_var_3 => ()) type_name1 assignment_expression1)
                    | DEFAULT COLON assignment_expression ((fn happy_var_3 => ()) assignment_expression1)

postfix_expression : primary_expression ((fn happy_var_1 => ()) primary_expression1)
                   | postfix_expression LBRACK expression RBRACK ((fn happy_var_1 => fn happy_var_3 => ()) postfix_expression1 expression1)
                   | postfix_expression LPAREN option_argument_expression_list_x5f RPAREN ((fn happy_var_1 => fn happy_var_3 => ()) postfix_expression1 option_argument_expression_list_x5f1)
                   | postfix_expression DOT general_identifier ((fn happy_var_1 => fn happy_var_3 => ()) postfix_expression1 general_identifier1)
                   | postfix_expression PTR general_identifier ((fn happy_var_1 => fn happy_var_3 => ()) postfix_expression1 general_identifier1)
                   | postfix_expression INC ((fn happy_var_1 => ()) postfix_expression1)
                   | postfix_expression DEC ((fn happy_var_1 => ()) postfix_expression1)
                   | LPAREN type_name RPAREN LBRACE initializer_list option_COMMA_x5f RBRACE ((fn happy_var_2 => fn happy_var_5 => fn happy_var_6 => ()) type_name1 initializer_list1 option_COMMA_x5f1)

argument_expression_list : assignment_expression ((fn happy_var_1 => ()) assignment_expression1)
                         | argument_expression_list COMMA assignment_expression ((fn happy_var_1 => fn happy_var_3 => ()) argument_expression_list1 assignment_expression1)

unary_expression : postfix_expression ((fn happy_var_1 => ()) postfix_expression1)
                 | INC unary_expression ((fn happy_var_2 => ()) unary_expression1)
                 | DEC unary_expression ((fn happy_var_2 => ()) unary_expression1)
                 | unary_operator cast_expression ((fn happy_var_1 => fn happy_var_2 => ()) unary_operator1 cast_expression1)
                 | SIZEOF unary_expression ((fn happy_var_2 => ()) unary_expression1)
                 | SIZEOF LPAREN type_name RPAREN ((fn happy_var_3 => ()) type_name1)
                 | ALIGNOF LPAREN type_name RPAREN ((fn happy_var_3 => ()) type_name1)

unary_operator : AND (())
               | STAR (())
               | PLUS (())
               | MINUS (())
               | TILDE (())
               | BANG (())

cast_expression : unary_expression ((fn happy_var_1 => ()) unary_expression1)
                | LPAREN type_name RPAREN cast_expression ((fn happy_var_2 => fn happy_var_4 => ()) type_name1 cast_expression1)

multiplicative_operator : STAR (())
                        | SLASH (())
                        | PERCENT (())

multiplicative_expression : cast_expression ((fn happy_var_1 => ()) cast_expression1)
                          | multiplicative_expression multiplicative_operator cast_expression ((fn happy_var_1 => fn happy_var_2 => fn happy_var_3 => ()) multiplicative_expression1 multiplicative_operator1 cast_expression1)

additive_operator : PLUS (())
                  | MINUS (())

additive_expression : multiplicative_expression ((fn happy_var_1 => ()) multiplicative_expression1)
                    | additive_expression additive_operator multiplicative_expression ((fn happy_var_1 => fn happy_var_2 => fn happy_var_3 => ()) additive_expression1 additive_operator1 multiplicative_expression1)

shift_operator : LEFT (())
               | RIGHT (())

shift_expression : additive_expression ((fn happy_var_1 => ()) additive_expression1)
                 | shift_expression shift_operator additive_expression ((fn happy_var_1 => fn happy_var_2 => fn happy_var_3 => ()) shift_expression1 shift_operator1 additive_expression1)

relational_operator : LT (())
                    | GT (())
                    | LEQ (())
                    | GEQ (())

relational_expression : shift_expression ((fn happy_var_1 => ()) shift_expression1)
                      | relational_expression relational_operator shift_expression ((fn happy_var_1 => fn happy_var_2 => fn happy_var_3 => ()) relational_expression1 relational_operator1 shift_expression1)

equality_operator : EQEQ (())
                  | NEQ (())

equality_expression : relational_expression ((fn happy_var_1 => ()) relational_expression1)
                    | equality_expression equality_operator relational_expression ((fn happy_var_1 => fn happy_var_2 => fn happy_var_3 => ()) equality_expression1 equality_operator1 relational_expression1)

and_expression : equality_expression ((fn happy_var_1 => ()) equality_expression1)
               | and_expression AND equality_expression ((fn happy_var_1 => fn happy_var_3 => ()) and_expression1 equality_expression1)

exclusive_or_expression : and_expression ((fn happy_var_1 => ()) and_expression1)
                        | exclusive_or_expression HAT and_expression ((fn happy_var_1 => fn happy_var_3 => ()) exclusive_or_expression1 and_expression1)

inclusive_or_expression : exclusive_or_expression ((fn happy_var_1 => ()) exclusive_or_expression1)
                        | inclusive_or_expression BAR exclusive_or_expression ((fn happy_var_1 => fn happy_var_3 => ()) inclusive_or_expression1 exclusive_or_expression1)

logical_and_expression : inclusive_or_expression ((fn happy_var_1 => ()) inclusive_or_expression1)
                       | logical_and_expression ANDAND inclusive_or_expression ((fn happy_var_1 => fn happy_var_3 => ()) logical_and_expression1 inclusive_or_expression1)

logical_or_expression : logical_and_expression ((fn happy_var_1 => ()) logical_and_expression1)
                      | logical_or_expression BARBAR logical_and_expression ((fn happy_var_1 => fn happy_var_3 => ()) logical_or_expression1 logical_and_expression1)

conditional_expression : logical_or_expression ((fn happy_var_1 => ()) logical_or_expression1)
                       | logical_or_expression QUESTION expression COLON conditional_expression ((fn happy_var_1 => fn happy_var_3 => fn happy_var_5 => ()) logical_or_expression1 expression1 conditional_expression1)

assignment_expression : conditional_expression ((fn happy_var_1 => ()) conditional_expression1)
                      | unary_expression assignment_operator assignment_expression ((fn happy_var_1 => fn happy_var_2 => fn happy_var_3 => ()) unary_expression1 assignment_operator1 assignment_expression1)

assignment_operator : EQ (())
                    | MUL_ASSIGN (())
                    | DIV_ASSIGN (())
                    | MOD_ASSIGN (())
                    | ADD_ASSIGN (())
                    | SUB_ASSIGN (())
                    | LEFT_ASSIGN (())
                    | RIGHT_ASSIGN (())
                    | AND_ASSIGN (())
                    | XOR_ASSIGN (())
                    | OR_ASSIGN (())

expression : assignment_expression ((fn happy_var_1 => ()) assignment_expression1)
           | expression COMMA assignment_expression ((fn happy_var_1 => fn happy_var_3 => ()) expression1 assignment_expression1)

constant_expression : conditional_expression ((fn happy_var_1 => ()) conditional_expression1)

declaration : declaration_specifiers option_init_declarator_list_declarator_varname_x5f_x5f SEMICOLON ((fn happy_var_1 => fn happy_var_2 => ()) declaration_specifiers1 option_init_declarator_list_declarator_varname_x5f_x5f1)
            | declaration_specifiers_typedef option_init_declarator_list_declarator_typedefname_x5f_x5f SEMICOLON ((fn happy_var_1 => fn happy_var_2 => ()) declaration_specifiers_typedef1 option_init_declarator_list_declarator_typedefname_x5f_x5f1)
            | static_assert_declaration ((fn happy_var_1 => ()) static_assert_declaration1)

declaration_specifier : storage_class_specifier ((fn happy_var_1 => ()) storage_class_specifier1)
                      | type_qualifier ((fn happy_var_1 => ()) type_qualifier1)
                      | function_specifier ((fn happy_var_1 => ()) function_specifier1)
                      | alignment_specifier ((fn happy_var_1 => ()) alignment_specifier1)

declaration_specifiers : list_eq1_type_specifier_unique_declaration_specifier_x5f ((fn happy_var_1 => ()) list_eq1_type_specifier_unique_declaration_specifier_x5f1)
                       | list_ge1_type_specifier_nonunique_declaration_specifier_x5f ((fn happy_var_1 => ()) list_ge1_type_specifier_nonunique_declaration_specifier_x5f1)

declaration_specifiers_typedef : list_eq1_eq1_TYPEDEF_type_specifier_unique_declaration_specifier_x5f ((fn happy_var_1 => ()) list_eq1_eq1_TYPEDEF_type_specifier_unique_declaration_specifier_x5f1)
                               | list_eq1_ge1_TYPEDEF_type_specifier_nonunique_declaration_specifier_x5f ((fn happy_var_1 => ()) list_eq1_ge1_TYPEDEF_type_specifier_nonunique_declaration_specifier_x5f1)

init_declarator_list_declarator_typedefname_x5f : init_declarator_declarator_typedefname_x5f ((fn happy_var_1 => ()) init_declarator_declarator_typedefname_x5f1)
                                                | init_declarator_list_declarator_typedefname_x5f COMMA init_declarator_declarator_typedefname_x5f ((fn happy_var_1 => fn happy_var_3 => ()) init_declarator_list_declarator_typedefname_x5f1 init_declarator_declarator_typedefname_x5f1)

init_declarator_list_declarator_varname_x5f : init_declarator_declarator_varname_x5f ((fn happy_var_1 => ()) init_declarator_declarator_varname_x5f1)
                                            | init_declarator_list_declarator_varname_x5f COMMA init_declarator_declarator_varname_x5f ((fn happy_var_1 => fn happy_var_3 => ()) init_declarator_list_declarator_varname_x5f1 init_declarator_declarator_varname_x5f1)

init_declarator_declarator_typedefname_x5f : declarator_typedefname ((fn happy_var_1 => ()) declarator_typedefname1)
                                           | declarator_typedefname EQ c_initializer ((fn happy_var_1 => fn happy_var_3 => ()) declarator_typedefname1 c_initializer1)

init_declarator_declarator_varname_x5f : declarator_varname ((fn happy_var_1 => ()) declarator_varname1)
                                       | declarator_varname EQ c_initializer ((fn happy_var_1 => fn happy_var_3 => ()) declarator_varname1 c_initializer1)

storage_class_specifier : EXTERN (())
                        | STATIC (())
                        | THREAD_LOCAL (())
                        | AUTO (())
                        | REGISTER (())

type_specifier_nonunique : CHAR (())
                         | SHORT (())
                         | INT (())
                         | LONG (())
                         | FLOAT (())
                         | DOUBLE (())
                         | SIGNED (())
                         | UNSIGNED (())
                         | COMPLEX (())

type_specifier_unique : VOID (())
                      | BOOL (())
                      | atomic_type_specifier ((fn happy_var_1 => ()) atomic_type_specifier1)
                      | struct_or_union_specifier ((fn happy_var_1 => ()) struct_or_union_specifier1)
                      | enum_specifier ((fn happy_var_1 => ()) enum_specifier1)
                      | typedef_name_spec ((fn happy_var_1 => ()) typedef_name_spec1)

struct_or_union_specifier : struct_or_union option_general_identifier_x5f LBRACE struct_declaration_list RBRACE ((fn happy_var_1 => fn happy_var_2 => fn happy_var_4 => ()) struct_or_union1 option_general_identifier_x5f1 struct_declaration_list1)
                          | struct_or_union general_identifier ((fn happy_var_1 => fn happy_var_2 => ()) struct_or_union1 general_identifier1)

struct_or_union : STRUCT (())
                | UNION (())

struct_declaration_list : struct_declaration ((fn happy_var_1 => ()) struct_declaration1)
                        | struct_declaration_list struct_declaration ((fn happy_var_1 => fn happy_var_2 => ()) struct_declaration_list1 struct_declaration1)

struct_declaration : specifier_qualifier_list option_struct_declarator_list_x5f SEMICOLON ((fn happy_var_1 => fn happy_var_2 => ()) specifier_qualifier_list1 option_struct_declarator_list_x5f1)
                   | static_assert_declaration ((fn happy_var_1 => ()) static_assert_declaration1)

specifier_qualifier_list : list_eq1_type_specifier_unique___anonymous_x5f_x30_x5f ((fn happy_var_1 => ()) list_eq1_type_specifier_unique___anonymous_x5f_x30_x5f1)
                         | list_ge1_type_specifier_nonunique___anonymous_x5f_x31_x5f ((fn happy_var_1 => ()) list_ge1_type_specifier_nonunique___anonymous_x5f_x31_x5f1)

struct_declarator_list : struct_declarator ((fn happy_var_1 => ()) struct_declarator1)
                       | struct_declarator_list COMMA struct_declarator ((fn happy_var_1 => fn happy_var_3 => ()) struct_declarator_list1 struct_declarator1)

struct_declarator : declarator ((fn happy_var_1 => ()) declarator1)
                  | option_declarator_x5f COLON constant_expression ((fn happy_var_1 => fn happy_var_3 => ()) option_declarator_x5f1 constant_expression1)

enum_specifier : ENUM option_general_identifier_x5f LBRACE enumerator_list option_COMMA_x5f RBRACE ((fn happy_var_2 => fn happy_var_4 => fn happy_var_5 => ()) option_general_identifier_x5f1 enumerator_list1 option_COMMA_x5f1)
               | ENUM general_identifier ((fn happy_var_2 => ()) general_identifier1)

enumerator_list : enumerator ((fn happy_var_1 => ()) enumerator1)
                | enumerator_list COMMA enumerator ((fn happy_var_1 => fn happy_var_3 => ()) enumerator_list1 enumerator1)

enumerator : enumeration_constant ((*%*)(fn happy_var_1 => let val i = happy_var_1 in (declare_varname i) end) enumeration_constant1)
           | enumeration_constant EQ constant_expression ((*%*)(fn happy_var_1 => fn happy_var_3 => let val (i, v_2, v_3) = (happy_var_1, (), happy_var_3) in (declare_varname i) end) enumeration_constant1 constant_expression1)

enumeration_constant : general_identifier ((*%*)(fn happy_var_1 => return let val i = happy_var_1 in (i) end) general_identifier1)

atomic_type_specifier : ATOMIC LPAREN type_name RPAREN ((fn happy_var_3 => ()) type_name1)
                      | ATOMIC ATOMIC_LPAREN type_name RPAREN ((fn happy_var_3 => ()) type_name1)

type_qualifier : CONST (())
               | RESTRICT (())
               | VOLATILE (())
               | ATOMIC (())

function_specifier : INLINE (())
                   | NORETURN (())

alignment_specifier : ALIGNAS LPAREN type_name RPAREN ((fn happy_var_3 => ()) type_name1)
                    | ALIGNAS LPAREN constant_expression RPAREN ((fn happy_var_3 => ()) constant_expression1)

declarator : direct_declarator ((*%*)(fn happy_var_1 => let val d = happy_var_1 in let val v_1 = () in (other_declarator d) end end) direct_declarator1)
           | pointer direct_declarator ((*%*)(fn happy_var_1 => fn happy_var_2 => let val (v_1, d) = (happy_var_1, happy_var_2) in let val v_1 = () in (other_declarator d) end end) pointer1 direct_declarator1)

direct_declarator : general_identifier ((*%*)(fn happy_var_1 => let val i = happy_var_1 in (identifier_declarator i) end) general_identifier1)
                  | LPAREN save_context declarator RPAREN ((*%*)(fn happy_var_2 => fn happy_var_3 => return let val (v_1, v_2, d, v_4) = ((), happy_var_2, happy_var_3, ()) in (d) end) save_context1 declarator1)
                  | direct_declarator LBRACK option_type_qualifier_list_x5f option_assignment_expression_x5f RBRACK ((*%*)(fn happy_var_1 => fn happy_var_3 => fn happy_var_4 => let val (d, v_2, v_3, v_4, v_5) = (happy_var_1, (), happy_var_3, happy_var_4, ()) in (other_declarator d) end) direct_declarator1 option_type_qualifier_list_x5f1 option_assignment_expression_x5f1)
                  | direct_declarator LBRACK STATIC option_type_qualifier_list_x5f assignment_expression RBRACK ((*%*)(fn happy_var_1 => fn happy_var_4 => fn happy_var_5 => let val (d, v_2, v_3, v_4, v_5, v_6) = (happy_var_1, (), (), happy_var_4, happy_var_5, ()) in (other_declarator d) end) direct_declarator1 option_type_qualifier_list_x5f1 assignment_expression1)
                  | direct_declarator LBRACK type_qualifier_list STATIC assignment_expression RBRACK ((*%*)(fn happy_var_1 => fn happy_var_3 => fn happy_var_5 => let val (d, v_2, v_3, v_4, v_5, v_6) = (happy_var_1, (), happy_var_3, (), happy_var_5, ()) in (other_declarator d) end) direct_declarator1 type_qualifier_list1 assignment_expression1)
                  | direct_declarator LBRACK option_type_qualifier_list_x5f STAR RBRACK ((*%*)(fn happy_var_1 => fn happy_var_3 => let val (d, v_2, v_3, v_4, v_5) = (happy_var_1, (), happy_var_3, (), ()) in (other_declarator d) end) direct_declarator1 option_type_qualifier_list_x5f1)
                  | direct_declarator LPAREN scoped_parameter_type_list_x5f RPAREN ((*%*)(fn happy_var_1 => fn happy_var_3 => let val (d, v_2, ctx, v_4) = (happy_var_1, (), happy_var_3, ()) in (function_declarator d ctx) end) direct_declarator1 scoped_parameter_type_list_x5f1)
                  | direct_declarator LPAREN save_context option_identifier_list_x5f RPAREN ((*%*)(fn happy_var_1 => fn happy_var_3 => fn happy_var_4 => let val (d, v_2, v_3, v_4, v_5) = (happy_var_1, (), happy_var_3, happy_var_4, ()) in (other_declarator d) end) direct_declarator1 save_context1 option_identifier_list_x5f1)

pointer : STAR option_type_qualifier_list_x5f option_pointer_x5f ((fn happy_var_2 => fn happy_var_3 => ()) option_type_qualifier_list_x5f1 option_pointer_x5f1)

type_qualifier_list : option_type_qualifier_list_x5f type_qualifier ((fn happy_var_1 => fn happy_var_2 => ()) option_type_qualifier_list_x5f1 type_qualifier1)

parameter_type_list : parameter_list option___anonymous_x5f_x32_x5f save_context ((*%*)(fn happy_var_1 => fn happy_var_2 => fn happy_var_3 => return let val (v_1, v_2, ctx) = (happy_var_1, happy_var_2, happy_var_3) in (ctx) end) parameter_list1 option___anonymous_x5f_x32_x5f1 save_context1)

parameter_list : parameter_declaration ((fn happy_var_1 => ()) parameter_declaration1)
               | parameter_list COMMA parameter_declaration ((fn happy_var_1 => fn happy_var_3 => ()) parameter_list1 parameter_declaration1)

parameter_declaration : declaration_specifiers declarator_varname ((fn happy_var_1 => fn happy_var_2 => ()) declaration_specifiers1 declarator_varname1)
                      | declaration_specifiers option_abstract_declarator_x5f ((fn happy_var_1 => fn happy_var_2 => ()) declaration_specifiers1 option_abstract_declarator_x5f1)

identifier_list : var_name ((fn happy_var_1 => ()) var_name1)
                | identifier_list COMMA var_name ((fn happy_var_1 => fn happy_var_3 => ()) identifier_list1 var_name1)

type_name : specifier_qualifier_list option_abstract_declarator_x5f ((fn happy_var_1 => fn happy_var_2 => ()) specifier_qualifier_list1 option_abstract_declarator_x5f1)

abstract_declarator : pointer ((fn happy_var_1 => ()) pointer1)
                    | direct_abstract_declarator ((fn happy_var_1 => ()) direct_abstract_declarator1)
                    | pointer direct_abstract_declarator ((fn happy_var_1 => fn happy_var_2 => ()) pointer1 direct_abstract_declarator1)

direct_abstract_declarator : LPAREN save_context abstract_declarator RPAREN ((fn happy_var_2 => fn happy_var_3 => ()) save_context1 abstract_declarator1)
                           | option_direct_abstract_declarator_x5f LBRACK option_assignment_expression_x5f RBRACK ((fn happy_var_1 => fn happy_var_3 => ()) option_direct_abstract_declarator_x5f1 option_assignment_expression_x5f1)
                           | option_direct_abstract_declarator_x5f LBRACK type_qualifier_list option_assignment_expression_x5f RBRACK ((fn happy_var_1 => fn happy_var_3 => fn happy_var_4 => ()) option_direct_abstract_declarator_x5f1 type_qualifier_list1 option_assignment_expression_x5f1)
                           | option_direct_abstract_declarator_x5f LBRACK STATIC option_type_qualifier_list_x5f assignment_expression RBRACK ((fn happy_var_1 => fn happy_var_4 => fn happy_var_5 => ()) option_direct_abstract_declarator_x5f1 option_type_qualifier_list_x5f1 assignment_expression1)
                           | option_direct_abstract_declarator_x5f LBRACK type_qualifier_list STATIC assignment_expression RBRACK ((fn happy_var_1 => fn happy_var_3 => fn happy_var_5 => ()) option_direct_abstract_declarator_x5f1 type_qualifier_list1 assignment_expression1)
                           | option_direct_abstract_declarator_x5f LBRACK STAR RBRACK ((fn happy_var_1 => ()) option_direct_abstract_declarator_x5f1)
                           | LPAREN option_scoped_parameter_type_list_x5f_x5f RPAREN ((fn happy_var_2 => ()) option_scoped_parameter_type_list_x5f_x5f1)
                           | direct_abstract_declarator LPAREN option_scoped_parameter_type_list_x5f_x5f RPAREN ((fn happy_var_1 => fn happy_var_3 => ()) direct_abstract_declarator1 option_scoped_parameter_type_list_x5f_x5f1)

c_initializer : assignment_expression ((fn happy_var_1 => ()) assignment_expression1)
              | LBRACE initializer_list option_COMMA_x5f RBRACE ((fn happy_var_2 => fn happy_var_3 => ()) initializer_list1 option_COMMA_x5f1)

initializer_list : option_designation_x5f c_initializer ((fn happy_var_1 => fn happy_var_2 => ()) option_designation_x5f1 c_initializer1)
                 | initializer_list COMMA option_designation_x5f c_initializer ((fn happy_var_1 => fn happy_var_3 => fn happy_var_4 => ()) initializer_list1 option_designation_x5f1 c_initializer1)

designation : designator_list EQ ((fn happy_var_1 => ()) designator_list1)

designator_list : option_designator_list_x5f designator ((fn happy_var_1 => fn happy_var_2 => ()) option_designator_list_x5f1 designator1)

designator : LBRACK constant_expression RBRACK ((fn happy_var_2 => ()) constant_expression1)
           | DOT general_identifier ((fn happy_var_2 => ()) general_identifier1)

static_assert_declaration : STATIC_ASSERT LPAREN constant_expression COMMA STRING_LITERAL RPAREN SEMICOLON ((fn happy_var_3 => ()) constant_expression1)

statement : labeled_statement ((fn happy_var_1 => ()) labeled_statement1)
          | scoped_compound_statement_x5f ((fn happy_var_1 => ()) scoped_compound_statement_x5f1)
          | expression_statement ((fn happy_var_1 => ()) expression_statement1)
          | scoped_selection_statement_x5f ((fn happy_var_1 => ()) scoped_selection_statement_x5f1)
          | scoped_iteration_statement_x5f ((fn happy_var_1 => ()) scoped_iteration_statement_x5f1)
          | jump_statement ((fn happy_var_1 => ()) jump_statement1)

labeled_statement : general_identifier COLON statement ((fn happy_var_1 => fn happy_var_3 => ()) general_identifier1 statement1)
                  | CASE constant_expression COLON statement ((fn happy_var_2 => fn happy_var_4 => ()) constant_expression1 statement1)
                  | DEFAULT COLON statement ((fn happy_var_3 => ()) statement1)

compound_statement : LBRACE option_block_item_list_x5f RBRACE ((fn happy_var_2 => ()) option_block_item_list_x5f1)

block_item_list : option_block_item_list_x5f block_item ((fn happy_var_1 => fn happy_var_2 => ()) option_block_item_list_x5f1 block_item1)

block_item : declaration ((fn happy_var_1 => ()) declaration1)
           | statement ((fn happy_var_1 => ()) statement1)

expression_statement : option_expression_x5f SEMICOLON ((fn happy_var_1 => ()) option_expression_x5f1)

selection_statement : IF LPAREN expression RPAREN scoped_statement_x5f ELSE scoped_statement_x5f ((fn happy_var_3 => fn happy_var_5 => fn happy_var_7 => ()) expression1 scoped_statement_x5f1 scoped_statement_x5f2)
                    | IF LPAREN expression RPAREN scoped_statement_x5f %prec below_ELSE ((fn happy_var_3 => fn happy_var_5 => ()) expression1 scoped_statement_x5f1)
                    | SWITCH LPAREN expression RPAREN scoped_statement_x5f ((fn happy_var_3 => fn happy_var_5 => ()) expression1 scoped_statement_x5f1)

iteration_statement : WHILE LPAREN expression RPAREN scoped_statement_x5f ((fn happy_var_3 => fn happy_var_5 => ()) expression1 scoped_statement_x5f1)
                    | DO scoped_statement_x5f WHILE LPAREN expression RPAREN SEMICOLON ((fn happy_var_2 => fn happy_var_5 => ()) scoped_statement_x5f1 expression1)
                    | FOR LPAREN option_expression_x5f SEMICOLON option_expression_x5f SEMICOLON option_expression_x5f RPAREN scoped_statement_x5f ((fn happy_var_3 => fn happy_var_5 => fn happy_var_7 => fn happy_var_9 => ()) option_expression_x5f1 option_expression_x5f2 option_expression_x5f3 scoped_statement_x5f1)
                    | FOR LPAREN declaration option_expression_x5f SEMICOLON option_expression_x5f RPAREN scoped_statement_x5f ((fn happy_var_3 => fn happy_var_4 => fn happy_var_6 => fn happy_var_8 => ()) declaration1 option_expression_x5f1 option_expression_x5f2 scoped_statement_x5f1)

jump_statement : GOTO general_identifier SEMICOLON ((fn happy_var_2 => ()) general_identifier1)
               | CONTINUE SEMICOLON (())
               | BREAK SEMICOLON (())
               | RETURN option_expression_x5f SEMICOLON ((fn happy_var_2 => ()) option_expression_x5f1)

translation_unit : external_declaration translation_unit ((fn happy_var_1 => fn happy_var_2 => ()) external_declaration1 translation_unit1)
                 | external_declaration EOF ((fn happy_var_1 => ()) external_declaration1)

external_declaration : function_definition ((fn happy_var_1 => ()) function_definition1)
                     | declaration ((fn happy_var_1 => ()) declaration1)

function_definition_x31 : declaration_specifiers declarator_varname ((*%*)(fn happy_var_1 => fn happy_var_2 => let val (v_1, d) = (happy_var_1, happy_var_2) in (bind (save_context ()) (fn ctx => bind (reinstall_function_context d) (fn _ => return ctx))) end) declaration_specifiers1 declarator_varname1)

function_definition : function_definition_x31 option_declaration_list_x5f compound_statement ((*%*)(fn happy_var_1 => fn happy_var_2 => fn happy_var_3 => let val (ctx, v_2, v_3) = (happy_var_1, happy_var_2, happy_var_3) in (restore_context ctx) end) function_definition_x311 option_declaration_list_x5f1 compound_statement1)

declaration_list : declaration ((fn happy_var_1 => ()) declaration1)
                 | declaration_list declaration ((fn happy_var_1 => fn happy_var_2 => ()) declaration_list1 declaration1)


