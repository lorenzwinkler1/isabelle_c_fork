\section{Introduction}
\isatagafp%
The Unified Modeling Language
(UML)~\cite{omg:uml-infrastructure:2011,omg:uml-superstructure:2011}
is one of the few modeling languages that is widely used in
industry. \UML is defined in an open process by the Object Management
Group (OMG), \ie, an industry consortium.  While \UML is mostly known
as diagrammatic modelling language (\eg, visualizing class models), it
also comprises a textual language, called Object Constraint Language
(\OCL)~\cite{omg:ocl:2012}. \OCL is a textual annotation language,
originally conceived as a three-valued logic, that turns substantial
parts of \UML into a formal language.  Unfortunately the semantics of
this specification language, captured in the ``Annex A'' (originally,
based on the work of \citet{richters:precise:2002}) of the \OCL
standard leads to different interpretations of corner cases.  Many of
these corner cases had been subject to formal analysis since more than
nearly fifteen years (see,
\eg,~\cite{brucker.ea:semantic:2006-b,brucker.ea:proposal:2002,mandel.ea:ocl:1999,
  hamie.ea:reflections:1998,cook.ea::amsterdam:2002}).

At its origins~\cite{richters:precise:2002,omg:ocl:1997}, \OCL was
conceived as a strict semantics for undefinedness (\eg, denoted by the
element \inlineocl{invalid}\footnote{In earlier versions of the \OCL
  standard, this element was called \inlineocl{OclUndefined}.}), with
the exception of the logical connectives of type \inlineocl{Boolean}
that constitute a three-valued propositional logic. At its core, \OCL
comprises four layers:
\begin{enumerate}
\item Operators (\eg, \inlineocl{_ and _}, \inlineocl{_ + _}) on
  built-in data structures such as \inlineocl{Boolean},
  \inlineocl{Integer}, or typed sets (\inlineocl{Set(_)}).
\item Operators on the user-defined data model (\eg, defined as part
  of a \UML class model) such as accessors, type casts and tests.
\item Arbitrary, user-defined, side-effect-free methods called \emph{queries},
\item Specification for invariants on states and contracts for
  operations to be specified via pre- and post-conditions.
\end{enumerate}

Motivated by the need for aligning \OCL closer with \UML, recent
versions of the \OCL standard~\cite{omg:ocl:2006,omg:ocl:2012} added a
second exception element.  While the first exception element
\inlineocl{invalid} has a strict semantics, \inlineocl{null} has a non
strict semantic interpretation.  Unfortunately, this extension results
in several inconsistencies and contradictions. These problems are
reflected in difficulties to define interpreters, code-generators,
specification animators or theorem provers for \OCL in a uniform manner
and resulting incompatibilities of various tools.

For the \OCL community, the semantics of \inlineocl{invalid} and
\inlineocl{null} as well as many related issues resulted in the
challenge to define a consistent version of the \OCL standard that is
well aligned with the recent developments of the \UML\@. A syntactical
and semantical consistent standard requires a major revision of both
the informal and formal parts of the standard. To discuss the future
directions of the standard, several \OCL experts met in November 2013
in Aachen to discuss possible mid-term improvements of \OCL, strategies
of standardization of \OCL within the OMG, and a vision for possible
long-term developments of the
language~\cite{brucker.ea:summary-aachen:2013}. During this meeting, a
Request for Proposals (RFP) for \OCL 2.5 was finalized and meanwhile
proposed. In particular, this RFP requires that the future \OCL 2.5
standard document shall be generated from a machine-checked
source. This will ensure
\begin{itemize}
\item the absence of syntax errors,
\item the consistency of the formal semantics,
\item a suite of corner-cases relevant for \OCL tool implementors.
\end{itemize}

In this document, we present a formalization using
Isabelle/HOL~\cite{nipkow.ea:isabelle:2002} of a core language of
\OCL\@. The semantic theory, based on a ``shallow embedding'', is
called \emph{Featherweight OCL}, since it focuses on a formal
treatment of the key-elements of the language (rather than a full
treatment of all operators and thus, a ``complete''
implementation). In contrast to full \OCL, it comprises just the logic
captured in \verb+Boolean+, the basic data types \verb+Void+,
\verb+Integer+, \verb+Real+ and \verb+String+, the collection types
\verb+Set+, \verb+Pair+, \verb+Sequence+ and \verb+Bag+. The generic
construction principle of class models is also
supported (its detailed presentation is out of the scope of this document, an
instantiation will be provided for two examples).
The formal semantics developed in \FOCL
is intended to be a proposal for the standardization
process of \OCL 2.5, which should ultimately replace parts of the
mandatory part of the standard document~\cite{omg:ocl:2012} as well as
replace completely its informative ``Annex A.''
\endisatagafp
%%
\isatagannexa
This annex chapter formally defines the semantics of \OCL\@. This
chapter is a, to a large extend automatically generated, summary of a
formal semantics of the core of OCL, called \FOCL\footnote{An updated,
  machine-checked version and formally complete version of the
  complete formalization is maintained by the Isabelle Archive of
  Formal Proofs (AFP), see
  \url{http://afp.sourceforge.net/entries/Featherweight_OCL.shtml}}. \FOCL
has a formal semantics in Isabelle/\HOL~\cite{nipkow.ea:isabelle:2002}.
\endisatagannexa

The semantic definitions are in large parts executable, namely the
essence of \verb+Set+, \verb+Pair+, \verb+Sequence+ and \verb+Bag+
constructions (as remark, \HOL is a classical logic where some parts
could be not constructively defined). The first goal of its
construction is \emph{consistency}, \ie, it should be possible to
apply logical rules and/or evaluation rules for \OCL in an arbitrary
manner always yielding the same result. Moreover, except in
pathological cases, this result should be unambiguously defined, \ie,
represent a value.

To motivate the need for logical consistency and also the magnitude of
the problem, we focus on one particular feature of the language as
example: \inlineocl{Tuples}. Recall that tuples (in other languages
known as \emph{records}) are $n$-ary Cartesian products with named
components, where the component names are used also as projection
functions: the special case \inlineocl+Pair{x:First, y:Second}+ stands
for the usual binary pairing operator \inlineocl+Pair{true, null}+ and
the two projection functions \inlineocl+x.First()+ and
\inlineocl+x.Second()+. For a developer of a compiler or proof-tool
(based on, say, a connection to an SMT solver designed to animate \OCL
contracts) it would be natural to add the rules $\mocl{Pair\{X,
  Y\}.First()} = \mocl{X}$ and $\mocl{Pair\{X, Y\}.Second()} =
\mocl{Y}$ to give pairings the usual semantics. At some place, the
\OCL Standard requires the existence of a constant symbol
\inlineocl+invalid+ and requires all operators to be strict. To
implement this, the developer might be tempted to add a generator for
corresponding strictness axioms, producing among hundreds of other
rules $\mocl{Pair\{invalid, Y\}} = \mocl{invalid}$, $\mocl{Pair\{X,
  invalid\}} = \mocl{invalid}$, $\mocl{invalid.First()} =
\mocl{invalid}$, $\mocl{invalid.Second()} = \mocl{invalid}$, etc.
Unfortunately, this ``natural'' axiomatization of pairing and
projection together with strictness is already inconsistent. One can
derive:
\begin{gather*}
\begin{array}{l@{}l@{}}
   \mocl{Pair\{true, invalid\}.First()} \ap & = \mocl{invalid.First()} \\
                                            & = \mocl{invalid}
\end{array}
\end{gather*}
and:
\begin{gather*}
\begin{array}{l@{}l@{}}
   \mocl{Pair\{true, invalid\}.First()} \ap & = \mocl{true}
\end{array}
\end{gather*}
which then results in the absurd logical consequence that
$\mocl{invalid} = \mocl{true}$. Obviously, we need to be more careful
on the side-conditions of our rules.\footnote{The solution to this little
  riddle can be found in \autoref{sec:collection_pairs}.}
And obviously, only a mechanized check of these definitions, following
a rigorous methodology, can establish strong guarantees for logical
consistency of the \OCL language.

\isatagafp
 This leads us to our second goal of this document:
\endisatagafp
\isatagannexa
 This leads us to our second goal of this annex:
\endisatagannexa
it should not only be
usable by logicians, but also by developers of compilers and
proof-tools. For this end, we \emph{derive} from the Isabelle
framework, many definitions and \emph{logical rules} for formal
interactive and automated proofs on \UML/\OCL specifications. These
logical rules are necessary for \emph{execution rules} and
\emph{test-cases} to reveal potential corner-cases related with the
semantics the implementors are defining.

\OCL is an annotation language for \UML models, in particular class
models allowing for specifying data and operations on them. As such,
it is a \emph{typed} object-oriented language. This means that it
is---like Java or C++---based on the concept of a \emph{static type},
that is the type that the type-checker infers from a \UML class model
and its \OCL annotation, as well as a \emph{dynamic type}, that is the
type at which an object is dynamically created\footnote{As side-effect
  free language, \OCL has no object-constructors, but with
  \inlineocl+OclIsNew()+, the effect of object creation can be
  expressed in a declarative way.}. Types are not only a means for
efficient compilation and a support of separation of concerns in
programming, there are of fundamental importance for our goal of
logical consistency: it is impossible to have sets that contain
themselves, \ie, to state Russell's paradox in \OCL typed set-theory.
Moreover, object-oriented typing means that types can be in sub-typing
relation; technically speaking, this means that any object $X$ can be
\emph{cast} with the operator $(\_ ::
C_i)\mocl{.oclAsType(}C_j\mocl{)}$ from one class types $C_i$ to
another class types $C_j$, and under particular conditions (to be
later described), these casts are semantically \emph{lossless}:
\begin{gather*}
(X :: C_i)\mocl{.oclAsType(}C_j\mocl{).oclAsType(}C_i\mocl{)} = X
\end{gather*}
Furthermore, object-oriented means that operations and object-types
can be grouped to \emph{classes} on which an inheritance relation can
be established; the latter induces a sub-type relation between the
corresponding types.

Here is a feature-list of  \FOCL:
\begin{itemize}
 \item it specifies key built-in types such as \inlineocl+Boolean+,
         \inlineocl+Void+, \inlineocl+Integer+, \inlineocl+Real+ and 
         \inlineocl+String+ as well as generic types such as 
         \inlineocl+Pair(T,T')+, \inlineocl+Sequence(T)+, \inlineocl+Bag(T)+ and \inlineocl+Set(T)+.
 \item it defines the semantics of the operations of these types in 
         \emph{denotational form} (to be explained in \autoref{sec:focl-semantics}),
         and thus in an unambiguous (and in Isabelle/\HOL executable or 
         animatable) way.
       \item it develops the \emph{theory} of these definitions, \ie, the collection 
         of lemmas and theorems that can be proven from these definitions.
 \item all types in  \FOCL contain the elements \inlineocl{null} and \inlineocl{invalid};
         including in particular the \inlineocl+Boolean+ type, 
         so we obtain a four-valued logic. Consequently,  \FOCL contains
         the derivation of the \emph{logic} of \OCL.
 \item collection types may contain
         \inlineocl{null} (so \inlineocl|Set{null}| is a defined set) but not
         \inlineocl{invalid} (\inlineocl|Set{invalid}| is just
         \inlineocl{invalid}).
 \item With respect to the static types, \FOCL is a strongly typed language in
         the Hindley-Milner tradition.
         So the explicit usage of casts are needed whenever for
         example one attempts to apply an attribute $a$ to an object
         $X :: C_i$, and where $a$ has been defined in $C_j$ (so not
         in $C_i$). On the other hand, one can also assume there is a
         pre-processing to automatically introduce these explicit
         conversions (\ie, to remove the need to write
         $\mocl{.oclAsType(}\_\mocl{)}$).\footnote{The details of such
           a pre-processing are present in
           \HOLOCL~\cite{brucker:interactive:2007} and can be
           similarly adapted for \FOCL.}
 \item  \FOCL types may be arbitrarily nested. For example,
         the expression
         $\mocl{Set\{Set\{1,2\}\}} = \mocl{Set\{Set\{2,1\}\}}$
         is legal and true.
 \item  \FOCL types may be higher-order nested. For example,
         the expression $\lambda X. \ap \mocl{Set\{}X\mocl{\}} = \mocl{Set\{Set\{2,1\}\}}$ is legal.
         Higher-order pattern-matching can be easily extended following 
         the principles in the \HOL library, which can be applied also to \FOCL types.
 \item All object types are represented in an object universe\footnote{following
         the tradition of \HOL-\OCL~\cite{brucker.ea:extensible:2008-b}}.
         The universe construction also gives semantics to type casts, dynamic type
         tests, as well as functions such as \inlineocl{allInstances()},
         or \inlineocl{oclIsNew()}. The object universe construction is
         conceptually described and demonstrated at an example.
 \item As part of the \OCL logic,  \FOCL develops the theory of
         equality in \UML/\OCL. This includes the standard equality, which is a
         computable strict equality using the object references for comparison,
         and the not necessarily computable logical equality, which expresses
         the Leibniz principle that ``equals may be replaced by equals'' in
         \OCL terms. 
 \item Technically,  \FOCL is a \emph{semantic embedding} into a
         powerful semantic meta-language and
         environment, namely Isabelle/\HOL~\cite{nipkow.ea:isabelle:2002}.
         It is a so-called \emph{shallow embedding} in \HOL; this means that types
         in \OCL are mapped one-to-one to types in Isabelle/\HOL.
         Ill-typed \OCL specifications can therefore not be represented in
          \FOCL and a type in  \FOCL contains exactly
         the values that are possible in \OCL\@.
% \item It supports equational reasoning and congruence reasoning, but
%         this requires a differentiation of the different equalities like
%         strict equality, strong equality, meta-equality (\HOL). Strict
%         equality and strong equality require a subcalculus, ``cp'' (a
%         detailed discussion of the different equalities as well as the
%         subcalculus ``cp''---for three-valued \OCL 2.0---is given
%         in~\cite{brucker.ea:semantics:2009}), which is nasty but can be
%         hidden from the user inside tools.
\end{itemize}

\paragraph*{Context.} This document stands in a more than fifteen years
tradition of giving a formal semantics to the core of \UML and its
annotation language \OCL, starting from \citet{richters:precise:2002}
and~\cite{hamie.ea:reflections:1998,mandel.ea:ocl:1999,cook.ea::amsterdam:2002},
leading to a number of formal, machine-checked versions, most notably
\HOL-\OCL~\cite{brucker.ea:semantic:2006-b,brucker:interactive:2007,brucker.ea:hol-ocl-book:2006,brucker.ea:extensible:2008-b}
and more recent approaches~\cite{brucker.ea:path-expressions:2013}. All
of them have in common the attempt to reconcile the conflicting
demands of an industrially used specification language and its various
stakeholders, the needs of OMG standardization process and the desire
for sufficient logical precision for tool-implementors, in particular
from the Formal Methods research community.  To discuss the future
directions of the standard, several \OCL experts met in November 2013
in Aachen to discuss possible mid-term improvements of \OCL,
strategies of standardization of \OCL within the OMG, and a vision for
possible long-term developments of the
language~\cite{brucker.ea:summary-aachen:2013}. The participants
agreed that future proposals for a formal semantics should be
machine-check, to ensure the absence of syntax errors, the consistency
of the formal semantics, as well as provide a a suite of corner-cases
relevant for \OCL tool implementors.

\paragraph*{Organization of this document.}
This document is organized as follows. After a brief background section
introducing a running example and basic knowledge on Isabelle/\HOL and its formal
notations, we present the formal semantics of  \FOCL introducing:
\begin{enumerate}
\item A conceptual description of the formal semantics, highlighting the essentials
      and avoiding the definitions in detail.
\item A detailed formal description. This covers:
\begin{enumerate}
\item \OCL Types and their presentation in Isabelle/\HOL,
\item \OCL Terms, \ie, the semantics of library operators,
        together with definitions, lemmas, and test cases for the implementor,
\item \UML/\OCL Constructs, \ie, a core of \UML class models plus user-defined
        constructions on them such as class-invariants and operation contracts.
\end{enumerate}
\item Since the latter, \ie, the construction of \UML class models, has to be done on the meta-level
(so not \emph{inside} \HOL, rather on the level of a pre-compiler), we will describe this process
with two larger examples, namely formalizations of our running example.
\end{enumerate}


%A.1 Object Models
%In this sub clause, the notion of an object model is formally defined.
%An object model provides the context for \OCL expressions and constraints.
%A precise understanding of object models is required before a formal
%definition of \OCL expressions can be given. Sub clause A.1.1 proceeds with a
%formal definition of the syntax of object models. The semantics of object
%models is defined in sub clause A.1.2. This sub clause also defines the
%notion of system states as snapshots of a running system.

\section{Background}
\isatagafp
\subsection{A Running Example for UML/OCL}\label{sec:guidedtour}
The Unified Modelling Language
(\UML)~\cite{omg:uml-infrastructure:2011,omg:uml-superstructure:2011}
comprises a variety of model types for describing static (\eg, class
models, object models) and dynamic (\eg, state-machines, activity
graphs) system properties.
\begin{figure*}
  \centering\scalebox{1}{\includegraphics{figures/AbstractSimpleChair}}%
  \caption{A simple \UML class model representing a conference
    system for organizing conference sessions: persons can
    participate, in different roles, in a session. \label{fig:uml}}
\end{figure*}
One of the more prominent model types of the \UML is the
\emph{class model} (visualized as \emph{class diagram}) for modelling
the underlying data model of a system in an object-oriented manner. As
a running example, we model a part of a conference management
system. Such a system usually supports the conference organizing
process, \eg, creating a conference Website, reviewing submissions,
registering attendees, organizing the different sessions and tracks,
and indexing and producing the resulting proceedings. In this example,
we constrain ourselves to the process of organizing conference
sessions; \autoref{fig:uml} shows the class model.  We model the
hierarchy of roles of our system as a hierarchy of classes (\eg,
\inlineocl{Hearer}, \inlineocl{Speaker}, or \inlineocl{Chair}) using
an \emph{inheritance} relation (also called \emph{generalization}). In
particular, \emph{inheritance} establishes a \emph{subtyping}
relationship, \ie, every \inlineocl{Speaker} (\emph{subclass}) is also
a \inlineocl{Hearer} (\emph{superclass}).

A class does not only describe a set of \emph{instances} (called
\emph{objects}), \ie, record-like data consisting of \emph{attributes}
such as \inlineocl{name} of class \inlineocl{Session}, but also
\emph{operations} defined over them. For example, for the class
\inlineocl{Session}, representing a conference session, we model an
operation \inlineocl{findRole(p:Person):Role} that should return the
role of a \inlineocl{Person} in the context of a specific session;
later, we will describe the behavior of this operation in more detail
using \UML\@. In the following, the term object describes a
(run-time) instance of a class or one of its subclasses.

Relations between classes (called \emph{associations} in \UML)
can be represented in a class diagram by connecting lines, \eg,
\inlineocl{Participant} and \inlineocl{Session} or \inlineocl{Person}
and \inlineocl{Role}. Associations may be labeled by a particular
constraint called \emph{multiplicity}, \eg, \inlineocl+0..*+ or
\inlineocl+0..1+, which means that in a relation between participants
and sessions, each \inlineocl{Participant} object is associated to at
most one \inlineocl{Session} object, while each \inlineocl{Session}
object may be associated to arbitrarily many \inlineocl{Participant}
objects. Furthermore, associations may be labeled by projection
functions like \inlineocl{person} and \inlineocl{role}; these implicit
function definitions allow for \OCL-expressions like
\inlineocl+self.person+, where \inlineocl+self+ is a variable of the
class \inlineocl{Role}. The expression \inlineocl+self.person+ denotes
persons being related to the specific object \inlineocl{self} of
type role. A particular feature of the \UML are \emph{association
  classes} (\inlineocl{Participant} in our example) which represent a
concrete tuple of the relation within a system state as an object;
\ie, associations classes allow also for defining attributes and
operations for such tuples. In a class diagram, association classes
are represented by a dotted line connecting the class with the
association. Associations classes can take part in other associations.
Moreover, \UML supports also $n$-ary associations (not shown in
our example).

We refine this data model using the Object Constraint Language (\OCL)
for specifying additional invariants, preconditions and postconditions
of operations. For example, we specify that objects of the class
\inlineocl{Person} are uniquely determined by the value of the
\inlineocl{name} attribute and that the attribute \inlineocl{name} is
not equal to the empty string (denoted by \inlineocl{''}):
\begin{ocl}
context Person
  inv: name <> '' and
       Person::allInstances()->isUnique(p:Person | p.name)
\end{ocl}
Moreover, we specify that every session has exactly one chair by the
following invariant (called \inlineocl{onlyOneChair}) of the class
\inlineocl{Session}:
\begin{ocl}
context Session
  inv onlyOneChair: self.participants->one( p:Participant |
                                      p.role.oclIsTypeOf(Chair))
\end{ocl}
where \inlineocl{p.role.oclIsTypeOf(Chair)} evaluates to true, if
\inlineocl{p.role} is of \emph{dynamic type}
\inlineocl{Chair}. Besides the usual \emph{static types} (\ie, the
types inferred by a static type inference), objects in \UML and other
object-oriented languages have a second \emph{dynamic} type concept.
This is a consequence of a family of \emph{casting functions} (written
$\typeCast{o}{C}$ for an object $o$ into another class type $C$) that
allows for converting the static type of objects along the class
hierarchy. The dynamic type of an object can be understood as its
``initial static type'' and is unchanged by casts. We complete our
example by describing the behavior of the operation
\inlineocl{findRole} as follows:
\begin{ocl}
context Session::findRole(person:Person):Role
  pre:  self.participates.person->includes(person)
  post: result=self.participants->one(p:Participant |
                                p.person = person ).role
        and self.participants = self.participants@pre
        and self.name = self.name@pre
\end{ocl}
where in post-conditions, the operator \inlineocl{@pre} allows for
accessing the previous state. Note that:
\begin{ocl}
  pre:  self.participates.person->includes(person)
\end{ocl}
is actually a syntactic abbreviation for a contraint referring to
the previous state:
\begin{ocl}
        self.participates@pre.person@pre->includes(person).
\end{ocl}
Note, further, that conventions for full-\OCL permit the suppression
of the \inlineocl$self$-parameter, following similar syntactic conventions
in other object-oriented languages such as Java:
\begin{ocl}
context Session::findRole(person:Person):Role
  pre:  participates.person->includes(person)
  post: result=participants->one(p:Participant |
                                p.person = person ).role
        and participants = participants@pre
        and name = name@pre
\end{ocl}


In \UML, classes can contain attributes of the type of the
defining class.  Thus, \UML can represent (mutually) recursive
datatypes. Moreover, \OCL introduces also recursively specified
operations.

A key idea of defining the semantics of \UML and extensions like
SecureUML~\cite{brucker.ea:transformation:2006} is to translate the
diagrammatic \UML features into a combination of more elementary
features of \UML and \OCL
expressions~\cite{gogolla.ea:expressing:2001}. For example,
associations (\ie, relations on objects) can be implemented in
specifications at the design level by aggregations, \ie, collection-valued 
class attributes together with \OCL constraints expressing the
multiplicity. Thus, having a semantics for a subset of \UML and \OCL is
tantamount for the foundation of the entire method.
\endisatagafp



\subsection{Formal Foundation}

\subsubsection{A Gentle Introduction to Isabelle}
Isabelle~\cite{nipkow.ea:isabelle:2002} is a \emph{generic} theorem
prover. New object-logics can be introduced by specifying their syntax
and natural deduction inference rules. Among many logics, Isabelle
supports First-Order Logic (\FOL), Zermelo-Fraenkel set theory, and for
instance Church's Higher-Order Logic (\HOL).

The core language of Isabelle is a typed $\lambda$-calculus providing
a uniform term language $T$ in which all logical entities are
represented:\footnote{In the Isabelle implementation, there are
  actually two further variants, they are irrelevant for this
  presentation and can be therefore omitted.}
\begin{gather*}
   T \ap\ap \defeq \ap\ap C \ap\ap|\ap\ap V \ap\ap|\ap\ap \lambda V\spot\ap T \ap\ap|\ap\ap T~T
\end{gather*}
where:
\begin{itemize}
\item $C$ is the set of \emph{constant symbols} like operators on
  pairs ``$\operatorname{fst}$'' or
  ``$\operatorname{snd}$''. Isabelle's syntax engine supports mixfix
  notation for terms. ``$(\_ \Longrightarrow \_)~A~B$'' or ``$(\_ +
  \_)~A~B$'' can be parsed and respectively printed as ``$A
  \Longrightarrow B$'' or ``$A + B$''.
\item $V$ is the set of \emph{variable symbols} like $x$, $y$,
  $z$\ldots Variables standing in the scope of a $\lambda$-operator
  are called \emph{bound} variables, all others are \emph{free}
  variables.
\item $\lambda~V\spot \ap T$ is called a \emph{$\lambda$-abstraction}, like as
  example the identity function $\lambda~x. \ap x$. A
  $\lambda$-abstraction forms a scope for the variable $V$.
\item $T~T'$ is called an \emph{application}.  
\end{itemize}
These concepts are not at all Isabelle specific and can be found in many modern programming
languages ranging from Haskell over Python to Java.

Terms are associated to \emph{types} by a set of \emph{type
  inference rules}\footnote{Similar to
\url{https://en.wikipedia.org/w/index.php?title=Hindley\%E2\%80\%93Milner_type_system&oldid=668548458}}. Only
terms for which a type can be inferred are considered as legal input
to the Isabelle system, such terms are \emph{typed terms}. The type
$\tau$ of typed terms can be inductively defined:\footnote{Our
  presentation is again slightly different than the Isabelle
  implementation to improve readability.}
\begin{gather*}
\tau \ap\ap \defeq \ap\ap TV \ap\ap|\ap\ap TV :: \Xi \ap\ap|\ap\ap \tau~\Rightarrow~\tau \ap\ap|\ap\ap (\tau, \ldots, \tau)\ap TC
\end{gather*}
\begin{itemize}
\item $TV$ is the set of \emph{type variables} like $'\alpha$,
  $'\beta$, \ldots The syntactic categories $V$ and $TV$ are disjoint,
  thus $'x$ is a possible type variable.
\item $\Xi$ is a set of
  \emph{type-classes} like
  ``$\operatorname{ord}$'', ``$\operatorname{order}$'',
  ``$\operatorname{linorder}$''\ldots This feature in the Isabelle
  type system is inspired by Haskell type classes.\footnote{See \url{https://en.wikipedia.org/w/index.php?title=Type_class&oldid=672053941}.}  A \emph{type class
    constraint} such as $'\alpha::\operatorname{order}$ expresses that
  the type variable $'\alpha$ may range over any type that has the
  algebraic structure of a partial ordering (as it is configured in
  the Isabelle/\HOL library).
\item The type $\tau_1$ $\Rightarrow$ $\tau_2$ denotes the total
  function space from $\tau_1$ to $\tau_2$.
\item $TC$ is a set of \emph{type constructors} like
  ``$('\alpha)\operatorname{list}$'' or
  ``$('\alpha)\operatorname{tree}$''. Again, Isabelle's syntax engine
  supports mixfix notation for type terms: \eg cartesian products
  $'\alpha$ $\times$ $'\beta$ are understood as $('\alpha,'\beta)
  \operatorname{prod}$. Also null-ary type-constructors like
  ``$()\operatorname{bool}$'', ``$()\operatorname{nat}$'' and
  ``$()\operatorname{int}$'' are possible, although the parentheses of
  nullary type constructors are usually omitted.
\end{itemize}
In the following, to designate elements in $TV$, we will usually omit
the quote ``$'$'' symbol in front of lowercase Greek letters.

Isabelle accepts also the notation $t :: \tau$ as type assertion in
the term language, where $t :: \tau$ means ``$t$ is required to have
the type $\tau$''. The type of typed terms \emph{can} contain free
type variables, like in the types of $x$ and $y$ when the system is
automatically inferring this term $x + y = y + x$. By convention, free
type variables are implicitly universally quantified.\footnote{Here, we assume that $\_ + \_$ and $\_ = \_$ are
  declared constant symbols having type
  $\operatorname{int} \Rightarrow \operatorname{int} \Rightarrow
  \operatorname{int}$
  and $'\alpha \Rightarrow '\alpha \Rightarrow \operatorname{bool}$,
  respectively.}

An environment providing $\Xi$, $TC$ and a map from constant symbols
$C$ to types (built over these $\Xi$ and $TC$) is called a
\emph{global context}. It provides a kind of signature or a mechanism
to construct the syntactic material of a logical theory.

The most basic (built-in) global context of Isabelle provides just a
language to construct logical rules. More concretely, it provides a
constant declaration for the (built-in) \emph{meta-level implication}
$\_ \ap\Implies\ap \_$ allowing to form constructs like $A_1
\ap\Implies\ap \cdots \ap\Implies\ap A_n \ap\Implies\ap A_{n+1}$,
which are viewed as a \emph{rule} of the form ``from assumptions $A_1$
to $A_n$, infer conclusion $A_{n+1}$'' and which is written in
Isabelle syntax as:
\begin{gather*}
  \semantics{A_1 ; \ldots; A_n}\ap\Implies\ap A_{n+1}
  \quad
  \text{or also usually seen as:}
  \quad
  \begin{prooftree}
    A_1 \quad \cdots \quad A_n
    \justifies
    A_{n+1}
  \end{prooftree}
\end{gather*}
Moreover, the built-in meta-level quantification
$\operatorname{Forall} (\lambda x. \ap E \ap x)$, pretty-printed and
parsed as $\Forall x\spot E~x$, captures the usual side-constraints
``$x$ must not occur free in the assumptions'' for quantifier rules.
Meta-quantified variables can be considered as ``fresh'' free
variables. Meta-level quantification leads to a generalization of
Horn-clauses of the form:
\begin{gather*}
\Forall x_1, \ldots, x_m\spot \semantics{A_1 ; \ldots; A_n} \ap\Implies\ap
A_{n+1}
\end{gather*}

Isabelle supports forward and backward reasoning on rules. For
backward-reasoning, a \emph{proof-state} can be initialized in a given 
global context and further transformed during the proof. For example,
a proof of $\phi$, using the
Isabelle/Isar~\cite{wenzel:isabelleisar:2002} language, will look as
follows in Isabelle:
\begin{gather*}
  \begin{array}{l}
    \Lemma{label} \phi\\
    \quad\apply{case\_tac}\\
    \quad\apply{simp\_all}\\
  \done
  \end{array}
\end{gather*}
This proof script instructs the Isabelle system to prove
$\phi$ by case distinction followed by a simplification of all
resulting proof states. Such a proof state is a
sequence of generalized Horn-clauses (called \emph{subgoals})
$\phi_1$, \ldots, $\phi_n$ with a \emph{goal} $\phi$. Proof states are
usually represented in mathematical textbooks as:
\begin{gather*}
\begin{array}{rl}
\pglabel{label}:& \phi \\
 1.& \phi_1 \\
    &\vdots \\
 n.& \phi_n\\
\end{array}
\end{gather*}
Subgoals and goals may be extracted from the proof state into theorems
of the form $\semantics{\phi_1 ; \ldots; \phi_n} \ap\Implies\ap \phi$
at any time.
% ; this mechanism helps to generate test theorems.  
% Further, Isabelle supports meta-variables (written $\meta{x}, \meta{y},
% \ldots$), which can be seen as ``holes in a term'' that can still be
% substituted. Meta-variables are instantiated by Isabelle's built-in
% higher-order unification.

By extending global contexts with theorems, axioms and proofs, we get
at the end a \emph{theory} which has been constructed step by
step. Beyond the basic mechanism of extending a global context with
raw types (with type constructors, type class, constant definitions,
or axioms), Isabelle offers a number of \emph{commands} that allow for
more complex extensions of theories in a logically safe way, \ie, by
directly avoiding the use of axioms.

\subsubsection{Higher-Order Logic (HOL)}
\emph{Higher-Order Logic}
(\HOL)~\cite{church:types:1940,andrews:introduction:2002} is a
classical logic based on a simple type system. Isabelle/\HOL is a
theory extension of the basic Isabelle core language with operators
and the seven axioms of \HOL. Together with large libraries, the
overall constitutes an implementation of \HOL.
Isabelle/\HOL provides the usual logical connectives like $\_ \land
\_$, $\_ \implies\_$, $\lnot \_ $ as well as the object logical
quantifiers $\forall x\spot P\ap x$ and $\exists x\spot P\ap x$. In
contrast to \FOL, quantifiers may range over arbitrary types, including
total functions $f \ap\ofType\ap \tau_1 \Rightarrow \tau_2$. \HOL is
centered around extensional equality $\_ = \_ \ap\ofType\ap \alpha
\Rightarrow \alpha \Rightarrow \text{bool}$. Extensional equality
means that two functions $f$ and $g$ are equal if and only if they are
point-wise equal. This is captured by the rule: $(\Forall~x\spot f~x =
g~x) \Longrightarrow f = g$.  \HOL is more expressive than \FOL, since
among many other things, induction schemes can be expressed inside the
logic. For example, the standard induction rule on natural numbers in
\HOL:
\begin{gather*}
  P~0 \Longrightarrow (\Forall~x\spot P~x \Longrightarrow P~(x+1)) \Longrightarrow P~x
\end{gather*}
is just an ordinary rule in Isabelle which is in fact a proven theorem
in the theory of natural numbers. This example exemplifies an
important design principle of Isabelle: theorems and rules are
technically the same, paving the way to \emph{derived rules} and
automated decision procedures based on them. This has the consequence
that these procedures are consequently sound by construction with
respect to their logical aspects (they may be incomplete or failing,
though).

On the one hand, Isabelle/\HOL can be viewed as a functional
programming language like SML or
Haskell, by reading Isabelle/\HOL definitions as one is reading any
declarations in a functional \textbf{programming} language, \ie by
omitting the reading of Isar proof scripts. Conversely, type
definitions in a functional programming language can be viewed as
formulae part of the \textbf{specification} language of
Isabelle/\HOL.

%Isabelle/HOL is a logical embedding of HOL into Isabelle.  The
%(original) simple-type system underlying HOL has been extended by
%Hindley-Milner style polymorphism with type-classes similar to
%Haskell.  
%While Isabelle/HOL is usually seen as proof assistant, we
%use it as symbolic computation environment. Implementations on top of
%Isabelle/HOL can re-use existing powerful deduction mechanisms such as
%higher-order resolution, tableaux-based reasoners, rewriting
%procedures, Presburger arithmetic, and via various integration
%mechanisms, also external provers such as
%Vampire~\cite{riazanov.ea:vampire:1999} and the SMT-solver
%Z3~\cite{moura.ea:z3:2008}.

Isabelle/\HOL offers support for a particular methodology to extend
given theories in a logically safe way: a theory extension is
\emph{conservative} if the provability of a formula in the extended
theory is the same as in the original theory. Then the consistency of
an extended theory depends on the consistency of the original
one. Conservative extensions apply to different families of
definitions: \emph{constant definitions}, \emph{type definitions},
\emph{datatype definitions}, \emph{primitive recursive definitions}
and \emph{well founded recursive definitions}.

Isabelle/\HOL provides a large collection of theories like sets,
lists, orderings, and various arithmetic theories. Theories only
contain rules derived from conservative definitions. As an example of
conservative extension, the library includes the type
constructor $\up{\tau} \defeq \isasymbottom | \lift{\_ \ap\ofType\ap
  \alpha}$ that assigns to each type $\tau$ a type $\up{\tau}$
\emph{disjointly extended} by the exceptional element
$\isasymbottom$. The function $\drop{\_} \ap\ofType\ap \up{\alpha} \to
\alpha$ is the inverse of $\lift{\_}$ (it is unspecified for
$\isasymbottom$). Partial functions $\alpha \ap \isasymrightharpoonup
\ap \beta$ are defined as functions $\alpha \ap \isasymRightarrow \ap
\up{\beta}$ supporting the usual concepts of domain ``$\dom\ap\_$''
and range ``$\ran\ap\_$''.

As another example, typed sets are conservatively built in the
Isabelle libraries on top of the kernel of \HOL as functions to
$\HolBoolean$. Consequently, the constant definitions for membership
is as follows:\footnote{To increase readability, we use a slightly
  simplified presentation. The complete details can be inspected in
  \texttt{\$ISABELLE\_HOME/src/HOL/Set.thy} (in Isabelle version
  2016).}
\begin{gather*}
  \begin{array}{lr@{}l@{}ll}
    \typesynonym& \HolSet{\alpha}            &&= \alpha \Rightarrow \HolBoolean\\[.5ex]
    \isardef &\operatorname{Collect}&&\ofType \ap (\alpha \Rightarrow \HolBoolean) \Rightarrow \HolSet{\alpha}  &\text{--- set comprehension}\\
     \where &\operatorname{Collect} & \ap S      & \ap \equiv S\\[.5ex]
     \isardef &\operatorname{member}           &&\ofType \ap \alpha \Rightarrow \HolSet{\alpha} \Rightarrow \HolBoolean &\text{--- membership test}\\
     \where &\operatorname{member} & \ap s\ap S &\ap \equiv S s
  \end{array}
\end{gather*}
Isabelle's syntax engine is instructed to accept the notation $\{x
\mid P\}$ for $\operatorname{Collect}\ap(\lambda x\spot P)$ and the
notation $s \in S$ for $\operatorname{member}\ap s\ap S$. As it can be
inferred from the example, constant definitions are axioms that
introduce a fresh constant symbol (which must not be based on a
recursive expression, or having free variables). This type of axiom is
logically safe since it works like an abbreviation. The syntactic side
conditions of so-introduced axioms are mechanically checked. Then it
becomes straightforward to express the usual operations on sets as
conservative extensions too, like for example $\_ \cup \_$,
$\_\cap\_\ofType\HolSet{\alpha} \Rightarrow \HolSet{\alpha}
\Rightarrow \HolSet{\alpha}$.

Similarly, a set of logical rules are ``compiled'' from the following
statements, which introduce the types $\operatorname{option}$ and
$\operatorname{list}$:
\begin{gather*}
  \begin{array}{lrlll}
    \datatype & \alpha \ap \operatorname{option}      &= \operatorname{None} &&\mid \operatorname{Some} \ap \alpha\\[.5ex]
    \datatype & \alpha \ap \operatorname{list} &= \operatorname{Nil} & (\text{``[]''}) &\mid \operatorname{Cons}\ap \alpha \ap \text{``$\alpha \operatorname{list}$''} \quad ({\greenkeywordstyle\operatorname{infixr}} \ap \text{``\#''} \ap 65)
  \end{array}
\end{gather*}
Here ``$[]$'' or ``$\_ \# \_$'' are an alternative syntax for
$\operatorname{Nil}$ or $\operatorname{Cons}\ap a ~l$. Moreover, the
commands $\holoclthykeywordstyle\operatorname{syntax}$ and
$\holoclthykeywordstyle\operatorname{translations}$
can additionally (recursively) define $[a, b, c]$ as an alternative
syntax for $a\#b\#c\#[]$. Besides the \emph{constructors} $\HolNone$,
$\HolSome$, $[]$ and $\operatorname{Cons}$, there is the matching
operation to conditionally return a term by case analysis provided a
general term $x$, whose type has been defined with $\datatype$, as
example:
\begin{gather*}
\HolCase\ap x\ap\HolOf \ap \operatorname{None} \ap \isasymRightarrow \ap F\ap \mid \ap
\operatorname{Some} \ap a \ap \isasymRightarrow \ap G\ap a
\end{gather*}
The $\datatype$ package automatically derives a set of properties in
front of each command
$\datatype$. One
way to understand this command is to view it as a kind of macro
(albeit its syntax is inspired by functional programming languages),
which generates a number of constant definitions and theorems from the
type declaration $\operatorname{option}$ or $\operatorname{list}$. So
the generated lemmas are also implicitly proved in the background,
this command constructs a model of the constructors and derive its
properties:
\begin{gather*}
  \begin{array}{ll}
    (\HolCase\ap[]\ap\HolOf\ap[] \Rightarrow F  \ap | \ap  (a\#r) \Rightarrow
    G\ap a\ap r) = F &\\
    (\HolCase \ap  b\#t  \ap \HolOf  \ap [] \Rightarrow F  \ap  | \ap
    (a\#r) \Rightarrow G\ap a\ap r) = G~b~t &\\ %
    \mbox{}[] \neq a\#t    &\text{-- distinctness} \\
    (a = [] \Longrightarrow P) \Longrightarrow
    (\Forall x \ap t\spot  a = x\#t \Longrightarrow P) \Longrightarrow
    P &\text{-- exhaust} \\
    P \ap [] \Longrightarrow ( \Forall \ap a \ap t\spot P \ap t \Longrightarrow  P (a\#t) ) \Longrightarrow P \ap x      &\text{-- induct}
  \end{array}
\end{gather*}
Besides $\datatype$, other packages are natively present when starting
Isabelle. For example the $\fun$ command serves to define well-founded
recursive
functions. Thus, we
may define the $\operatorname{sort}$ operation on linearly ordered
lists as follows:
\begin{gather*}
  \begin{array}{lll}
    \fun
    &\enspace\operatorname{ins} & \ofType
    [\alpha\ofType\mathrm{linorder}, \HolList{\alpha}]
    \Rightarrow
    \HolList{\alpha}\\
    \where
    &\enspace \operatorname{ins}\ap x \ap  [\;] &= [x]\\
    &\enspace \operatorname{ins}\ap x \ap (y\# ys)&=
    \HolIf x < y \ap
    \HolThen \ap x\#  y \# ys \ap
    \HolElse \ap y\#(\operatorname{ins} \ap x \ap ys)
 \end{array}\\
  \begin{array}{lll}
    \fun
    &\enspace\operatorname{sort} & \ofType
    \HolList{(\alpha\ofType\mathrm{linorder})}
    \Rightarrow
    \HolList{\alpha}\\
    \where
    &\enspace \operatorname{sort}\ap [\;] &= [\;]\\
    &\enspace \operatorname{sort} (x\# xs)&=
    \operatorname{ins}\ap x\ap (\operatorname{sort}\ap xs)
   \end{array}
\end{gather*}
Similar as $\datatype$, the $\fun$ command can again be seen as a kind
of macro: a conservative construction is implied; the derivation of
the equations $\operatorname{ins}\ap x \ap [\;] = [x]$ and
$\operatorname{ins}\ap x \ap (y\# ys) = \HolIf x < y \ap \HolThen \ap
x\# y \# ys \ap \HolElse \ap y\#(\operatorname{ins} \ap x \ap ys)$ is
done automatically involving a termination proof (most of the time
automatically proved for basic functions). This involved construction
assures logical safeness: in general, just adding axioms for recursive
equations causes inconsistency for non-terminating functions. The
resulting equations can now be used in the Isabelle simplifier.

The library of Isabelle/\HOL constitutes a comfortable basis for
defining the \OCL library or embed a specification language.  In
particular, Isabelle manages a set of \emph{executable types and
  operators}, \ie, types and operators for which a compilation to
external languages is possible, using
\emph{code-generation}. The
supported external languages in Isabelle for code-generation are
currently Haskell, OCaml, Scala and
SML. As one example, arithmetic types such as $\text{int}$ are
appropriately optimized to be executed fast depending on the chosen
external language. Datatypes and recursive functions are as well
supported to be executed in these external languages (assuming their
definitions contain only executable operators).

Another mean to do executions in Isabelle is to use the
$\holoclthykeywordstyle\operatorname{value}$ command (whose
functioning resembles to how code-generation
works). Then, after typing
$\holoclthykeywordstyle\operatorname{value}$ ``$3 + 7$'' in
Isabelle/jEdit, we
will get $10$ as result. Generally
$\holoclthykeywordstyle\operatorname{value}$ can work with many ground
expressions (with no free variables). So most of \OCL ground terms are
in fact executable in Isabelle, due to prior special setups in the
\FOCL library.

% Similarly, Isabelle
%manages a large set of (higher-order) rewrite rules into which
%recursive function definitions were included. Provided that this
%rule set represents a terminating and confluent rewrite system, the
%Isabelle simplifier provides also a highly potent decision procedure
%for many fragments of theories underlying the constraints to be
% processed when constructing test theorems.

\isatagafp
\subsection{How this Document was Generated from Isabelle/HOL Theories}
\endisatagafp
\isatagannexa
\subsection{How this Annex A was Generated from Isabelle/HOL Theories}
\endisatagannexa
\begin{figure*}[tb]
  \mbox{}\hfill
  \subfloat%
  [The Isabelle jEdit environment. ]%
  {\label{fig:jedit} \includegraphics[height=6.2cm]{jedit}}%
  \hfill%
  \hfill%
    \subfloat[The generated formal document.]%
    {\label{fig:pdf} \includegraphics[height=6.2cm]{pdf}}
    \hfill\mbox{}
  \caption{Generating documents with guaranteed  syntactical and
    semantical consistency.}
  \label{fig:gener-docum-where}
\end{figure*}
Isabelle, as a framework for building formal
tools~\cite{wenzel.ea:building:2007},
provides the means for generating \emph{formal documents}. With formal
documents (such as the one the reader is reading) we refer to
documents that are machine generated with a process ensuring certain
formal guarantees. In particular, all the textual content manipulating
definitions, formulae, \ldots, types are checked for consistency
during the document generation.

For writing documents, Isabelle supports the embedding of informal
texts using a \LaTeX{} based markup language within the theory
files. One other alternative to embed informal documents is to
directly write \LaTeX{} code in usual ``$\_$\verb|.tex|'' files, and
then link them with the formal content generated by
Isabelle. Generally, by manually inspecting the source code of
Isabelle theory files, one can have a clear estimation of the size of
informal texts versus formal texts of a given project. 

Still, to ensure consistencies of certain informal parts, Isabelle
supports the use of \emph{antiquotations} within informal texts, that
refer to the formal parts and that are checked while generating the
actual document as PDF\@. For example, in an informal text, the
antiquotation ``\verb|@{|$\holoclthykeywordstyle\operatorname{thm}$ $OclNot\_not$\verb|}|'' will instruct
Isabelle to abort the generation with an error in case no \OCL
theorems with the name $OclNot\_not$ were found, otherwise the system
will replace the antiquotation with the actual theorem, \ie
``$\mocl{not} \ap (\mocl{not} \ap X) = X$''.

\autoref{fig:gener-docum-where}
illustrates this approach: \autoref{fig:jedit} shows the jEdit-based
development environment of Isabelle with an excerpt of one of the core
theories of \FOCL\@. \autoref{fig:pdf} shows the generated
PDF document where all antiquotations are replaced. Moreover,
the document generation tools allows for defining syntactic sugar as
well as skipping technical details of the formalization.

\isatagannexa
Thus, applying the  \FOCL approach to writing an updated
Annex A that provides a formal semantics of the most fundamental
concepts of \OCL ensures
\begin{enumerate}
\item that all formal context is syntactically correct and well-typed,
  and
\item all formal definitions and the derived logical rules are
  semantically consistent.
\end{enumerate}
% Overall, this would contribute to one of the main goals of the \OCL 2.5
% RFP, as discussed at the \OCL meeting in
% Aachen~\cite{brucker.ea:summary-aachen:2013}.
\endisatagannexa
\isatagafp
Featherweight OCL is a formalization of the core of OCL
aiming at formally investigating the relationship between the
various concepts. At present, it does not attempt to define the complete
OCL library. Instead, it concentrates on the core concepts of
OCL as well as the types \inlineocl{Boolean},
\inlineocl{Integer}, and typed sets (\inlineocl|Set(T)|).  Following
the tradition of
HOL-OCL~\cite{brucker.ea:hol-ocl:2008,brucker.ea:hol-ocl-book:2006},
Featherweight OCL is based on the following principles:
\begin{enumerate}
\item It is an embedding into a powerful semantic meta-language and
  environment, namely
  Isabelle/HOL~\cite{nipkow.ea:isabelle:2002}.
\item It is a \emph{shallow embedding} in HOL; types
  in OCL were injectively mapped to types in Featherweight
  OCL\@. Ill-typed OCL specifications cannot be represented in
  Featherweight OCL and a type in Featherweight OCL contains exactly
  the values that are possible in OCL\@. Thus, sets may contain
  \inlineocl{null} (\inlineocl|Set{null}| is a defined set) but not
  \inlineocl{invalid} (\inlineocl|Set{invalid}| is just
  \inlineocl{invalid}).
\item Any Featherweight OCL type contains at least
  \inlineocl{invalid} and \inlineocl{null} (the type \inlineocl{Void}
  contains only these instances). The logic is consequently
  four-valued, and there is a \inlineocl{null}-element in the type
  \inlineocl{Set(A)}.
\item It is a strongly typed language in the Hindley-Milner tradition.
  We assume that a pre-process eliminates all implicit conversions due
  to sub-typing by introducing explicit casts (\eg,
  \inlineocl{oclAsType()}). The details of such a pre-processing are
  described in~\cite{brucker:interactive:2007}.  Casts are semantic
  functions, typically injections, that may convert data between the
  different Featherweight OCL types.
\item All objects are represented in an object universe in the HOL-OCL
  tradition~\cite{brucker.ea:extensible:2008-b}. The universe
  construction also gives semantics to type casts, dynamic type
  tests, as well as functions such as \inlineocl{oclAllInstances()},
  or \inlineocl{oclIsNew()}.
\item Featherweight OCL types may be arbitrarily nested. For example,
  the expression
  \inlineocl|Set{Set{1,2}} = Set{Set{2,1}}| is legal and true.
\item For demonstration purposes, the set type in Featherweight OCL
  may be infinite, allowing infinite quantification and a constant
  that contains the set of all Integers.  Arithmetic laws like
  commutativity may therefore be expressed in OCL itself.  The
  iterator is only defined on finite sets.
\item It supports equational reasoning and congruence reasoning, but
  this requires a differentiation of the different equalities like
  strict equality, strong equality, meta-equality (HOL). Strict
  equality and strong equality require a sub-calculus, ``cp'' (a
  detailed discussion of the different equalities as well as the
  sub-calculus ``cp''---for three-valued OCL 2.0---is given
  in~\cite{brucker.ea:semantics:2009}), which is nasty but can be
  hidden from the user inside tools.
\end{enumerate}
Overall, this would contribute to one of the main goals of the \OCL 2.5
RFP, as discussed at the \OCL meeting in
Aachen~\cite{brucker.ea:summary-aachen:2013}.
\endisatagafp


\section{The Essence of UML/OCL Semantics}\label{sec:focl-semantics}
\subsection{The Theory Organization}
The semantic theory is organized in several
\emph{semantic layers}. The following three layers will provide a
``minimal'' core semantics of built-in data-structures, so to support
in particular the \OCL type \inlineocl+Boolean+.
\begin{itemize}
\item The first layer, called the \emph{denotational semantics}
  comprises a set of definitions of the operators of the language.
  Presented as \emph{definitional axioms} inside Isabelle/\HOL, this
  part assures the logically consistency of the overall
  construction. The denotational definitions of types, constants and
  operations, and \OCL contracts represent the ``gold standard'' of
  the semantics.
\item The second layer, called \emph{logical layer}, is derived from
  the former and centered around the notion of validity of an \OCL
  formula $P$. For a state-transition from pre-state $\sigma$ to
  post-state $\sigma'$, a validity statement is written $(\sigma,
  \sigma') \isasymMathOclValid P$. Its major purpose is to logically
  establish facts (lemmas and theorems) about the denotational
  definitions.
\item The third layer, called \emph{algebraic layer}, also derived
  from the former layers, tries to establish algebraic laws of the
  form $P = P'$; such laws are amenable to equational reasoning and
  also help for automated reasoning and code-generation. For an
  implementor of an \OCL compiler, these consequences are of most
  interest.
\end{itemize}

Then come the next semantic layers covering construction of \UML class
models, composed of:
\begin{itemize}
\item the \emph{state layer} describing state-related operations like
        \mocl{allInstances()}, and
\item the \emph{object-oriented datatype layers} giving semantics to
  \UML class models over this, comprising the theory of accessors,
  type casts and tests.
\end{itemize}

For space reasons, we will restrict ourselves in this document to a
few operators and make a traversal through all five layers to give a
high-level description of our formalization. Especially, the details
of the semantic construction for sets, sequences, bags are excluded
from a presentation here.


\subsection{Denotational Semantics of Types}
\begin{defholsimple}[\UML/\OCL types]
The syntactic material for type expressions, called
$\operatorname{TYPES}(C,E)$, is inductively defined as follows:
\begin{itemize}
\item $C \subseteq \operatorname{TYPES}(C,E)$ are object types.

\item $E \subseteq \operatorname{TYPES}(C,E)$ are enumerate
  types. Enumerate types are basically sum types: a form of Isabelle
  $\datatype$ without polymorphic parameters.

\item \inlineocl+Void+, \inlineocl+Boolean+, \inlineocl+Integer+,
  \inlineocl+Real+, \inlineocl+String+ are base types $\text{T}_{base}
  \subseteq \operatorname{TYPES}(C,E)$.

\item $\tysequence_m\mocl{(}X\mocl{)}$,
  $\mocl{Set}_m\mocl{(}X\mocl{)}$, and
  $\mocl{Pair(}X\mocl{,}Y\mocl{)}$ are collection
  types in $\operatorname{TYPES}(C,E)$ if $X, Y \in
  \operatorname{TYPES}(C,E)$.

  These collection types are particular dependent
  types: the multiplicity $m$ is a list of
  intervals constraining the size of the corresponding sequence or
  set. An interval $\mocl{[}i_{min} \mocl{..} i_{max}\mocl{]}$ is
  composed of two lifted naturals $\operatorname{nat}$ of the form
  $(\up{\operatorname{nat}} \times \up{\operatorname{nat}})$ where the
  bottom element is conventionally represented as a star
  ``$\mocl{*}$'', this additional element means an arbitrary allowed
  number. For a sequence or set to be classified as well-typed, it
  must exist one interval in the list $m$ such that $i_{min} \le s \le
  i_{max}$, with $s$ the size of the sequence or set.

  Whenever $m$ evaluates to the interval $\mocl{*}$\footnotemark, the
  multiplicity information can be omitted and in this case we will
  just write $\tysequence\mocl{(}X\mocl{)}$ and
  $\mocl{Set(}X\mocl{)}$.

  A syntactic sugar is provided for building arbitrary
  tuples: $\mocl{(}X_1\mocl{,}\cdots\mocl{,}X_n\mocl{)}$ is a
  shorthand for $\mocl{Pair(}X_1\mocl{,}\cdots
  \mocl{Pair(}X_{n-2}\mocl{,Pair(}X_{n-1}\mocl{,}X_n\mocl{))} \cdots
  \mocl{)}$ for $n \ge 2$.
  Types in tuples can be preceded with additional labelling variables
  $\mocl{(}x_1\mocl{:}X_1\mocl{,}\cdots\mocl{,}x_n\mocl{:}X_n\mocl{)}$
  where $x_1, \cdots, x_n$ are labels for naming individuals of the
  respective types $X_1, \cdots, X_n$. These labels are typically used
  when defining \UML/\OCL contracts.

\item
  $X\mocl{:}Y$ are functional types in $\operatorname{TYPES}(C,E)$ if
  $X, Y \in \operatorname{TYPES}(C,E)$.

  Like tuples, $\mocl{(}x\mocl{:}X\mocl{)}\mocl{:}Y$ is an additional
  syntax for describing functional types, where $x$ is a stamped
  label.
  Functional types mainly appear together with tuples when writing
  \UML/\OCL contracts.
  Depending on the context, in positions where no ambiguities with
  tuples occur, functional types can be shorten to
  $\mocl{(}x_1\mocl{:}X_1\mocl{,}\cdots\mocl{,}x_n\mocl{:}X_n\mocl{)}$
  (where $n \ge 1$), in this case the absent type $Y$ has
  the same semantics as $\mocl{Void}$.

  As another notation, we can use $X\mocl{->}Y$ to represent
  functional types. Thus
  $\mocl{(}X_1\mocl{,}\cdots\mocl{,}X_n\mocl{)}\mocl{->}Y$ can be used
  without labelling names (as this does not conflict with tuples).
\end{itemize}
We define $\operatorname{TYPES}_0(C,E)$ as the smallest subset of
$\operatorname{TYPES}(C,E)$ built without using functional types in all
recursive calls.
In the following, $\operatorname{TYPES}_0(C,E)$ and $\operatorname{TYPES}(C,E)$ will be respectively shorten to $\operatorname{TYPES}_0$ and $\operatorname{TYPES}$.
\end{defholsimple}\footnotetext{The
    interval $\mocl{*}$ is a shortcut for $\mocl{[*..*]}$. We will
    abbreviate intervals $\mocl{[}i_{min} \mocl{..} i_{max}\mocl{]}$
    by a single $i_{min}$ if we have $i_{min} = i_{max}$.}

Types were directly represented in \FOCL by types in \HOL; consequently,
any \FOCL type must provide elements for a bottom element (also denoted $\bot$)
and a null element; this is enforced in Isabelle by a type-class $\TCnull$ that
contains two distinguishable elements $\HolBot$ and $\HolNull$ 
(see \autoref{sec:focl-types} for the details of the construction).

Moreover, the representation mapping from \OCL types to \FOCL is
one-to-one (\ie, injective), and the corresponding \FOCL types were
constructed to represent \emph{exactly} the elements (``no junk, no confusion
  elements'') of their \OCL counterparts. The corresponding \FOCL types were
constructed in two stages: First, a \emph{base type} is constructed whose
carrier set contains exactly the elements of the \OCL type. Secondly, this
base type is lifted to a \emph{valuation} type that we use for type-checking
\FOCL constants, operations, and expressions. The valuation type takes into account
that some \UML-\OCL functions of its \OCL type (namely: accessors in path-expressions)
depend on a pre- and a post-state.

For most base types like $\text{Boolean}_{\text{base}}$ or 
$\text{Integer}_{\text{base}}$, it suffices to double-lift a \HOL library type:
\begin{gather*}
\typesynonym \qquad  \text{Boolean}_{\text{base}} = \up{{\up{bool}}}
\end{gather*}
As a consequence of this definition of the type, we have the elements
$\isasymbottom, \lift{\isasymbottom}, \lift{\lift{\HolTrue}},
\lift{\lift{\HolFalse}}$ in the carrier-set of  $\text{Boolean}_{\text{base}}$. 
We can therefore use the element$\isasymbottom$ to define the generic type 
class element $\bot$ and $\lift{\bot}$ for the generic type class $\HolNull$.
For collection types and object types this definition
is more evolved (see \autoref{sec:focl-types}).

For object base types, we assume a typed universe $\isaAA$ of objects to be 
discussed later, for the moment we will refer it by its polymorphic variable.

With respect the valuation types for \OCL expression in general and Boolean 
expressions in particular, they depend on the pair $(\sigma, \sigma')$ of 
pre-and post-state. Thus, we define valuation types by the synonym:
\begin{gather*}
\typesynonym \qquad  \V{\isaAA}{\alpha} = (\state{\isaAA} \times 
                                \state{\isaAA} \to \alpha \ofType \TCnull) \mi{.}
\end{gather*}
The valuation type for boolean,integer, etc. \OCL terms is therefore defined as:
\begin{gather*}
\typesynonym \qquad \text{Boolean}_{\isaAA} = \V{\isaAA}{\text{Boolean}_{\text{base}}} \\
\typesynonym \qquad \text{Integer}_{\isaAA} = \V{\isaAA}{\text{Integer}_{\text{base}}} \\
\ldots
\end{gather*}
the other cases are analogous. In the subsequent subsections, we will drop the 
index $\isaAA$ since it is constant in all formulas and expressions except for 
operations related to the object universe construction in \autoref{sec:universe}

The rules of the logical layer (there are no algebraic rules related to the 
semantics of types), and more details can be found in  \autoref{sec:focl-types}.

\subsection{Denotational Semantics of Constants and Operations}
We use the notation $I\semantics{E}\tau$ for the semantic interpretation 
function as commonly used in mathematical textbooks and the variable $\tau$ 
standing for pairs of pre- and post state $(\sigma, \sigma')$. Note that we will 
also use $\tau$ to denote the \emph{type} of a state-pair; since both syntactic 
categories are independent, we can do so without arising confusion. \OCL 
provides for all \OCL types the constants \mocl{invalid} for the exceptional 
computation result and \mocl{null} for the non-existing value. Thus we define:
\begin{gather*}
\begin{alignedat}{3}
I\semantics{\mocl{invalid}\ofType V(\alpha)} \tau &\equiv \HolBot &
\qquad I\semantics{\mocl{null}\ofType V(\alpha)}  \tau    &\equiv \HolNull\\
\end{alignedat}
\end{gather*}
For the concrete \mocl{Boolean}-type, we define similarly the boolean constants 
$\mocl{true}$ and $\mocl{false}$ as well as the fundamental tests for definedness 
and validity (generically defined for all types):
\begin{gather*}
\begin{alignedat}{3}
I\semantics{\mocl{true}\ofType\mocl{Boolean}} \tau &= \lift{\lift{\HolTrue}} &
\qquad I\semantics{\mocl{false}} \tau &= \lift{\lift{\HolFalse}}\\
\end{alignedat}\\
I\semantics{X\mocl{.oclIsUndefined()}} \tau =
    (\HolIf I\semantics{X}\tau \in \{\HolBot, \HolNull\} \HolThen I\semantics{\mocl{true}}\tau \HolElse I\semantics{\mocl{false}}\tau)\\
 I\semantics{X\mocl{.oclIsInvalid()}} \tau =
    (\HolIf I\semantics{X}\tau = \HolBot \HolThen I\semantics{\mocl{true}}\tau \HolElse I\semantics{\mocl{false}}\tau)
\end{gather*}

Due to the used style of semantic representation (a shallow embedding) $I$ is 
in fact superfluous and defined semantically as the identity $\lambda x.~x$; 
instead of:
\begin{gather*}
I\semantics{\mocl{true}\ofType\mocl{Boolean}} \tau = \lift{\lift{\HolTrue}}
\shortintertext{we can therefore write:}
\mocl{true}\ofType\mocl{Boolean}  = \lambda \tau.  \lift{\lift{\HolTrue}}
\end{gather*}
In Isabelle theories, this particular presentation of definitions
paves the way for an automatic check that the underlying equation
has the form of an \emph{axiomatic definition} and is therefore logically safe.

\isatagannexa
Since all operators of the assertion language depend on the context 
$\tau$ = $(\sigma, \sigma')$ and result in values that can be $\isasymbottom$, 
all expressions can be viewed as \emph{evaluations} from $(\sigma, \sigma')$ to 
a type $\alpha$ which must posses a $\bottom$ and a $\text{null}$-element. Given 
that such constraints can be expressed in Isabelle/HOL via \emph{type classes} 
(written: $\alpha::\kappa$), all types for OCL-expressions are of a form captured 
by
\begin{gather*}
\V{\isaAA}{\alpha} = (\state{\isaAA} \times 
                                \state{\isaAA} \to \alpha \ofType \TCnull)  \mi{,}
\end{gather*}
where $\state{\isaAA}$ stands for the system state and $\state{\isaAA} \times
\state{\isaAA}$ describes the pair of pre-state and post-state.

Previous versions of the OCL semantics~\cite[Annex A]{omg:ocl:2003} used different
interpretation functions for invariants and pre-conditions; we achieve
their semantic effect by a syntactic transformation $\__\text{pre}$
which replaces, for example, all accessor functions
$\getAttrib{\_}{a}$ by their counterparts
$\getAttrib{\_}{a\isasymOclATpre}$ (see \autoref{sec:invlogic}). For example,
$(\getAttrib{\self}{a} > 5)_\text{pre}$ is just
$(\getAttrib{\self}{a\isasymOclATpre} > 5)$. This way, also invariants
and pre-conditions can be interpreted by the same interpretation
function and have the same type of an evaluation $\V{}{\alpha}$.
\endisatagannexa

On this basis, one can define the core logical operators $\mocl{not}$
and $\mocl{and}$ as follows:
\begin{gather*}
  \begin{array}{ll}
    I\semantics{\mocl{not}\; X}  \tau
    &=  (\HolCase I\semantics{X} \tau  \HolOf\\
    &\quad\begin{array}{ll}
                     ~ \bottom                    &\Rightarrow  \bottom \\
                     | \lfloor  \bottom  \rfloor  &\Rightarrow  \lfloor  \bottom  \rfloor  \\
                     | \lfloor \lfloor  x \rfloor \rfloor  &\Rightarrow  \lfloor \lfloor  \lnot  x \rfloor \rfloor )
          \end{array}
  \end{array}
\end{gather*}
\begin{gather*}
  \begin{array}{ll}
   I\semantics{X\;\mocl{and}\; Y}  \tau
    &=  (\HolCase I\semantics{X} \tau  \HolOf\\
    &\quad\begin{array}{ll}
      ~ \bottom                    &\Rightarrow
      (\HolCase I\semantics{Y} \tau  \HolOf\\
      &\quad\begin{array}{ll}
                     ~ \bottom                    &\Rightarrow  \bottom \\
                     | \lfloor  \bottom  \rfloor  &\Rightarrow  \bottom  \\
                     | \lfloor \lfloor  \HolTrue \rfloor \rfloor
                     &\Rightarrow  \bottom\\
                     | \lfloor \lfloor  \HolFalse \rfloor \rfloor
                     &\Rightarrow  \lfloor \lfloor  \HolFalse \rfloor \rfloor )\\
                   \end{array}
      \\
                     | \lfloor  \bottom  \rfloor  &\Rightarrow
      (\HolCase I\semantics{Y} \tau  \HolOf\\
      &\quad\begin{array}{ll}
                     ~ \bottom                    &\Rightarrow
                     \bottom \\
                     | \lfloor  \bottom  \rfloor  &\Rightarrow  \lfloor
                     \bottom \rfloor \\
                     | \lfloor \lfloor  \HolTrue \rfloor \rfloor
                     &\Rightarrow  \lfloor \bottom\rfloor\\
                     | \lfloor \lfloor  \HolFalse \rfloor \rfloor
                     &\Rightarrow  \lfloor \lfloor  \HolFalse \rfloor \rfloor )\\
                   \end{array}
      \\
                     | \lfloor \lfloor  \HolTrue \rfloor \rfloor  &\Rightarrow
      (\HolCase I\semantics{Y} \tau  \HolOf\\
      &\quad\begin{array}{ll}
                     ~ \bottom                    &\Rightarrow
                     \bottom \\
                     | \lfloor  \bottom  \rfloor  &\Rightarrow  \lfloor
                     \bottom \rfloor \\
                     | \lfloor \lfloor y \rfloor \rfloor
                     &\Rightarrow  \lfloor \lfloor  y \rfloor \rfloor )\\
                   \end{array}
      \\
                     | \lfloor \lfloor  \HolFalse \rfloor \rfloor
                     &\Rightarrow   \lfloor \lfloor  \HolFalse \rfloor
                     \rfloor )\\
                   \end{array}\\
\end{array}
\end{gather*}
These non-strict operations are used to define the other logical connectives in 
the usual classical way:
\begin{gather*}
\begin{array}{l}
X\; \mocl{or}\; Y \equiv \mocl{not} \; ((\mocl{not}\; X)\; \mocl{and}\; (\mocl{not}\; Y))\\
X\;\mocl{implies}\;Y \equiv (\mocl{not}\; X)\;\mocl{or}\; Y
\end{array}
\end{gather*}
For reasons of conciseness, we will write $\delta~X$ for 
$\mocl{not} \ap (X\mocl{.oclIsUndefined()})$ and $\upsilon~X$ for 
$\mocl{not} \ap (X\mocl{.oclIsInvalid()})$ throughout this document.

The default semantics for an \OCL library operator is strict
semantics; this means that the result of an operation $f$ is
$\mocl{invalid}$ if one of its arguments is $\mocl{invalid}$ or $\mocl{null}$.
The definition of the addition for integers as default variant reads as follows:
\begin{gather*}
   \begin{array}{rl}
   I\semantics{X \;\mocl{+}\; Y}\tau  = &\HolIf I\semantics{\delta ~ X}\tau =I\semantics{\mocl{true}}\tau
                 \land  I\semantics{\delta  ~ Y}\tau =I\semantics{\mocl{true}}\tau \\
                &\HolThen \; \lfloor \lfloor \lceil \lceil I\semantics{X}\tau \rceil \rceil  + \lceil \lceil I\semantics{Y}\tau \rceil \rceil \rfloor \rfloor\\
                &\HolElse \; \bottom
   \end{array}
\end{gather*}
where the operator ``\mocl{+}'' on the left-hand
side of the equation denotes the \OCL addition of type
$\mocl{(Integer,Integer)->Integer}$ while 
the ``$+$'' on the right-hand side of the equation of type 
$[\HolInteger,\HolInteger]\Rightarrow \HolInteger$ denotes the integer-addition 
from the \HOL library.

\subsection{Logical Layer}
The topmost goal of the logic for \OCL is to define the \emph{validity statement}:
\begin{gather*}
   (\sigma, \sigma') \isasymMathOclValid P
\end{gather*}
where $\sigma$ is the pre-state and $\sigma'$ the post-state of the
underlying system and $P$ is a formula, \ie, an \OCL expression of type \mocl{Boolean}.
Informally, a formula $P$ is valid if and only if its evaluation in
$(\sigma, \sigma')$ (\ie, $\tau$ for short) yields $\mocl{true}$. Formally this means:
\begin{gather*}
\tau \models P \equiv (I\semantics{P}\tau =  I\semantics{\mocl{true}}\tau)
\end{gather*}
On this basis, classical, two-valued inference rules can be established for
reasoning over the logical connectives, the different notions of equality,
definedness and validity. Generally speaking, rules over logical validity can
relate bits and pieces in various \OCL terms and allow---via strong
logical equality discussed below---the replacement
of semantically equivalent sub-expressions.
The core inference rules are:
\begin{itemize}

\item $\mocl{Boolean}$:
\begin{gather*}
  \tau \isasymMathOclValid \mocl{true} \quad
  \lnot(\tau \isasymMathOclValid \mocl{false}) \quad
  \lnot(\tau \isasymMathOclValid \mocl{invalid}) \quad
  \lnot(\tau \isasymMathOclValid \mocl{null})
\end{gather*}

\item $\mocl{not}$:
\begin{gather*}
  \tau \isasymMathOclValid \mocl{not}\; P \Longrightarrow \lnot (\tau \isasymMathOclValid P)
\end{gather*}

\item $\mocl{and}$:
\begin{gather*}
  \tau \isasymMathOclValid P \;\mocl{and}\; Q \Longrightarrow \tau \isasymMathOclValid P \qquad
  \tau \isasymMathOclValid P \;\mocl{and}\; Q \Longrightarrow \tau \isasymMathOclValid Q
\end{gather*}

\item $\mocl{or}$:
\begin{gather*}
  \tau \isasymMathOclValid P \Longrightarrow \tau \isasymMathOclValid P \;\mocl{or}\; Q  \phantom{\mocl{r}}\qquad
   \tau \isasymMathOclValid Q \Longrightarrow \tau \isasymMathOclValid P \;\mocl{or}\; Q 
\end{gather*}

\item $\mocl{if} \ldots \mocl{then} \ldots \mocl{else} \ldots \mocl{endif}$:
\begin{gather*}
\begin{array}{l@{\ap}l}
  \tau \isasymMathOclValid & P \Longrightarrow
     I\semantics{\mocl{if}\; P \;\mocl{then}\; B_1 \;\mocl{else}\; B_2 \;\mocl{endif}} \tau = I\semantics{B_1}\tau \\
  \tau \isasymMathOclValid \mocl{not} & P \Longrightarrow
     I\semantics{\mocl{if}\; P \;\mocl{then}\; B_1 \;\mocl{else}\; B_2 \;\mocl{endif}} \tau = I\semantics{B_2}\tau
\end{array}
\end{gather*}

or equivalently:
\begin{gather*}
\begin{array}{l@{\ap}l}
  \tau \isasymMathOclValid & P \Longrightarrow
     (\mocl{if}\; P \;\mocl{then}\; B_1 \;\mocl{else}\; B_2 \;\mocl{endif}) \ap \tau = B_1\ap \tau \\
  \tau \isasymMathOclValid \mocl{not} & P \Longrightarrow
       (\mocl{if}\; P \;\mocl{then}\; B_1 \;\mocl{else}\; B_2 \;\mocl{endif}) \ap \tau = B_2\ap \tau
\end{array}
\end{gather*}

\item $\delta \ap \_$ and $\upsilon \ap \_$:
\begin{gather*}
  \tau \isasymMathOclValid P \Longrightarrow \tau \isasymMathOclValid \delta \ap P \qquad
  \tau \isasymMathOclValid \delta \ap X \Longrightarrow \tau \isasymMathOclValid \upsilon \ap X
\end{gather*}
\end{itemize}

By the latter two properties, it can be inferred that any valid
property $P$ (so for example, a valid invariant) is defined, which
allows to infer for terms composed by strict operations that their
arguments and finally the variables occurring in it are valid or
defined.

The mandatory part of the \OCL standard refers to an equality
(written $X \;\mocl{=}\; Y$ or $X \;\mocl{<>}\; Y$ for its negation), which is
intended to be a strict operation (thus: $\mocl{invalid} \;\mocl{=}\; Y$ evaluates
  to \mocl{invalid}) and which uses the references of objects in a state
when comparing objects, similarly to C++ or Java. In order to avoid
confusions, we will use the following notations for equality:
\begin{enumerate}
\item The symbol $\_ = \_$ remains to be reserved to the \HOL equality,
      \ie, the equality of our semantic meta-language,
\item The symbol $\_ \isasymMathOclStrongEq \_$ will be used for
      the \emph{strong logical equality},  which follows the general
      logical principle that ``equals can be replaced by equals,''\footnote{Strong logical equality is also referred as ``Leibniz''-equality.}
      and is at the heart of the \OCL logic,
\item The symbol $\_ \isasymMathOclStrictEq \_$ is used for the
      strict referential equality, \ie, the equality the mandatory part
      of the \OCL standard refers to by the ``\_ \;\mocl{=}\; \_'' symbol.
\end{enumerate}

The strong logical equality is a polymorphic
concept which is defined using polymorphism for all \OCL types by:
\begin{gather*}
  I\semantics{X \triangleq  Y}  \tau  \equiv
  \lift {\lift{I\semantics{X}  \tau = I\semantics{Y} \tau  }}
\shortintertext{It enjoys nearly the laws of a congruence:}
\tau \isasymMathOclValid (X \triangleq X)\\
\tau \isasymMathOclValid (X \triangleq Y) \Longrightarrow \tau \isasymMathOclValid (Y \triangleq X)\\
\tau \isasymMathOclValid (X \triangleq Y) \Longrightarrow \tau \isasymMathOclValid (Y \triangleq Z) \Longrightarrow \tau \isasymMathOclValid (X \triangleq Z)\\
\operatorname{cp} P \Longrightarrow \tau \isasymMathOclValid (X \triangleq Y) \Longrightarrow \tau \isasymMathOclValid (P\ap X) \Longrightarrow \tau \isasymMathOclValid (P\ap Y)
\end{gather*}
where the predicate $\operatorname{cp}$ stands for
\emph{context-passing}, a property that is true in \FOCL for all pure \OCL
expressions (but not arbitrary mixtures of \OCL and \HOL):
\begin{gather*}
\operatorname{cp} P \equiv \exists f. \; \forall X \; \tau. \; I\semantics{P \ap X}\tau = I\semantics{f \ap (I\semantics{X}\tau)}\tau
\end{gather*}
The necessary side-calculus for establishing $\operatorname{cp}$ can
be fully automated; the reader interested in the details is referred
to \autoref{sec:equality}.

The strong logical equality of \FOCL gives rise to a number
of further rules and derived properties, that clarify the role of strong 
logical equality and the $\mocl{Boolean}$ constants in \OCL specifications:
\begin{gather*}
\tau \isasymMathOclValid \delta \ap X \lor \tau \isasymMathOclValid X \triangleq \mocl{invalid} \lor \tau \isasymMathOclValid X \triangleq \mocl{null}\\
\begin{array}{l@{}l@{\ap}l@{\ap}l@{}l}
(\tau \isasymMathOclValid A \triangleq \mocl{invalid} &) &= (& \tau \isasymMathOclValid \mocl{not} \; (\upsilon \; A) &)\\
% (*  foundation15 *)
(\tau \isasymMathOclValid A \triangleq \mocl{null} &) &= (& \tau \isasymMathOclValid \upsilon \; A \; \mocl{and} \; \mocl{not} \; (\delta \; A) &)\\
 (\tau \isasymMathOclValid A \triangleq \mocl{true} &) &= (& \tau \isasymMathOclValid A &) \\
 (\tau \isasymMathOclValid A \triangleq \mocl{false} &) &= (& \tau \isasymMathOclValid \mocl{not} \; A &) \\
 (\tau \isasymMathOclValid \mocl{not} \; (\delta \; X) &) &= (\lnot & \tau \isasymMathOclValid \delta \; X &) \\
 (\tau \isasymMathOclValid \mocl{not} \; (\upsilon \; X) &) &= (\lnot & \tau \isasymMathOclValid \upsilon \; X &) % (*  UML_Logic.foundation7':*)
\end{array}
\end{gather*}
%   (not A \<triangleq> not B) = (A \<triangleq> B) (*foundation21*)

Thus with these rules, one can convert an \OCL formula represented in
its four-valued world into a representation that is classically
two-valued, and let the processing with standard SMT solvers such as
CVC3~\cite{barrett.ea:cvc3:2007} or
Z3~\cite{moura.ea:z3:2008}. $\delta$-closure rules for all logical
connectives have the following format (for example):
\begin{gather*}
\begin{array}{l@{\ap}c@{\ap}l@{\ap}c@{\ap}l}
\multicolumn{5}{l}{\tau \isasymMathOclValid \delta \ap X \Longrightarrow (\tau \isasymMathOclValid \ap\mocl{not}\ap X) = (\lnot (\tau \isasymMathOclValid X))} \\
\tau \isasymMathOclValid \delta \ap X \Longrightarrow \tau \isasymMathOclValid \delta \ap Y \Longrightarrow (\tau \isasymMathOclValid X & \mocl{and} & Y) = ( (\tau \isasymMathOclValid X) & \land & (\tau \isasymMathOclValid Y)) \\
\tau \isasymMathOclValid \delta \ap X \Longrightarrow  \tau \isasymMathOclValid \delta \ap Y
\Longrightarrow (\tau \isasymMathOclValid X & \mocl{implies} & Y) = ( (\tau \isasymMathOclValid X) & \longrightarrow & (\tau \isasymMathOclValid Y))
\end{array}
\end{gather*}
With the conjunction of these rules (comprising the above mentioned
case distinction: $\tau \isasymMathOclValid \delta \ap X \lor \tau
\isasymMathOclValid X \triangleq \mocl{invalid} \lor \tau
\isasymMathOclValid X \triangleq \mocl{null}$), we can automatically
proceed to the simplification of a formula by case analysis, in order
to quickly reach a contradiction, whenever we know that a variable $X$
is $\mocl{invalid}$ or $\mocl{null}$. For example, we can infer from
an invariant $\tau \isasymMathOclValid X \isasymMathOclStrictEq Y
\;\mocl{-}\; \mocl{3}$ that we have $\tau \isasymMathOclValid X
\isasymMathOclStrictEq Y \;\mocl{-}\; \mocl{3} \land \tau
\isasymMathOclValid \delta \ap X \land \tau \isasymMathOclValid \delta
\ap Y$.  We call the latter formula the $\delta$-closure of the
former.  Now, we can convert a formula like $\tau \isasymMathOclValid
X \;\mocl{>}\; \mocl{0} \ap\mocl{or}\ap \mocl{3} \;\mocl{*}\; Y
\;\mocl{>}\; X \;\mocl{*}\; X$ into the equivalent formula $\tau
\isasymMathOclValid X \;\mocl{>}\; \mocl{0} \lor \tau
\isasymMathOclValid \mocl{3} \;\mocl{*}\; Y \;\mocl{>}\; X
\;\mocl{*}\; X$ and thus internalize the four-valued logic of \OCL, as
if we have a classical (and more tool-conform) logic.

\subsection{Algebraic Layer}
Based on the logical layer, we build a system with simpler rules which
are amenable to automated reasoning. We restrict ourselves to pure
equations on \OCL expressions.

Our denotational definitions on \inlineocl+not+ and \inlineocl+and+
can be re-formulated in the following ground equations:
\begin{itemize}
\item $\upsilon \ap \_$:
\begin{gather*}
  \begin{aligned}
  \upsilon\; \mocl{invalid} &= \mocl{false}&\qquad
  \upsilon\; \mocl{null} &= \mocl{true}\\
  \upsilon\; \mocl{true} &= \mocl{true}&\qquad
  \upsilon\; \mocl{false} &= \mocl{true}\\
\end{aligned}
\end{gather*}

\item $\delta \ap \_$:
\begin{gather*}
\begin{aligned}
  %
  \delta\; \mocl{invalid} &= \mocl{false}&\qquad
  \delta\; \mocl{null} &= \mocl{false}\\
  \delta\; \mocl{true} &= \mocl{true}&\qquad
  \delta\; \mocl{false} &= \mocl{true}\\
\end{aligned}
\end{gather*}

\item $\mocl{not}$:
\begin{gather*}
\begin{aligned}
  %
  \mocl{not}\; \mocl{invalid} &= \mocl{invalid}&\qquad
  \mocl{not}\; \mocl{null} &= \mocl{null}\\
  \mocl{not}\; \mocl{true} &= \mocl{false}&\qquad
  \mocl{not}\; \mocl{false} &= \mocl{true}\\
\end{aligned}
\end{gather*}

\item $\mocl{and}$:
\begin{itemize}
\item $\mocl{invalid}$:
\begin{gather*}
\begin{aligned}
  (\mocl{invalid} \;\mocl{and}\; \mocl{true}) &= \mocl{invalid}&
  (\mocl{invalid} \;\mocl{and}\; \mocl{false}) &= \mocl{false}\\
  (\mocl{invalid} \;\mocl{and}\; \mocl{null}) &= \mocl{invalid}&
  (\mocl{invalid} \;\mocl{and}\; \mocl{invalid}) &= \mocl{invalid}\\
\end{aligned}
\end{gather*}

\item $\mocl{null}$:
\begin{gather*}
\begin{aligned}
  %
  (\mocl{null} \;\mocl{and}\; \mocl{true}) &= \mocl{null}&\qquad
  (\mocl{null} \;\mocl{and}\; \mocl{false}) &= \mocl{false}\\
  (\mocl{null} \;\mocl{and}\; \mocl{null}) &= \mocl{null}&\qquad
  (\mocl{null} \;\mocl{and}\; \mocl{invalid}) &= \mocl{invalid}\\
\end{aligned}
\end{gather*}

\item $\mocl{true}$:
\begin{gather*}
\begin{aligned}
  %
  (\mocl{true} \;\mocl{and}\; \mocl{true}) &= \mocl{true}&\qquad
  (\mocl{true} \;\mocl{and}\; \mocl{false}) &= \mocl{false}\\
  (\mocl{true} \;\mocl{and}\; \mocl{null}) &= \mocl{null}&\qquad
  (\mocl{true} \;\mocl{and}\; \mocl{invalid}) &= \mocl{invalid}
\end{aligned}
\end{gather*}

\item $\mocl{false}$:
\begin{gather*}
\begin{aligned}
  %
  (\mocl{false} \;\mocl{and}\; \mocl{true}) &= \mocl{false}&\qquad
  (\mocl{false} \;\mocl{and}\; \mocl{false}) &= \mocl{false}\\
  (\mocl{false} \;\mocl{and}\; \mocl{null}) &= \mocl{false}&\qquad
  (\mocl{false} \;\mocl{and}\; \mocl{invalid}) &= \mocl{false}\\
\end{aligned}
\end{gather*}
\end{itemize}
\end{itemize}
On this core, the structure of a conventional lattice arises:
\begin{gather*}
  \begin{aligned}
    X \;\mocl{and}\; X &= X \\
    X \;\mocl{and}\; Y &= Y \;\mocl{and}\; X \\
    X \;\mocl{and}\; (Y \;\mocl{and}\; Z) &= X \;\mocl{and}\; Y \;\mocl{and}\; Z
  \end{aligned}\\
  \begin{aligned}
    \mocl{false} \;\mocl{and}\; X &= \mocl{false} &\qquad
    X \;\mocl{and}\; \mocl{false} &= \mocl{false}  \\
    \mocl{true} \;\mocl{and}\; X  &= X &\qquad
    X \;\mocl{and}\; \mocl{true} &= X
  \end{aligned}
\end{gather*}
as well as the dual equalities for $\_ \;\mocl{or}\; \_$ and the De
Morgan rules.  This wealth of algebraic properties makes the
understanding of the logic easier, and enables automated analysis: for
example, by computing the DNF of some invariant systems (by
term-rewriting techniques) which are a prerequisite for
$\delta$-closures.

The above equations explain the behaviour for the most important
non-strict operations. The clarification of the exceptional behaviours
is of key importance for a semantic definition of the standard and the
major deviation point from
\HOLOCL~\cite{brucker.ea:hol-ocl:2008,brucker.ea:hol-ocl-book:2006}
to \FOCL as presented here.  Expressed in algebraic equations,
``strictness-principles'' boil down to:
\begin{gather*}
  \begin{aligned}
    \mocl{invalid} \;\mocl{+}\; X &= \mocl{invalid} &\qquad
    X \;\mocl{+}\; \mocl{invalid} &= \mocl{invalid}\\
    \mocl{invalid->including(}X\mocl{)} &= \mocl{invalid} &\qquad
    \mocl{null->including(}X\mocl{)} &= \mocl{invalid}\\
    X \isasymMathOclStrictEq  \mocl{invalid} &= \mocl{invalid}&\qquad
    \mocl{invalid} \isasymMathOclStrictEq X &= \mocl{invalid} \\
  \end{aligned}\\
      \mocl{S->including(invalid)}=\mocl{invalid} \\
       X \isasymMathOclStrictEq X =  (\mocl{if}\; \upsilon\; x\; \mocl{then true}
                                         \;\mocl{else invalid endif}) \\
  \begin{aligned}
    \mocl{1} \;\mocl{div}\; \mocl{0} &= \mocl{invalid} \quad &\quad
    \mocl{1} \;\mocl{div}\; \mocl{null} &= \mocl{invalid} \\
    \mocl{invalid->isEmpty()}&=\mocl{invalid} \quad &\quad \mocl{null->isEmpty()}&=\mocl{null}\\
  \end{aligned}\\
\end{gather*}

Algebraic rules are also the key for execution and compilation
of  \FOCL expressions. We derived, \eg:
\begin{gather*}
\delta\; \mocl{Set\{\}} = \mocl{true}\\
\delta\; (X\mocl{->including(}x\mocl{)}) = \delta \ap X \;\mocl{and}\;
 \upsilon \ap x\\
\begin{aligned}
\mocl{Set\{\}->includes(}x\mocl{)} = (\mocl{if}\; \upsilon\; x\; &\mocl{then false}\\
&\mocl{else invalid endif})
\end{aligned}\\
\begin{multlined}
  {(X\mocl{->including(}x\mocl{)->includes(}y\mocl{)})=}\\
  \mbox{\hspace{3.2cm}}\qquad{\begin{aligned}
   (&\mocl{if}\; \delta\; X\\
  &\mocl{then}\;
\begin{array}[t]{l}
\mocl{if}\; x \doteq y\\
\mocl{then}\ap \mocl{true} \\
\mocl{else}\ap X\mocl{->includes(}y\mocl{)}\\
\mocl{endif}
  \end{array}\\
&\mocl{else invalid} \\
         &\mocl{endif})
  \end{aligned}}
\end{multlined}
\end{gather*}
As \inlineocl+Set{1,2}+ is only syntactic sugar for
\begin{ocl}
  Set{}->including(1)->including(2)
\end{ocl}
an expression like \inlineocl+Set{1,2}->includes(null)+ becomes
decidable in  \FOCL by applying these algebraic laws (which can give
  rise to efficient compilations). The reader interested in the list of
``test-statements'' like:
\begin{isar}[mathescape]
value  "\<tau> \<Turnstile> ($\mathtt{Set\{Set\{2,null\}\}}$ \<doteq> $\;\mathtt{Set\{Set\{null,2\}\}}$)"
\end{isar}
may consult \autoref{formal-set}; these test-statements
 have been machine-checked and proven consistent with the denotational and logic
 semantics of \FOCL.
% It fairly readable information for \OCL tool manufactures and users.


\subsection{Object-oriented Datatype Theories}
In the following, we will refine the concepts of a user-defined
data-model implied by a \emph{class-model} (\emph{visualized} by a class-\emph{diagram})
as well as the notion of $\state{\isaAA}$ used in the
previous section to much more detail.  \UML class models represent in a compact
and visual manner quite complex, object-oriented data-types with a surprisingly rich
theory. In this section, this theory is made explicit
and corner cases were pointed out.

A \UML class model underlying a
given \OCL invariant or operation contract
produces several implicit operations which
become accessible via appropriate \OCL syntax.
A class model is a four-tuple $(C, \_ < \_, Attrib, Assoc)$ where:
\begin{enumerate}
\item $C$ is a  set of class names (written as $\{C_1, \ldots, C_n\}$). To each class
  name a type of data in \OCL is associated. Moreover, class names declare two projector
  functions to the set of all objects in a state:
  $C_i$\inlineocl{.allInstances()} and
  $C_i$\inlineocl{.allInstances}$\isasymOclATpre$\inlineocl{()},
\item $\_ < \_$ is an inheritance relation on classes,
\item $Attrib(C_i)$ is a collection of
  attributes associated to classes $C_i$. It declares two families of accessors; for each attribute $a \in Attrib(C_i) $ in a
  class definition $C_i$ (denoted
  $\getAttrib{X}{\text{$a$}}               :: C_i \rightarrow A $ and
  $\getAttrib{X}{\text{$a$}\isasymOclATpre}:: C_i \rightarrow A $ for
  $A\in TYPES$),
\item $Assoc(C_i,C_j)$ is a collection of associations\footnote{Given the fact that there is at present no consensus on the
  semantics of n-ary associations, \FOCL{} restricts itself to binary associations. }.
   An association $(n, rn_{from}, rn_{to})\in Assoc(C_i,C_j)$ between to classes
   $C_i$ and $C_j$ is a triple consisting of a (unique) association name $n$,
    and the role-names $rn_{to}$ and $rn_{from}$. To each role-name belong two
    families of accessors   denoted
    $\getRole{X}{\text{$a$}}               :: C_i \rightarrow A$ and
    $\getRole{X}{\text{$a$}\isasymOclATpre}:: C_i \rightarrow A$ for
    $A\in TYPES$),
\item for each pair $C_i < C_j$ ($C_i, C_j < C$), there is a
     cast operation of type $C_j \rightarrow C_i$ that can change the static type
     of an object of type $C_i$:
     $\getAttrib{obj::C_i}{\mocl{oclAsType(}\text{$C_j$}\mocl{)}}$,
\item for each class $C_i\in C$, there are two dynamic type tests
     ($\getAttrib{X}{\mocl{oclIsTypeOf(}\text{$C_i$}\mocl{)}}$ and
     $\getAttrib{X}{\mocl{oclIsKindOf(}\text{$C_i$}\mocl{)}}$ ),
\item and last but not least, for each class name $C_i\in C$ there is an
     instance of the overloaded referential equality (written $\_
     \isasymMathOclStrictEq \_$).
\end{enumerate}


Assuming a strong static type discipline in the sense of
Hindley-Milner types,  \FOCL has no ``syntactic
subtyping.''  In contrast, sub-typing can be expressed
\emph{semantically} in  \FOCL by adding suitable type-casts which do
have a formal semantics. Thus, sub-typing becomes an issue of the front-end 
that can make implicit type-coercions explicit. Our perspective shifts the 
emphasis on the semantic properties of casting, and the necessary universe of 
object representations (induced by a class model) that allows to establish
them.

As a pre-requisite of a denotational semantics for these operations induced
by a class-model, we need an \emph{object-universe} in which these operations can
be defined in a denotational manner and from which the necessary properties
for constructors, accessors, tests and casts
can be derived. A concrete universe constructed from a class model will be
used to instantiate the implicit type parameter $\isaAA$ of all \OCL operations
discussed so far.

\subsubsection{A Denotational Space for Class-Models: Object Universes}

It is natural to construct system states by a set of partial functions
$f$ that map object identifiers $\oid$ to some representations of
objects:
\begin{gather*}
\begin{array}{lll}
  \record \ap \state{\isaAA} = & \operatorname{heap} & :: \oid \rightharpoonup {\isaAA}
\end{array}
\end{gather*}

The key point is that we need a common type $\mathfrak{A}$ for the set of all
possible \emph{object representations}.  Object representations model
``a piece of typed memory,'' \ie, a kind of record comprising
administration information and the information for all attributes of
an object; here, the primitive types as well as collections over them
are stored directly in the object representations, class types and
collections over them are represented by $\oid$'s (respectively lifted
collections over them).

In a shallow embedding which must represent
\UML types one-to-one by HOL types, there are two fundamentally
different ways to construct such a set of object representations,
which we call an \emph{object universe} $\mathfrak{A}$:
\begin{enumerate}
\item an object universe can be constructed from a given class model,
  leading to \emph{closed world semantics}, and
\item an object universe can be constructed for a given class model
  \emph{and all its extensions by new classes added into the leaves of
    the class hierarchy}, leading to an \emph{open world semantics}.
\end{enumerate}
For the sake of simplicity, the present semantics chose the first option for
 \FOCL, while HOL-\OCL~\cite{brucker.ea:extensible:2008-b}
used an involved construction allowing the latter.

A na\"ive attempt to construct $\mathfrak{A}$ would look like this:
the class type $C_i$ induced by a class will be the type of such an
object representation: $C_i \defeq (\oid \times \up{{a_{i_{1}}}}
\times \cdots \times \up{{a_{i_{n}}}} )$ where the types $a_{i_1}$,
\ldots, $a_{i_n}$ are the attribute types (including inherited
attributes) with class types substituted by $\oid$. The function
$\HolOclOidOf$ projects the first component, the $\oid$, out of an
object representation. Then the object universe will be constructed by
the type definition:
\begin{gather*}
\mathfrak{A} \defeq C_1 + \cdots +  C_m\mi{.}
\end{gather*}
It is possible to define constructors, accessors, and the referential
equality on this object universe. However, the treatment of type casts
and type tests cannot be faithful with common object-oriented
semantics, be it in \UML or Java: casting up along the class hierarchy
can only be implemented by loosing information, such that casting up
and casting down will \emph{not} give the required identity, whenever $C_k  < C_i$ and $X$ is valid:
\begin{gather*}
        X.\mocl{oclIsTypeOf(}C_k\mocl{)} ~ ~  \mocl{implies} ~ ~ X\mocl{.oclAsType(}C_i\mocl{)}\mocl{.oclAsType(}C_k\mocl{)} \isasymMathOclStrictEq
   X
\end{gather*}

To overcome this limitation, we introduce an auxiliary type
$C_{i\text{ext}}$ for \emph{class type extension}; together, they were
inductively defined for a given class diagram:

Let $C_i$ be a class with a possibly empty set of immediate subclasses
$C_{j_{1}}, \ldots, C_{j_{m}}$ ($C_{j_l} < C_i$).
\begin{itemize}
\item Then the \emph{class type extension} $C_{i\textup{ext}}$
  associated to $C_i$ is $\up{{a_{i_{1}}}} \times \cdots \times
  \up{{a_{i_{h}}}} \times \up{(C_{j_{1}\textup{ext}} + \cdots +
    C_{j_{m}\textup{ext}})}$ where $a_{i_{k}}$ ranges over the local
  attribute types of $C_i$ (not inherited ones) and
  $C_{j_{l}\textup{ext}}$ ranges over all class type extensions of
  immediate subclasses $C_{j_{l}}$ of $C_i$.
\item Then the \emph{class type} $C_{i\textup{ty}}$ for $C_i$ is $\oid
  \times \up{{a_{i_{1}}}} \times \cdots \times \up{{a_{i_{n}}}} \times
  \up{(C_{j_{1}\textup{ext}} + \cdots + C_{j_{m}\textup{ext}})}$ where
  $a_{i_{k}}$ ranges over the inherited \emph{and} local attribute
  types of $C_i$ and $C_{j_{l}\textup{ext}}$ ranges over all class
  type extensions of immediate subclasses $C_{j_{l}}$ of $C_i$.
\end{itemize}

\isatagafp
Example instances of this scheme---outlining a compiler---can be found
in \autoref{ex:employee-analysis:uml} and \autoref{ex:employee-design:uml}.
\endisatagafp
\isatagannexa
Example instances of this scheme---outlining a compiler---can be found
in \autoref{ex:employee-analysis:uml}.
\endisatagannexa

This construction can \emph{not} be done in HOL itself since it
involves quantifications and iterations over the ``set of class-types'';
rather, it is a meta-level construction.  Technically, this means that
we need a compiler to be done in SML on the syntactic
``meta-model''-level of a class model.

With respect to our semantic construction here,
which above all means is intended to be type-safe, this has the following consequences:
\begin{itemize}
\item there is a generic theory of states, which must be formulated independently
      from a concrete object universe,
\item there is a principle of translation (captured by the inductive scheme for
      class type extensions and class types above) that converts a given class model
      into an concrete object universe,
\item there are fixed principles that allow to derive the semantic theory of any
      concrete object universe, called the \emph{object-oriented datatype theory.}
\end{itemize}
\isatagafp
We will work out concrete examples for the construction of the
object-universes in \autoref{ex:employee-analysis:uml} and \autoref{ex:employee-design:uml} and the
derivation of the respective datatype theories. While an
automatization is clearly possible and desirable for concrete
applications of  \FOCL, we consider this out of the scope
of this document which has a focus on the semantic construction and its
presentation.
\endisatagafp
\isatagannexa
We will work out concrete examples for the construction of the
object-universes in \autoref{ex:employee-analysis:uml} and the
derivation of the respective datatype theories. While an
automatization is clearly possible and desirable for concrete
applications of  \FOCL, we consider this out of the scope
of this annex which has a focus on the semantic construction and its
presentation.
\endisatagannexa


\subsubsection{Denotational Semantics of Accessors on Objects and Associations}
Our choice to use a shallow embedding of \OCL in HOL and, thus having
an injective mapping from \OCL types to HOL types, results in
type-safety of  \FOCL\@. Arguments and results of accessors
are based on type-safe object representations and \emph{not} $\oid$'s.
This implies the following scheme for an accessor:
\begin{itemize}
\item The \emph{evaluation and extraction} phase. If the argument
  evaluation results in an object representation, the $\oid$ is
  extracted, if not, exceptional cases like \inlineocl{invalid} are
  reported.
\item The \emph{de-referentiation} phase. The $\oid$ is interpreted in
  the pre- or post-state, %(depending on the suffix of accessor),
  the resulting object is cast to the expected format.  The
  exceptional case of non-existence in this state must be treated.
\item The \emph{selection} phase. The corresponding attribute is
  extracted from the object representation.
\item The \emph{re-construction} phase.  The resulting value has to be
  embedded in the adequate HOL type.  If an attribute has the type of
  an object (not value), it is represented by an optional (set of)
  $\oid$, which must be converted via de-referentiation in one of the
  states to produce an object representation again. The
  exceptional case of non-existence in this state must be treated.
\end{itemize}

The first phase directly translates into the following formalization:
\begin{gather*}
  \begin{array}{r@{\ap}l@{\ap}l}
 \isardef \ap \operatorname{eval\_extract} X\ap f = (\lambda \tau\spot \HolCase
 X\ap \tau \HolOf & \bottom &\Rightarrow
 \mocl{invalid}\ap\tau\\
 &\multicolumn{2}{r}{\text{propagating the exception}}\\
 |& \lift{\bottom} &\Rightarrow
 \mocl{invalid}\ap\tau\\
 &\multicolumn{2}{r}{\text{dereferencing a null value}}\\
 |& \lift{\lift{\mathit{obj}}} &\Rightarrow f\ap (\HolOclOidOf \ap \mathit{obj})\ap\tau)
  \end{array}
\end{gather*}

For each class $C$, we introduce the de-referentiation phase of this
form:
\begin{multline*}
  \isardef \ap
  \operatorname{deref\_oid}_{C_i} \ap \mathit{fst\_snd}\ap f\ap \mathit{oid} =
                     (\lambda \tau\spot \HolCase\ap \operatorname{heap}\ap
                     (\mathit{fst\_snd}\ap \tau)\ap \mathit{oid}\ap
                     \HolOf\\
  \begin{array}{ll}
           \phantom{|}\ap \lift{\operatorname{in}_{C_i} obj} &\Rightarrow f\ap
                     \mathit{obj} \ap \tau\\
                     |\ap \_ &\Rightarrow \mocl{invalid}\ap \tau)
      \end{array}
   \end{multline*}
The operation yields undefined if $\mathit{oid}$ is not interpretable in the
state or referencing an object representation not conforming to the
expected type.

We turn to the selection phase: for each class $C$ in the class model
with at least one attribute,
and each attribute $a$ in this class,
we introduce the selection phase of this form:
\begin{itemize}
\item  for inherited attributes $a$ returning a base type:
\begin{gather*}
  \begin{array}{r@{\ap}l@{\ap}c@{\ap}l}
  \isardef \ap
    \operatorname{select}_{C_i\_a} \ap f = (\lambda &
                  \operatorname{mk'}_{C_i} \ap oid & \cdots \bottom \cdots & \_ \Rightarrow \mocl{null}\\
                  |& \operatorname{mk'}_{C_i} \ap oid & \cdots \lift{a} \cdots & \_
                    \Rightarrow f\ap (\lambda \ap x \ap \_\spot
                   \lift{\lift{x}})\ap a)
  \end{array}
\end{gather*}
\item  for owned attributes $a$ returning a base type:
\begin{gather*}
  \begin{array}{r@{\ap}l@{\ap}c@{\ap}l@{\quad\quad\ap\ap\ap}}
  \isardef \ap
    \operatorname{select}_{C_i\_a} \ap f = (\lambda &
                  \operatorname{mk'}_{C_i} \ap \_ \cdots (\operatorname{mk}_{C_i} & \cdots \bottom \cdots & ) \Rightarrow \mocl{null}\\
                  |& \operatorname{mk'}_{C_i} \ap \_ \cdots (\operatorname{mk}_{C_i} & \cdots \lift{a} \cdots & )
                    \Rightarrow \\
    & \multicolumn{3}{r}{f\ap (\lambda \ap x \ap \_\spot
                   \lift{\lift{x}})\ap a)}
  \end{array}
\end{gather*}
\item  for attributes $a$ returning a ``set'' of object type (for ``sequence'' it is similar):
\begin{multline*}
  \isardef \ap
    \operatorname{select}_{a}^{\operatorname{set}} \ap f = \\
    X_a \circ \ap \operatorname{foldl} \ap \operatorname{OclIncluding^{set}} \operatorname{mt^{set}} \circ \ap \operatorname{map} \ap (f \ap (\lambda \ap x \ap \_\spot
                   \lift{\lift{x}}))
\end{multline*}
\end{itemize}

This works for definitions of basic values as well as for object
references in which the $a$ is of type $\oid$.  To increase
readability, we introduce the functions:
\begin{gather*}
\begin{array}{llrlr}
\qquad\qquad&\isardef\enspace&\operatorname{in\_pre\_state}    &= \operatorname{fst} & \qquad \text{first component}\\
\qquad\qquad&\isardef\enspace&\operatorname{in\_post\_state}   &= \operatorname{snd} & \qquad \text{second component} \\
\qquad\qquad&\isardef\enspace&\operatorname{reconst\_basetype} &= \operatorname{id} & \qquad \text{identity function}
\end{array}
\end{gather*}


Let \_\inlineocl{.getB} be an owned accessor of class $C_j$ yielding a
value of base type $A\in \text{T}_{base}$. Then its definition for every class $C_i <^* C_j$ is of the form\footnote{We use an ad-hoc overloading mechanism for defining a family of functions, parameterised over $C_i$.}:
\begin{gather*}
  \begin{array}{l@{\ap}l@{\ap}l}
\overloading&\_\mocl{.getB} &\ofType \ap C_i \Rightarrow A\\
\IIbegin\\
\isardef&X\mocl{.getB} &= \operatorname{eval\_extract}\ap X\ap
                       (\operatorname{deref\_oid}_{C_i}\ap \operatorname{in\_post\_state} \\
              &          &\qquad\qquad   (\operatorname{select}_{C_i\_\text{getB}}\ap \operatorname{reconst\_basetype}))\\
\IIend
                           \end{array}
\end{gather*}

Let \_\inlineocl{.getO} be an owned accessor of class $C_j$ yielding a
value of object type $C_k$ (or $\mocl{Set(}C_k\mocl{)}$ depending on the returned type of $\operatorname{select}_\text{getO}^{\operatorname{set}}$). Then its definition for every class $C_i <^* C_j$ is of the form:
\begin{gather*}
  \begin{array}{l@{\ap}l@{\ap}l}
\overloading&\_\mocl{.getO} &\ofType \ap C_i \Rightarrow C_k \enskip \text{(or $\mocl{Set(}C_k\mocl{)}$ depending on $\operatorname{select}_\text{getO}^{\operatorname{set}}$)}\\
\IIbegin\\
\isardef&X\mocl{.getO} &= \operatorname{eval\_extract}\ap X\ap
                        (\operatorname{deref\_oid}_{C_i}\ap \operatorname{in\_post\_state} \\
     &                    &\qquad\qquad (\operatorname{deref\_assocs}_\text{getO} \ap \operatorname{in\_post\_state} \\
     &                    &\qquad\qquad (\operatorname{select}_\text{getO}^{\operatorname{set}}\ap
                          (\operatorname{deref\_oid}_{C_k}\ap\operatorname{in\_post\_state}))))\\
\IIend
                           \end{array}
\end{gather*}
The variant for an accessor yielding a $\operatorname{TYPES}_0$ is
omitted here; its construction follows by the application of the
principles of the former two.  The respective variants
$\getAttrib{\_}{\text{$a$}\isasymOclATpre}$ are produced when
\inlineisar+in_post_state+ is replaced by
$\operatorname{in\_pre\_state}$.

\isatagafp
Examples for the construction of accessors via associations can be found in
\autoref{sec:eam-accessors}, the construction of accessors via attributes in
\autoref{sec:edm-accessors}. The construction of casts and type tests \inlineocl{->oclIsTypeOf()} and
\inlineocl{->oclIsKindOf()} is similarly.
\endisatagafp
\isatagannexa
Examples for the construction of accessors via associations can be found in
\autoref{sec:eam-accessors}. The construction of casts and type tests \inlineocl{->oclIsTypeOf()} and
\inlineocl{->oclIsKindOf()} is similarly.
\endisatagannexa

In the following, we discuss the role of multiplicities on the types of the
accessors.
Depending on the specified multiplicity, the evaluation of an attribute can
yield just a value (multiplicity \inlineocl{0..1} or \inlineocl{1})
or a collection type like Set or Sequence of values (otherwise).
A multiplicity defines a lower bound as well as a possibly infinite upper
bound on the cardinality of the attribute's values.


\paragraph{Single-Valued Attributes}\label{sec:single-valued-properties}
If the upper bound specified by the attribute's multiplicity is one,
then an evaluation of the attribute yields a single value.
Thus, the evaluation result is \emph{not} a collection. If the lower bound specified by the
multiplicity is zero, the evaluation is not required to yield a non-null value. In this case an
evaluation of the attribute can return $\isasymOclNull$ to indicate an
absence of value.

To facilitate accessing attributes with multiplicity \inlineocl{0..1}, the \OCL
standard states that single values can be used as sets by calling collection
operations on them. This implicit conversion of a value to a
\inlineocl{Set} is not defined by the standard. We argue that the resulting set
cannot be constructed the same way as when evaluating a \inlineocl{Set}
literal. Otherwise, $\isasymOclNull$ would be mapped to the singleton set
containing $\isasymOclNull$, but the standard demands that
the resulting set is empty in this case. The conversion should instead
be defined as follows:
\begin{ocl}
context OclAny::asSet():T
  post: if self = null then result = Set{}
        else result = Set{self} endif
\end{ocl}
% Changed self.isTypeOf(\OCLVoid) to self = null to make it easier for the superficial reader

\paragraph{Collection-Valued Attributes}\label{sec:collection-valued-properties}
If the upper bound specified by the attribute's multiplicity is larger than one,
then an evaluation of the attribute yields a collection of values.  This raises
the question whether $\isasymOclNull$ can belong to this collection. The \OCL
standard states that $\isasymOclNull$ can be owned by collections. However, if
an attribute can evaluate to a collection containing $\isasymOclNull$, it is not
clear how multiplicity constraints should be interpreted for this attribute. The
question arises whether the $\isasymOclNull$ element should be counted or not
when determining the cardinality of the collection. Recall that $\isasymOclNull$
denotes the absence of value in the case of a cardinality upper bound of one, so
we would assume that $\isasymOclNull$ is not counted. On the other hand, the
operation \inlineocl{size} defined for collections in \OCL does count
$\isasymOclNull$.

We propose to resolve this dilemma by regarding multiplicities as optional. This
point of view complies with the \UML standard, that does not require lower and
upper bounds to be defined for multiplicities.\footnote{We are however aware
  that a well-formedness rule of the \UML standard does define a default bound
  of one in case a lower or upper bound is not specified.} In case a
multiplicity is specified for an attribute, \ie, a lower and an upper bound
are provided, we require for any collection the attribute evaluates to 
a collection not containing $\isasymOclNull$. This allows for a straightforward 
interpretation of
the multiplicity constraint. If bounds are not provided for an attribute, we
consider the attribute values to not be restricted in any way. Because in
particular the cardinality of the attribute's values is not bounded, the result
of an evaluation of the attribute is of collection type. As the range of values
that the attribute can assume is not restricted, the attribute can evaluate to a
collection containing $\isasymOclNull$. The attribute can also evaluate to
$\isasymOclInvalid$. Allowing multiplicities to be optional in this way gives
the modeler the freedom to define attributes that can assume the full ranges of
values provided by their types. However, we do not permit the omission of
multiplicities for association ends, since the values of association ends are
not only restricted by multiplicities, but also by other constraints enforcing
the semantics of associations. Hence, the values of association ends cannot be
completely unrestricted.

\paragraph{The Precise Meaning of Multiplicity Constraints}
We are now ready to define the meaning of multiplicity constraints by giving
equivalent invariants written in \OCL\@. Let \inlineocl{a} be an attribute of a
class \inlineocl{C} with a multiplicity specifying a lower bound $m$ and an
upper bound $n$. Then we can define the multiplicity constraint on the values of
attribute \inlineocl{a} to be equivalent to the following invariants written in
\OCL:
\begin{ocl}
context C inv lowerBound: a->size() >= m
          inv upperBound: a->size() <= n
          inv notNull: not a->includes(null)
\end{ocl}
If the upper bound $n$ is infinite, the second invariant is omitted. For the
definition of these invariants we are making use of the conversion of single
values to sets described in \autoref{sec:single-valued-properties}. If $n
\leq 1$, the attribute \inlineocl{a} evaluates to a single value, which is then
converted to a \inlineocl{Set} on which the \inlineocl{size} operation is
called.

If a value of the attribute \inlineocl{a} includes a reference to a non-existent
object, the attribute call evaluates to $\isasymOclInvalid$. As a result, the
entire expressions evaluate to $\isasymOclInvalid$, and the invariants are not
satisfied. Thus, references to non-existent objects are ruled out by these
invariants. We believe that this result is appropriate, since we argue that the
presence of such references in a system state is usually not intended and likely
to be the result of an error. If the modeler wishes to allow references to
non-existent objects, she can make use of the possibility described above to
omit the multiplicity.

\subsubsection{Logic Properties of Class-Models}\label{sec:logicprop-datamodel}
In this section, we assume to have $C_z,C_i,C_j \in C$ and  $C_i < C_j$.
Let $C_z$ be a smallest element with respect to the class hierarchy $\_ < \_$.
The operations induced from a class-model have the following properties:
\begin{gather*}
 \tau \isasymMathOclValid (X :: C_i)\mocl{.oclAsType(}C_i\mocl{)} \isasymMathOclStrongEq X \\
 \tau \isasymMathOclValid \mocl{invalid .oclAsType(}C_i\mocl{)} \isasymMathOclStrongEq \mocl{invalid} \\
 \tau \isasymMathOclValid \mocl{null .oclAsType(}C_i\mocl{)} \isasymMathOclStrongEq \mocl{null} \\
 \tau \isasymMathOclValid (X::C_i)\mocl{.oclAsType(}C_j\mocl{) .oclAsType(}C_i\mocl{)} \isasymMathOclStrongEq X  \\
 \tau \isasymMathOclValid (X::\mocl{OclAny})\mocl{.oclAsType(OclAny)} \isasymMathOclStrongEq X \\
 \tau \isasymMathOclValid \upsilon \ap (X :: C_i) \Longrightarrow
    \tau \isasymMathOclValid X \mocl{.oclIsTypeOf(}C_i\mocl{)} \ap \mocl{implies} \ap (X \mocl{.oclAsType(}C_j\mocl{) .oclAsType(}C_i\mocl{)}) \isasymMathOclStrictEq X \\
 \tau \isasymMathOclValid \delta \ap X \Longrightarrow \tau \isasymMathOclValid (X::C_i)\mocl{.oclAsType(}C_j\mocl{) .oclAsType(}C_i\mocl{)} \isasymMathOclStrongEq X \\
 \tau \isasymMathOclValid (X::C_j)\mocl{.oclIsTypeOf(}C_j\mocl{)} \Longrightarrow \tau \isasymMathOclValid \delta \ap X \Longrightarrow \tau \isasymMathOclValid \mocl{not} \ap (\upsilon \ap X \mocl{.oclAsType(}C_i\mocl{)}) \\
 \tau \isasymMathOclValid \mocl{invalid .oclIsTypeOf(}C_i\mocl{)} \isasymMathOclStrongEq \mocl{invalid} \\
 \tau \isasymMathOclValid \mocl{null .oclIsTypeOf(}C_i\mocl{)} \isasymMathOclStrongEq \mocl{true} \\
 \tau \isasymMathOclValid C_z \mocl{.allInstances()->forAll(}X\mocl{|}X \mocl{.oclIsTypeOf(}C_z\mocl{))} \\
 \tau \isasymMathOclValid C_z \mocl{.allInstances@pre()->forAll(}X\mocl{|}X \mocl{.oclIsTypeOf(}C_z\mocl{))} \\
 \tau \isasymMathOclValid C_i \mocl{.allInstances()->forAll(}X\mocl{|}X \mocl{.oclIsKindOf(}C_j\mocl{))} \\
 \tau \isasymMathOclValid C_i \mocl{.allInstances@pre()->forAll(}X\mocl{|}X \mocl{.oclIsKindOf(}C_j\mocl{))} \\
 \tau \isasymMathOclValid (X::C_i)\mocl{.oclIsTypeOf(}C_j\mocl{)} \Longrightarrow \tau \isasymMathOclValid (X::C_i)\mocl{.oclIsKindOf(}C_j\mocl{)} \\
(\tau \isasymMathOclValid (X::C_j) \isasymMathOclStrictEq X) = (\tau \isasymMathOclValid \mocl{if} \ap \upsilon \ap X \ap \mocl{then true else invalid endif}) \\
 \tau \isasymMathOclValid (X::C_j) \isasymMathOclStrictEq Y \Longrightarrow  \tau \isasymMathOclValid Y \isasymMathOclStrictEq X \\
 \tau \isasymMathOclValid (X::C_j) \isasymMathOclStrictEq Y \Longrightarrow  \tau \isasymMathOclValid Y \isasymMathOclStrictEq Z  \Longrightarrow   \tau \isasymMathOclValid X \isasymMathOclStrictEq Z \\
\vdots
\end{gather*}

\subsubsection{Algebraic Properties of the Class-Models}\label{sec:algprop-datamodel}
In this section, we assume to have $C_i,C_j \in C$ and  $C_i < C_j$.
The operations induced from a class-model have the following  properties:
\begin{gather*}
\begin{array}{ll}
 \mocl{invalid .oclIsTypeOf(}C_i\mocl{)} = \mocl{invalid}  \qquad
 \mocl{null .oclIsTypeOf(}C_i\mocl{)} = \mocl{true}        \\
 \mocl{invalid .oclIsKindOf(}C_i\mocl{)} = \mocl{invalid}  \qquad
 \mocl{null .oclIsKindOf(}C_i\mocl{)} = \mocl{true}        \\
 \mocl{invalid .oclAsType(}C_i\mocl{)} = \mocl{invalid}    \qquad
 \mocl{null .oclAsType(}C_i\mocl{)} = \mocl{null}          \\
 (X::C_i)\mocl{.oclAsType(}C_i\mocl{)} = X                 \qquad
 (X::C_i)\mocl{.oclAsType(}C_j\mocl{).oclAsType(}C_i\mocl{)} = X
\end{array} \\
 ((X::C_i) \isasymMathOclStrictEq X) = (\mocl{if} \ap \upsilon ~ X \ap \mocl{then true else invalid endif}) \\
\end{gather*}
With respect to attributes $\getAttrib{\_}{\text{a}}$ or $\getAttrib{\_}{\text{a}\isasymOclATpre}$
and role-ends $\getAttrib{\_}{\text{r}}$ or $\getAttrib{\_}{\text{r}\isasymOclATpre}$ we have
\begin{gather*}
 \getAttrib{\mocl{invalid}}{\text{a}} = \mocl{invalid} \qquad
 \getAttrib{\mocl{null}}{\text{a}} = \mocl{invalid} \\
 \getAttrib{\mocl{invalid}}{\text{a}\isasymOclATpre} = \mocl{invalid} \qquad
 \getAttrib{\mocl{null}}{\text{a}\isasymOclATpre} = \mocl{invalid} \\
 \getRole{\mocl{invalid}}{\text{r}} = \mocl{invalid} \qquad
 \getRole{\mocl{null}}{\text{r}} = \mocl{invalid} \\
 \getRole{\mocl{invalid}}{\text{r}\isasymOclATpre} = \mocl{invalid} \qquad
 \getRole{\mocl{null}}{\text{r}\isasymOclATpre} = \mocl{invalid}
\end{gather*}

\subsubsection{Other Operations on States}\label{sec:otherStateOperations}
Defining $\_\isasymOclAllInstances$
is straight-forward; the only difference is the property
$T\isasymOclAllInstances\isasymOclExcludes\mocl{(}\isasymOclNull\mocl{)}$ which is a
consequence of the fact that $\Null{}$'s are values and do not ``live'' in the
state.  \OCL semantics admits states with ``dangling references,''; it is
the semantics of accessors or roles which maps these references to \mocl{invalid},
which makes it possible to rule out these situations in invariants.

%it is
%possible to define a counterpart to \inlineocl+_.oclIsNew()+ called
%\inlineocl+_.oclIsDeleted()+ which asks if an object id (represented by an object
%representation) is contained in the pre-state, but not the post-state.

\OCL does not guarantee that an operation only modifies the path-expressions
mentioned in the postcondition, \ie, it allows arbitrary relations from
pre-states to post-states.  This framing problem is well-known (one of the
suggested solutions is~\cite{kosiuczenko:specification:2006}). We define
\begin{ocl}
 (S:Set(OclAny))->oclIsModifiedOnly():Boolean
\end{ocl}
where \inlineocl|S| is a set of object representations, encoding
a set of $\oid$'s. The semantics of this operator is defined such that
for any object whose $\oid$ is \emph{not }represented in \inlineocl|S|
and that is defined in pre and post state, the corresponding object representation will not change
in the state transition. A simplified presentation is as follows:
\begin{gather*}
I\semantics{X\isasymMathOclIsModifiedOnly} (\sigma, \sigma')  \equiv
  \begin{cases}
    \isasymbottom & \text{if $X' = \bottom \lor \mocl{null}\in X'$}    \\
     \lift{\isasymforall i \isasymin M\spot
        \sigma~i = \sigma'~i} & \text{otherwise}\mi{.}
   \end{cases}
\end{gather*}
where $X' = I\semantics{X} (\sigma, \sigma')$ and $M=
(\dom~\sigma\cap\dom~\sigma') - \{ \HolOclOidOf x |~x \in\drop{X'}\}$.  Thus, if
we require in a postcondition \inlineocl|Set{}->oclIsModifiedOnly()| and exclude via
\inlineocl+_.oclIsNew()+ and \inlineocl+_.oclIsDeleted()+ the existence of new
or deleted objects, the operation is a query in the sense of the \OCL standard, \ie,
the \inlineocl|isQuery| property is true. So, whenever we have $ \tau
\isasymMathOclValid X\isasymOclExcluding\mocl{(}s.a\mocl{)}\isasymMathOclIsModifiedOnly$ and $ \tau
\isasymMathOclValid X\mocl{->forAll(}x\mocl{|}\mocl{not}(x \doteq s.a) \mocl{)}$, we can infer that $\tau
\isasymMathOclValid s.a \triangleq s.a\isasymOclATpre$.


\subsection{Data Invariants}\label{sec:invlogic}
Since the present \OCL semantics uses one interpretation function\footnote{This has been handled
differently in previous versions of the Annex A.}, we express the effect of \OCL terms
occurring in preconditions and invariants by a syntactic transformation $\__\text{pre}$ which
replaces:
\begin{itemize}
\item all accessor functions $\getAttrib{\_}{a}$ from the class model $a \in Attrib(C)$ by their
counterparts $\getAttrib{\_}{i\isasymOclATpre}$. For example, $(\getAttrib{\self}{salary} >
500)_\text{pre}$ is transformed to $(\getAttrib{\self}{salary\isasymOclATpre} > 500)$.
\item all role accessor functions  $\getRole{\_}{rn_{from}}$ or  $\getRole{\_}{rn_{to}}$
      within the class model (\ie, $(id, rn_{from},  rn_{to}) \in Assoc(C_i, C_j)$)
      were replaced by their counterparts $\getRole{\_}{rn\isasymOclATpre}$.
      For example, $(\getAttrib{\self}{boss} = null)_\text{pre}$ is transformed to
      $\getAttrib{\self}{boss\isasymOclATpre} = null$.
\item The operation $\_\isasymOclAllInstances$ is also substituted by its
$\isasymOclATpre$ counterpart.
\end{itemize}
Thus, we formulate the semantics of the invariant specification  as follows:
\begin{gather*}
\begin{aligned}
& I\semantics{\mathtt{context}~c:C_i~\mathtt{inv}~n: \phi(c)} \tau \equiv  \\
&\qquad \tau  \isasymMathOclValid  (C_i\isasymOclAllInstances\isasymOclForAll(x
\text{|} \phi(x)))~\land \\
&\qquad \tau  \isasymMathOclValid (C_i\isasymOclAllInstances\isasymOclForAll(x
\text{|} \phi(x)))_\text{pre}
\end{aligned}
\end{gather*}
Recall that  expressions containing $\isasymOclATpre$ constructs in
invariants or preconditions are syntactically forbidden; thus, mixed forms cannot arise.

\subsection{Operation Contracts}
Since operations have strict semantics in \OCL, we have to distinguish for a specification of an
operation $\mathit{op}$ with the arguments $a_1$, \ldots, $a_n$ the
two cases where all arguments are valid and additionally, $\self$ is non-null (\ie, it must be defined), or not.
In former case, a method call can be replaced by a $\mathit{result}$
that satisfies the contract, in the latter case the result is
\mocl{invalid}. This is reflected by the following definition of the contract semantics:
\begin{gather*}
\begin{aligned}
 I\semantics{& \mathtt{context}~C~:: \mathit{op}(a_1, \ldots, a_n) : T \\
                     & \qquad\mathtt{pre}~ \phi(\self, a_1, \ldots, a_n)  \\
                     & \qquad\mathtt{post}~\psi(\self, a_1, \ldots, a_n, \mathit{result})}  \equiv \\
 & \qquad \quad \lambda  s,  x_1, \ldots, x_n, \tau.  \\
 & \qquad\qquad \text{if}  ~ ~ \tau
\isasymMathOclValid \isasymMathOclIsDefined s \land \tau \isasymMathOclValid
\isasymupsilon~x_1 \land \ldots \land  \tau \isasymMathOclValid
\isasymupsilon~ x_n \\
 & \qquad\qquad \text{then} ~ \text{SOME}~ \mathit{result}. ~ ~ ~ ~\tau \isasymMathOclValid \phi(s, x_1, \ldots, x_n)_\text{pre} \\
 & \qquad\qquad\qquad\qquad\qquad\qquad ~ ~          \land \tau \isasymMathOclValid \psi(s, x_1, \ldots, x_n, \mathit{result}))\\
 &\qquad\qquad  \text{else}  ~  \isasymMathOclUndefined
\end{aligned}
\end{gather*}
where $\text{SOME}~ x. ~P(x)$ is the Hilbert-Choice Operator that
chooses an arbitrary element satisfying $P$; if such an element does not exist, it chooses
an arbitrary one\footnote{In \HOL, the Hilbert-Choice operator is a first-class element of
the logical language.}. Thus, using the Hilbert-Choice Operator, a contract can be associated
to a function definition:
\begin{gather*}
    f_{op}  \equiv I\semantics{ \mathtt{context}~C~:: \mathit{op}(a_1, \ldots, a_n) : T \ldots }
\end{gather*}
provided that neither $\phi$  nor $\psi$ contain recursive method calls of $\mathit{op}$.
In the case of a query operation (\ie, $\tau$ must have the form: $(\sigma,\sigma)$, which
means that query operations do not change the state; c.f. \mocl{oclIsModifiedOnly()} in
\autoref{sec:otherStateOperations}), this constraint can be relaxed: the above
equation is then stated as \emph{axiom}. Note however, that the consistency of the overall
theory is for recursive query contracts left to the user (it can be shown, for example, by a proof
of termination, \ie, by showing that all recursive calls were applied to  argument vectors that are
smaller wrt. a well-founded ordering). Under this condition, an $f_{op}$ resulting from recursive
query operations can be used safely inside pre- and post-conditions of other contracts.

For the general case of a user-defined contract, the following rule can be established
that reduces the proof of a property $E$ over a method call $f_{op}$ to a proof
of $E(res)$ (where $res$ must be one of the values that satisfy the post-condition $\psi$):
\begin{gather*}
  \begin{prooftree}
     \[ \big[ \tau \isasymMathOclValid \psi~self~a_1\ldots a_n~res \big]_{res}
        \leadsto
        \tau \isasymMathOclValid E(res)
     \]
    \justifies
    \tau \isasymMathOclValid E(f_{op}~self~a_1 \ldots a_n)
    \end{prooftree}
\end{gather*}
under the conditions:
\begin{itemize}
\item $E$ must be an \OCL term and
\item $\self$ must be defined, and the arguments valid in $\tau$: \\
      $\tau \isasymMathOclValid \isasymMathOclIsDefined~\self \land \tau \isasymMathOclValid \isasymupsilon~a_1 \land \ldots \land  \tau \isasymMathOclValid \isasymupsilon~ a_n$
\item the post-condition must be satisfiable (``the operation must be implementable''):
      $\exists res.~ \tau \isasymMathOclValid \psi ~\self ~a_1 \ldots a_n~res $.
\end{itemize}
For the special case of a (recursive) query method, this rule can be specialized to the following
executable ``unfolding principle'':
\begin{gather*}
  \begin{prooftree}
  \tau \isasymMathOclValid \phi~self~a_1\ldots a_n
  \justifies
  (\tau \isasymMathOclValid E(f_{op}~self~a_1\ldots a_n)) = e
  (\tau \isasymMathOclValid E (BODY~self~a_1
  \cdots a_n))
  \end{prooftree}
\end{gather*}
where
\begin{itemize}
\item $E$ must be an \OCL term.
\item $\self$ must be defined, and the arguments valid in $\tau$: \\
      $\tau \isasymMathOclValid \isasymMathOclIsDefined~\self \land \tau \isasymMathOclValid \isasymupsilon~a_1 \land \ldots \land  \tau \isasymMathOclValid \isasymupsilon~ a_n$
\item the postcondition $\psi~self~a_1~\ldots~a_n~result$ must be decomposable
      into: \\
      $\psi'~self~a_1~\ldots a_n$ and $result \isasymMathOclStrongEq BODY~self~a_1~\ldots~a_n$.
\end{itemize}
Currently, \FOCL neither supports overloading nor overriding for
user-defined operations: the \FOCL compiler needs to be extended to
generate pre-conditions that constrain the classes on which an
overridden function can be called as well as the dispatch order. This
construction, overall, is similar to the virtual function table that,
e.g., is generated by C++ compilers. Moreover, to avoid logical
contradictions (inconsistencies) between different instances of an
overridden operation, the user has to prove Liskov's principle for
these situations: pre-conditions of the superclass must imply
pre-conditions of the subclass, and post-conditions of a subclass must
imply post-conditions of the superclass.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "root"
%%% End:

%  LocalWords:  \UML \OCL implementors RFP OMG provers invariants
%  LocalWords:  wellfounded Denotational equalities
