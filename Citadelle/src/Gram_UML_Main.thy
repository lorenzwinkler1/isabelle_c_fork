lexicon: "!" "!!" "#" "%" "&" "&&&" "(" "()" "(|" ")" "*" "*⇩R" "*⇩i⇩n⇩t"
  "*⇩r⇩e⇩a⇩l" "+" "++" "+⇩i⇩n⇩t" "+⇩r⇩e⇩a⇩l" "+⇩s⇩t⇩r⇩i⇩n⇩g" "," "-" "--" "---->"
  "--->" "-->" "->any⇩B⇩a⇩g()" "->any⇩S⇩e⇩q()" "->any⇩S⇩e⇩t()" "->append⇩S⇩e⇩q("
  "->asBoolean⇩I⇩n⇩t()" "->asBoolean⇩R⇩e⇩a⇩l()" "->asInteger⇩R⇩e⇩a⇩l()"
  "->asPair⇩S⇩e⇩q()" "->asPair⇩S⇩e⇩t()" "->asReal⇩I⇩n⇩t()" "->asSequence⇩P⇩a⇩i⇩r()"
  "->asSequence⇩S⇩e⇩t()" "->asSet⇩P⇩a⇩i⇩r()" "->asSet⇩S⇩e⇩q()" "->at⇩S⇩e⇩q("
  "->collect⇩S⇩e⇩q(" "->count⇩B⇩a⇩g(" "->count⇩S⇩e⇩t(" "->excludesAll⇩B⇩a⇩g("
  "->excludesAll⇩S⇩e⇩t(" "->excludes⇩B⇩a⇩g(" "->excludes⇩S⇩e⇩t("
  "->excluding⇩B⇩a⇩g(" "->excluding⇩S⇩e⇩q(" "->excluding⇩S⇩e⇩t(" "->exists⇩B⇩a⇩g("
  "->exists⇩S⇩e⇩q(" "->exists⇩S⇩e⇩t(" "->first⇩S⇩e⇩q(" "->forAll⇩B⇩a⇩g("
  "->forAll⇩S⇩e⇩q(" "->forAll⇩S⇩e⇩t(" "->includesAll⇩B⇩a⇩g(" "->includesAll⇩S⇩e⇩t("
  "->includes⇩B⇩a⇩g(" "->includes⇩S⇩e⇩t(" "->including⇩B⇩a⇩g(" "->including⇩S⇩e⇩q("
  "->including⇩S⇩e⇩t(" "->intersection⇩B⇩a⇩g(" "->intersection⇩S⇩e⇩t("
  "->isEmpty⇩B⇩a⇩g()" "->isEmpty⇩S⇩e⇩q()" "->isEmpty⇩S⇩e⇩t()" "->iterate⇩B⇩a⇩g("
  "->iterate⇩S⇩e⇩q(" "->iterate⇩S⇩e⇩t(" "->last⇩S⇩e⇩q(" "->notEmpty⇩B⇩a⇩g()"
  "->notEmpty⇩S⇩e⇩q()" "->notEmpty⇩S⇩e⇩t()" "->oclIsModifiedOnly()"
  "->prepend⇩S⇩e⇩q(" "->reject⇩B⇩a⇩g(" "->reject⇩S⇩e⇩t(" "->select⇩B⇩a⇩g("
  "->select⇩S⇩e⇩q(" "->select⇩S⇩e⇩t(" "->size⇩B⇩a⇩g()" "->size⇩S⇩e⇩q()"
  "->size⇩S⇩e⇩t()" "->sum⇩B⇩a⇩g()" "->sum⇩S⇩e⇩t()" "->union⇩B⇩a⇩g("
  "->union⇩S⇩e⇩q(" "->union⇩S⇩e⇩t(" "-⇩i⇩n⇩t" "-⇩r⇩e⇩a⇩l" "-`" "." ".." "..." "..<"
  "..}" ".First()" ".Second()" ".allInstances()" ".allInstances@pre()"
  ".oclIsAbsent()" ".oclIsDeleted()" ".oclIsMaintained()" ".oclIsNew()" "/" "//"
  "/⇩R" "0" "1" ":" "::" ":=" ":>" ";" "<" "<*>" "<*lex*>" "<*mlex*>" "<+>" "<-"
  "<->" "<.." "<..<" "<..}" "<=" "<>" "<⇩i⇩n⇩t" "<⇩r⇩e⇩a⇩l" "=" "==" "==>" "=>"
  "=simp=>" ">" ">=" "?" "?!" "@" "@post" "@pre" "ALL" "Bag(" "Bag{" "Bag{}" "CHR"
  "CONST" "CSUM" "DERIV" "EX" "EX!" "FDERIV" "GREATEST" "INF" "INFM" "INT" "I⟦"
  "Int" "LEAST" "LIM" "MOST" "O" "OFCLASS" "OO" "PROD" "PROP" "Pair(" "Pair{"
  "SIGMA" "SOME" "SORT_CONSTRAINT" "SUM" "SUP" "Sequence(" "Sequence{" "Sequence{}"
  "Set(" "Set{" "Set{}" "TERM" "THE" "TYPE" "TYPEREP" "UN" "Un" "WRT" "XCONST" "["
  "[↦]" "[]" "[|" "[|->]" "⋀" "∷" "⋂" "⟹" "∏" "⇒" "⨅⇩f⇩i⇩n" "⨆⇩f⇩i⇩n" "∑"
  "⊨" "⋃" "⇘" "⇙" "⇧*" "⇧*⇧*" "⇧+" "⇧+⇧+" "⇧2" "⇧=" "⇧=⇧=" "𝖺" "∧" "𝖻" "¦" "⊥" "𝖼"
  "∘" "∘⇩m" "δ" "≐" "…" "𝟴" "𝟴.𝟬" "≡" "∃" "∃!" "∃⇩F" "∃⇩∞" "𝟱" "𝟱.𝟬" "∀" "∀⇩F"
  "∀⇩∞" "𝟰" "𝟰.𝟬" "≥" "∈" "ı" "ℤ" "∩" "¯" "¯¯" "λ" "⟨" "⟦" "⌈" "≤" "≤⇩i⇩n⇩t"
  "≤⇩r⇩e⇩a⇩l" "←" "⌊" "⟷" "⟶" "⦇" "↦" "ℕ" "𝟵" "𝟵.𝟬" "¬" "≠" "∉" "𝟭" "𝟭.𝟬" "𝟭𝟬"
  "𝟭𝟬.𝟬" "∨" "π" "⟩⇩⊥" "ℚ" "⟧" "⌉" "ℝ" "⌋" "⇀" "⦈" "𝟳" "𝟳.𝟬" "𝟲" "𝟲.𝟬" "ϵ" "⋄" "⊂"
  "⊆" "⊆⇩m" "⊃" "⊇" "𝟯" "𝟯.𝟬" "×" "≜" "𝟮" "𝟮.𝟬" "∪" "υ" "𝟬" "𝟬.𝟬" "]" "^" "^*"
  "^**" "^+" "^++" "^--1" "^-1" "^=" "^==" "^^" "_" "_'" "`" "``" "and" "at" "case"
  "chain⇩⊆" "choose" "differentiable" "div" "div⇩i⇩n⇩t" "div⇩r⇩e⇩a⇩l" "dvd" "else"
  "endif" "gchoose" "has_derivative" "has_field_derivative" "has_real_derivative"
  "has_vector_derivative" "if" "implies" "in" "initial_segment_of" "let" "mod"
  "mod⇩i⇩n⇩t" "mod⇩r⇩e⇩a⇩l" "not" "o" "o_m" "of" "op" "or" "powr" "respects"
  "respects2" "sums" "then" "within" "{" "{.." "{..<" "{}" "|" "|)" "|->" "|≠" "|]"
  "|`" "}" "~" "~:" "~=" "~=>"
prods:
  Fun.updbind = any[0] ":=" any[0] => "_updbind" (1000)
  Fun.updbinds = Fun.updbind[0] "," Fun.updbinds[0] => "_updbinds" (1000)
  Fun.updbinds = Fun.updbind[-1] (-1)
  HOL.case_syn = any[0] "⇒" any[0] => "_case1" (10)
  HOL.case_syn = any[0] "=>" any[0] => "_case1" (10)
  HOL.cases_syn = HOL.case_syn[0] "|" HOL.cases_syn[0] => "_case2" (1000)
  HOL.cases_syn = HOL.case_syn[-1] (-1)
  HOL.letbind = pttrn[0] "=" any[0] => "_bind" (10)
  HOL.letbinds = HOL.letbind[0] ";" HOL.letbinds[0] => "_binds" (1000)
  HOL.letbinds = HOL.letbind[-1] (-1)
  List.lc_qual = logic[0] => "_lc_test" (1000)
  List.lc_qual = any[0] "←" logic[0] => "_lc_gen" (1000)
  List.lc_qual = any[0] "<-" logic[0] => "_lc_gen" (1000)
  List.lc_quals = "," List.lc_qual[0] List.lc_quals[0] => "_lc_quals" (1000)
  List.lc_quals = "]" => "_lc_end" (1000)
  List.lupdbind = any[0] ":=" any[0] => "_lupdbind" (1000)
  List.lupdbinds = List.lupdbind[0] "," List.lupdbinds[0] => "_lupdbinds" (1000)
  List.lupdbinds = List.lupdbind[-1] (-1)
  Map.maplet = any[0] "↦" any[0] => "_maplet" (1000)
  Map.maplet = any[0] "[↦]" any[0] => "_maplets" (1000)
  Map.maplet = any[0] "|->" any[0] => "_maplet" (1000)
  Map.maplet = any[0] "[|->]" any[0] => "_maplets" (1000)
  Map.maplets = Map.maplet[0] "," Map.maplets[0] => "_Maplets" (1000)
  Map.maplets = Map.maplet[-1] (-1)
  Product_Type.patterns = pttrn[0] "," Product_Type.patterns[0] => "_patterns"
    (1000)
  Product_Type.patterns = pttrn[-1] (-1)
  Product_Type.tuple_args = any[0] => "_tuple_arg" (1000)
  Product_Type.tuple_args = any[0] "," Product_Type.tuple_args[0] => "_tuple_args"
    (1000)
  Record.field = Record.ident[0] "=" any[0] => "_field" (1000)
  Record.field_type = Record.ident[0] "::" type[0] => "_field_type" (1000)
  Record.field_types = Record.field_type[0] "," Record.field_types[0]
    => "_field_types" (1000)
  Record.field_types = Record.field_type[-1] (-1)
  Record.field_update = Record.ident[0] ":=" any[0] => "_field_update" (1000)
  Record.field_updates = Record.field_update[0] "," Record.field_updates[0]
    => "_field_updates" (1000)
  Record.field_updates = Record.field_update[-1] (-1)
  Record.fields = Record.field[0] "," Record.fields[0] => "_fields" (1000)
  Record.fields = Record.field[-1] (-1)
  Record.ident = longid => "_constify" (1000)
  Record.ident = id => "_constify" (1000)
  any = prop'[-1] (-1)
  any = logic[-1] (-1)
  aprop = "_" => "\<^const>Pure.dummy_pattern" (1000)
  aprop = "XCONST" longid_position[0] => "_context_xconst" (1000)
  aprop = "XCONST" id_position[0] => "_context_xconst" (1000)
  aprop = "CONST" longid_position[0] => "_context_const" (1000)
  aprop = "CONST" id_position[0] => "_context_const" (1000)
  aprop = "..." => "_DDDOT" (1000)
  aprop = "(" aprop[0] ")" (1000)
  aprop = "…" => "_DDDOT" (1000)
  aprop = logic[1000] cargs[1000] => "_applC" (999)
  aprop = var_position[-1] (-1)
  aprop = longid_position[-1] (-1)
  aprop = id_position[-1] (-1)
  args = any[0] "," args[0] => "_args" (1000)
  args = any[-1] (-1)
  asms = prop[0] ";" asms[0] => "_asms" (1000)
  asms = prop[0] => "_asm" (1000)
  cargs = any[1000] cargs[1000] => "_cargs" (1000)
  cargs = any[-1] (-1)
  cartouche_position = cartouche => "_position" (1000)
  class_name = longid => "_class_name" (1000)
  class_name = id => "_class_name" (1000)
  classes = class_name[0] "," classes[0] => "_classes" (1000)
  classes = class_name[-1] (-1)
  float_const = float_position[0] => "_constify" (1000)
  float_position = float_token => "_position" (1000)
  id_position = id => "_position" (1000)
  idt = "(" idt[0] ")" (1000)
  idt = "_" "::" type[0] => "_idtypdummy" (0)
  idt = "_" => "_idtdummy" (1000)
  idt = "_" "∷" type[0] => "_idtypdummy" (0)
  idt = id_position[0] "::" type[0] => "_idtyp" (0)
  idt = id_position[0] "∷" type[0] => "_idtyp" (0)
  idt = id_position[-1] (-1)
  idts = idt[1] idts[0] => "_idts" (0)
  idts = idt[-1] (-1)
  index = "ı" => "_indexvar" (1000)
  index = => "_indexdefault" (1000)
  index = "⇘" logic[0] "⇙" => "_index" (1000)
  logic = "op" "&&&" => "\<^const>Pure.conjunction" (1000)
  logic = "op" "==>" => "\<^const>Pure.imp" (1000)
  logic = "op" "⟹" => "\<^const>Pure.imp" (1000)
  logic = "op" "≡" => "\<^const>Pure.eq" (1000)
  logic = "op" "==" => "\<^const>Pure.eq" (1000)
  logic = "op" "-->" => "\<^const>HOL.implies" (1000)
  logic = "op" "=" => "\<^const>HOL.eq" (1000)
  logic = "op" "|" => "\<^const>HOL.disj" (1000)
  logic = "op" "&" => "\<^const>HOL.conj" (1000)
  logic = "op" "~=" => "\<^const>HOL.not_equal" (1000)
  logic = "op" "≠" => "\<^const>HOL.not_equal" (1000)
  logic = "op" "⟶" => "\<^const>HOL.implies" (1000)
  logic = "op" "∨" => "\<^const>HOL.disj" (1000)
  logic = "op" "∧" => "\<^const>HOL.conj" (1000)
  logic = "op" "<->" => "\<^const>HOL.iff" (1000)
  logic = "op" "⟷" => "\<^const>HOL.iff" (1000)
  logic = "op" "=simp=>" => "\<^const>HOL.simp_implies" (1000)
  logic = "op" "<" => "\<^const>Orderings.ord_class.less" (1000)
  logic = "op" "<=" => "\<^const>Orderings.ord_class.less_eq" (1000)
  logic = "op" "≤" => "\<^const>Orderings.ord_class.less_eq" (1000)
  logic = "op" ">=" => "\<^const>Orderings.ord_class.greater_eq" (1000)
  logic = "op" "≥" => "\<^const>Orderings.ord_class.greater_eq" (1000)
  logic = "op" ">" => "\<^const>Orderings.ord_class.greater" (1000)
  logic = "op" "+" => "\<^const>Groups.plus_class.plus" (1000)
  logic = "op" "-" => "\<^const>Groups.minus_class.minus" (1000)
  logic = "op" "*" => "\<^const>Groups.times_class.times" (1000)
  logic = "op" ":" => "\<^const>Set.member" (1000)
  logic = "op" "~:" => "\<^const>Set.not_member" (1000)
  logic = "op" "∉" => "\<^const>Set.not_member" (1000)
  logic = "op" "∈" => "\<^const>Set.member" (1000)
  logic = "op" "⊆" => "\<^const>Set.subset_eq" (1000)
  logic = "op" "⊂" => "\<^const>Set.subset" (1000)
  logic = "op" "⊇" => "\<^const>Set.supset_eq" (1000)
  logic = "op" "⊃" => "\<^const>Set.supset" (1000)
  logic = "op" "Int" => "\<^const>Set.inter" (1000)
  logic = "op" "∩" => "\<^const>Set.inter" (1000)
  logic = "op" "Un" => "\<^const>Set.union" (1000)
  logic = "op" "∪" => "\<^const>Set.union" (1000)
  logic = "op" "`" => "\<^const>Set.image" (1000)
  logic = "op" "-`" => "\<^const>Set.vimage" (1000)
  logic = "op" "o" => "\<^const>Fun.comp" (1000)
  logic = "op" "∘" => "\<^const>Fun.comp" (1000)
  logic = "op" "<*>" => "\<^const>Product_Type.Times" (1000)
  logic = "op" "×" => "\<^const>Product_Type.Times" (1000)
  logic = "op" "<+>" => "\<^const>Sum_Type.Plus" (1000)
  logic = "op" "dvd" => "\<^const>Rings.dvd_class.dvd" (1000)
  logic = "op" "/" => "\<^const>Fields.inverse_class.divide" (1000)
  logic = "op" "^^" => "\<^const>Nat.compower" (1000)
  logic = "op" "O" => "\<^const>Relation.relcomp" (1000)
  logic = "op" "OO" => "\<^const>Relation.relcompp" (1000)
  logic = "op" "``" => "\<^const>Relation.Image" (1000)
  logic = "op" "<*lex*>" => "\<^const>Wellfounded.lex_prod" (1000)
  logic = "op" "<*mlex*>" => "\<^const>Wellfounded.mlex_prod" (1000)
  logic = "op" "initial_segment_of" => "\<^const>Zorn.initialSegmentOf" (1000)
  logic = "op" "//" => "\<^const>Equiv_Relations.quotient" (1000)
  logic = "op" "respects" => "\<^const>Equiv_Relations.RESPECTS" (1000)
  logic = "op" "respects2" => "\<^const>Equiv_Relations.RESPECTS2" (1000)
  logic = "op" "^" => "\<^const>Power.power_class.power" (1000)
  logic = "op" "div" => "\<^const>Divides.div_class.div" (1000)
  logic = "op" "mod" => "\<^const>Divides.div_class.mod" (1000)
  logic = "op" "#" => "\<^const>List.list.Cons" (1000)
  logic = "op" "@" => "\<^const>List.append" (1000)
  logic = "op" "!" => "\<^const>List.nth" (1000)
  logic = "op" "o_m" => "\<^const>Map.map_comp" (1000)
  logic = "op" "∘⇩m" => "\<^const>Map.map_comp" (1000)
  logic = "op" "++" => "\<^const>Map.map_add" (1000)
  logic = "op" "|`" => "\<^const>Map.restrict_map" (1000)
  logic = "op" "⊆⇩m" => "\<^const>Map.map_le" (1000)
  logic = "op" "choose" => "\<^const>Binomial.binomial" (1000)
  logic = "op" "gchoose" => "\<^const>Binomial.gbinomial" (1000)
  logic = "op" "--->"
    => "\<^const>Topological_Spaces.topological_space_class.tendsto" (1000)
  logic = "op" "*⇩R" => "\<^const>Real_Vector_Spaces.scaleR_class.scaleR" (1000)
  logic = "op" "/⇩R" => "\<^const>Real_Vector_Spaces.scaleR_class.divideR" (1000)
  logic = "op" "sums" => "\<^const>Series.sums" (1000)
  logic = "op" "has_derivative" => "\<^const>Deriv.has_derivative" (1000)
  logic = "op" "has_field_derivative" => "\<^const>Deriv.has_field_derivative"
    (1000)
  logic = "op" "has_vector_derivative" => "\<^const>Deriv.has_vector_derivative"
    (1000)
  logic = "op" "differentiable" => "\<^const>Deriv.differentiable" (1000)
  logic = "op" "has_real_derivative" => "\<^const>Deriv.has_real_derivative" (1000)
  logic = "op" "powr" => "\<^const>Transcendental.powr" (1000)
  logic = "op" "≜" => "\<^const>UML_Logic.StrongEq" (1000)
  logic = "op" "and" => "\<^const>UML_Logic.OclAnd" (1000)
  logic = "op" "or" => "\<^const>UML_Logic.OclOr" (1000)
  logic = "op" "implies" => "\<^const>UML_Logic.OclImplies" (1000)
  logic = "op" "≐" => "\<^const>UML_Logic.StrictRefEq" (1000)
  logic = "op" "<>" => "notequal" (1000)
  logic = "op" "+⇩i⇩n⇩t" => "\<^const>UML_Integer.OclAdd⇩I⇩n⇩t⇩e⇩g⇩e⇩r" (1000)
  logic = "op" "-⇩i⇩n⇩t" => "\<^const>UML_Integer.OclMinus⇩I⇩n⇩t⇩e⇩g⇩e⇩r" (1000)
  logic = "op" "*⇩i⇩n⇩t" => "\<^const>UML_Integer.OclMult⇩I⇩n⇩t⇩e⇩g⇩e⇩r" (1000)
  logic = "op" "div⇩i⇩n⇩t" => "\<^const>UML_Integer.OclDivision⇩I⇩n⇩t⇩e⇩g⇩e⇩r"
    (1000)
  logic = "op" "mod⇩i⇩n⇩t" => "\<^const>UML_Integer.OclModulus⇩I⇩n⇩t⇩e⇩g⇩e⇩r"
    (1000)
  logic = "op" "<⇩i⇩n⇩t" => "\<^const>UML_Integer.OclLess⇩I⇩n⇩t⇩e⇩g⇩e⇩r" (1000)
  logic = "op" "≤⇩i⇩n⇩t" => "\<^const>UML_Integer.OclLe⇩I⇩n⇩t⇩e⇩g⇩e⇩r" (1000)
  logic = "op" "+⇩s⇩t⇩r⇩i⇩n⇩g" => "\<^const>UML_String.OclAdd⇩S⇩t⇩r⇩i⇩n⇩g" (1000)
  logic = "op" "+⇩r⇩e⇩a⇩l" => "\<^const>UML_Real.OclAdd⇩R⇩e⇩a⇩l" (1000)
  logic = "op" "-⇩r⇩e⇩a⇩l" => "\<^const>UML_Real.OclMinus⇩R⇩e⇩a⇩l" (1000)
  logic = "op" "*⇩r⇩e⇩a⇩l" => "\<^const>UML_Real.OclMult⇩R⇩e⇩a⇩l" (1000)
  logic = "op" "div⇩r⇩e⇩a⇩l" => "\<^const>UML_Real.OclDivision⇩R⇩e⇩a⇩l" (1000)
  logic = "op" "mod⇩r⇩e⇩a⇩l" => "\<^const>UML_Real.OclModulus⇩R⇩e⇩a⇩l" (1000)
  logic = "op" "<⇩r⇩e⇩a⇩l" => "\<^const>UML_Real.OclLess⇩R⇩e⇩a⇩l" (1000)
  logic = "op" "≤⇩r⇩e⇩a⇩l" => "\<^const>UML_Real.OclLe⇩R⇩e⇩a⇩l" (1000)
  logic = "XCONST" longid_position[0] => "_context_xconst" (1000)
  logic = "XCONST" id_position[0] => "_context_xconst" (1000)
  logic = "CONST" longid_position[0] => "_context_const" (1000)
  logic = "CONST" id_position[0] => "_context_const" (1000)
  logic = "⋄" index[1000] => "_struct" (1000)
  logic = "..." => "_DDDOT" (1000)
  logic = "TYPE" "(" type[0] ")" => "_TYPE" (1000)
  logic = "%" pttrns[0] "." any[3] => "_lambda" (3)
  logic = "%" HOL.cases_syn[0] => "_lam_pats_syntax" (10)
  logic = "(" logic[0] ")" (1000)
  logic = "(" any[0] "," Product_Type.tuple_args[0] ")" => "_tuple" (1000)
  logic = "…" => "_DDDOT" (1000)
  logic = "λ" pttrns[0] "." any[3] => "_lambda" (3)
  logic = "λ" HOL.cases_syn[0] => "_lam_pats_syntax" (10)
  logic = "_" => "\<^const>Pure.dummy_pattern" (1000)
  logic = "EX!" idts[0] "." logic[10] => "\<^const>HOL.Ex1_binder" (10)
  logic = "EX!" pttrn[0] ":" logic[0] "." logic[10] => "_Bex1" (10)
  logic = "EX" idts[0] "." logic[10] => "\<^const>HOL.Ex_binder" (10)
  logic = "EX" idt[0] ">=" any[0] "." logic[10] => "_Ex_greater_eq" (10)
  logic = "EX" idt[0] ">" any[0] "." logic[10] => "_Ex_greater" (10)
  logic = "EX" idt[0] "<=" any[0] "." logic[10] => "_Ex_less_eq" (10)
  logic = "EX" idt[0] "<" any[0] "." logic[10] => "_Ex_less" (10)
  logic = "EX" pttrn[0] ":" logic[0] "." logic[10] => "_Bex" (10)
  logic = "ALL" idts[0] "." logic[10] => "\<^const>HOL.All_binder" (10)
  logic = "ALL" idt[0] ">=" any[0] "." logic[10] => "_All_greater_eq" (10)
  logic = "ALL" idt[0] ">" any[0] "." logic[10] => "_All_greater" (10)
  logic = "ALL" idt[0] "<=" any[0] "." logic[10] => "_All_less_eq" (10)
  logic = "ALL" idt[0] "<" any[0] "." logic[10] => "_All_less" (10)
  logic = "ALL" pttrn[0] ":" logic[0] "." logic[10] => "_Ball" (10)
  logic = "~" logic[40] => "\<^const>HOL.Not" (40)
  logic = "¬" logic[40] => "\<^const>HOL.Not" (40)
  logic = "THE" pttrn[0] "." logic[10] => "_The" (10)
  logic = "let" HOL.letbinds[0] "in" any[10] => "_Let" (10)
  logic = "case" any[0] "of" HOL.cases_syn[0] => "_case_syntax" (10)
  logic = "∃!" idts[0] "." logic[10] => "\<^const>HOL.Ex1_binder" (10)
  logic = "∃!" pttrn[0] "∈" logic[0] "." logic[10] => "_Bex1" (10)
  logic = "∃!" idt[0] "⊆" any[0] "." logic[10] => "_setleEx1" (10)
  logic = "∃" idts[0] "." logic[10] => "\<^const>HOL.Ex_binder" (10)
  logic = "∃" idt[0] "≥" any[0] "." logic[10] => "_Ex_greater_eq" (10)
  logic = "∃" idt[0] ">" any[0] "." logic[10] => "_Ex_greater" (10)
  logic = "∃" idt[0] "≤" any[0] "." logic[10] => "_Ex_less_eq" (10)
  logic = "∃" idt[0] "<" any[0] "." logic[10] => "_Ex_less" (10)
  logic = "∃" pttrn[0] "∈" logic[0] "." logic[10] => "_Bex" (10)
  logic = "∃" idt[0] "⊆" any[0] "." logic[10] => "_setleEx" (10)
  logic = "∃" idt[0] "⊂" any[0] "." logic[10] => "_setlessEx" (10)
  logic = "∀" idts[0] "." logic[10] => "\<^const>HOL.All_binder" (10)
  logic = "∀" idt[0] "≥" any[0] "." logic[10] => "_All_greater_eq" (10)
  logic = "∀" idt[0] ">" any[0] "." logic[10] => "_All_greater" (10)
  logic = "∀" idt[0] "≤" any[0] "." logic[10] => "_All_less_eq" (10)
  logic = "∀" idt[0] "<" any[0] "." logic[10] => "_All_less" (10)
  logic = "∀" pttrn[0] "∈" logic[0] "." logic[10] => "_Ball" (10)
  logic = "∀" idt[0] "⊆" any[0] "." logic[10] => "_setleAll" (10)
  logic = "∀" idt[0] "⊂" any[0] "." logic[10] => "_setlessAll" (10)
  logic = "?!" idts[0] "." logic[10] => "\<^const>HOL.Ex1_binder" (10)
  logic = "?!" pttrn[0] ":" logic[0] "." logic[10] => "_Bex1" (10)
  logic = "?" idts[0] "." logic[10] => "\<^const>HOL.Ex_binder" (10)
  logic = "?" idt[0] "<=" any[0] "." logic[10] => "_Ex_less_eq" (10)
  logic = "?" idt[0] "<" any[0] "." logic[10] => "_Ex_less" (10)
  logic = "?" pttrn[0] ":" logic[0] "." logic[10] => "_Bex" (10)
  logic = "!" idts[0] "." logic[10] => "\<^const>HOL.All_binder" (10)
  logic = "!" idt[0] "<=" any[0] "." logic[10] => "_All_less_eq" (10)
  logic = "!" idt[0] "<" any[0] "." logic[10] => "_All_less" (10)
  logic = "!" pttrn[0] ":" logic[0] "." logic[10] => "_Ball" (10)
  logic = "if" logic[0] "then" any[0] "else" any[10] => "\<^const>HOL.If" (10)
  logic = "if" logic[10] "then" logic[10] "else" logic[10] "endif"
    => "\<^const>UML_Logic.OclIf" (50)
  logic = "LEAST" idts[0] "." logic[10]
    => "\<^const>Orderings.ord_class.Least_binder" (10)
  logic = "LEAST" id ":" logic[0] "." logic[10] => "_Bleast" (10)
  logic = "LEAST" id "∈" logic[0] "." logic[10] => "_Bleast" (10)
  logic = "LEAST" pttrn[0] "WRT" logic[4] "." logic[10] => "_LeastM" (10)
  logic = "0" => "\<^const>Groups.zero_class.zero" (1000)
  logic = "-" any[81] => "\<^const>Groups.uminus_class.uminus" (80)
  logic = "¦" any[0] "¦" => "\<^const>Groups.abs_class.abs" (1000)
  logic = "1" => "\<^const>Groups.one_class.one" (1000)
  logic = "{" pttrn[0] "." logic[0] "}" => "_Coll" (1000)
  logic = "{" pttrn[0] ":" logic[0] "." logic[0] "}" => "_Collect" (1000)
  logic = "{" pttrn[0] "∈" logic[0] "." logic[0] "}" => "_Collect" (1000)
  logic = "{" args[0] "}" => "_Finset" (1000)
  logic = "{" any[0] "|" idts[0] "." logic[0] "}" => "_Setcompr" (1000)
  logic = "{" any[0] "<..}" => "\<^const>Set_Interval.ord_class.greaterThan" (1000)
  logic = "{" any[0] "..}" => "\<^const>Set_Interval.ord_class.atLeast" (1000)
  logic = "{" any[0] "<..<" any[0] "}"
    => "\<^const>Set_Interval.ord_class.greaterThanLessThan" (1000)
  logic = "{" any[0] "..<" any[0] "}"
    => "\<^const>Set_Interval.ord_class.atLeastLessThan" (1000)
  logic = "{" any[0] "<.." any[0] "}"
    => "\<^const>Set_Interval.ord_class.greaterThanAtMost" (1000)
  logic = "{" any[0] ".." any[0] "}"
    => "\<^const>Set_Interval.ord_class.atLeastAtMost" (1000)
  logic = "{}" => "\<^const>Set.empty" (1000)
  logic = "SUP" pttrn[0] ":" logic[0] "." any[10] => "_SUP" (10)
  logic = "SUP" pttrns[0] "." any[10] => "_SUP1" (10)
  logic = "INF" pttrn[0] ":" logic[0] "." any[10] => "_INF" (10)
  logic = "INF" pttrns[0] "." any[10] => "_INF1" (10)
  logic = "⋂" logic[900] => "\<^const>Complete_Lattices.Inter" (900)
  logic = "⋂" pttrn[0] "∈" logic[0] "." logic[10] => "_INTER" (10)
  logic = "⋂" pttrns[0] "." logic[10] => "_INTER1" (10)
  logic = "⋂" any[0] "<" any[0] "." logic[10] => "_INTER_less" (10)
  logic = "⋂" any[0] "≤" any[0] "." logic[10] => "_INTER_le" (10)
  logic = "INT" pttrn[0] ":" logic[0] "." logic[10] => "_INTER" (10)
  logic = "INT" pttrns[0] "." logic[10] => "_INTER1" (10)
  logic = "INT" any[0] "<" any[0] "." logic[10] => "_INTER_less" (10)
  logic = "INT" any[0] "<=" any[0] "." logic[10] => "_INTER_le" (10)
  logic = "⋃" logic[900] => "\<^const>Complete_Lattices.Union" (900)
  logic = "⋃" pttrn[0] "∈" logic[0] "." logic[10] => "_UNION" (10)
  logic = "⋃" pttrns[0] "." logic[10] => "_UNION1" (10)
  logic = "⋃" any[0] "<" any[0] "." logic[10] => "_UNION_less" (10)
  logic = "⋃" any[0] "≤" any[0] "." logic[10] => "_UNION_le" (10)
  logic = "UN" pttrn[0] ":" logic[0] "." logic[10] => "_UNION" (10)
  logic = "UN" pttrns[0] "." logic[10] => "_UNION1" (10)
  logic = "UN" any[0] "<" any[0] "." logic[10] => "_UNION_less" (10)
  logic = "UN" any[0] "<=" any[0] "." logic[10] => "_UNION_le" (10)
  logic = "()" => "\<^const>Product_Type.Unity" (1000)
  logic = "SIGMA" pttrn[0] ":" logic[0] "." logic[10] => "_Sigma" (10)
  logic = "ℕ" => "\<^const>Nat.semiring_1_class.Nats" (1000)
  logic = "ϵ" pttrn[0] "." logic[10] => "_Eps" (10)
  logic = "@" pttrn[0] "." logic[10] => "_Eps" (10)
  logic = "SOME" pttrn[0] "." logic[10] => "_Eps" (10)
  logic = "GREATEST" idts[0] "." logic[10]
    => "\<^const>Hilbert_Choice.Greatest_binder" (10)
  logic = "GREATEST" pttrn[0] "WRT" logic[4] "." logic[10] => "_GreatestM" (10)
  logic = "chain⇩⊆" => "\<^const>Zorn.chain_subset" (1000)
  logic = "CSUM" pttrn[0] ":" logic[51] "." logic[10] => "_Csum" (10)
  logic = num_const[0] => "_Numeral" (1000)
  logic = "∑" logic[1000] => "\<^const>Groups_Big.comm_monoid_add_class.Setsum"
    (999)
  logic = "∑" pttrn[0] "∈" logic[51] "." any[10] => "_setsum" (10)
  logic = "∑" pttrn[0] "|" logic[0] "." any[10] => "_qsetsum" (10)
  logic = "∑" idt[0] "≤" any[0] "." any[10] => "_upto_setsum" (10)
  logic = "∑" idt[0] "<" any[0] "." any[10] => "_upt_setsum" (10)
  logic = "∑" idt[0] "=" any[0] "..<" any[0] "." any[10] => "_from_upto_setsum"
    (10)
  logic = "∑" idt[0] "=" any[0] ".." any[0] "." any[10] => "_from_to_setsum" (10)
  logic = "∑" pttrn[0] "←" logic[51] "." any[10] => "_listsum" (10)
  logic = "∑" idts[0] "." any[10] => "\<^const>Series.suminf_binder" (10)
  logic = "SUM" pttrn[0] ":" logic[51] "." any[10] => "_setsum" (10)
  logic = "SUM" pttrn[0] "|" logic[0] "." any[10] => "_qsetsum" (10)
  logic = "SUM" idt[0] "<=" any[0] "." any[10] => "_upto_setsum" (10)
  logic = "SUM" idt[0] "<" any[0] "." any[10] => "_upt_setsum" (10)
  logic = "SUM" idt[0] "=" any[0] "..<" any[0] "." any[10] => "_from_upto_setsum"
    (10)
  logic = "SUM" idt[0] "=" any[0] ".." any[0] "." any[10] => "_from_to_setsum" (10)
  logic = "SUM" pttrn[0] "<-" logic[51] "." any[10] => "_listsum" (10)
  logic = "∏" logic[1000] => "\<^const>Groups_Big.comm_monoid_mult_class.Setprod"
    (999)
  logic = "∏" pttrn[0] "∈" logic[51] "." any[10] => "_setprod" (10)
  logic = "∏" pttrn[0] "|" logic[0] "." any[10] => "_qsetprod" (10)
  logic = "∏" idt[0] "≤" any[0] "." any[10] => "_upto_setprod" (10)
  logic = "∏" idt[0] "<" any[0] "." any[10] => "_upt_setprod" (10)
  logic = "∏" idt[0] "=" any[0] "..<" any[0] "." any[10] => "_from_upto_setprod"
    (10)
  logic = "∏" idt[0] "=" any[0] ".." any[0] "." any[10] => "_from_to_setprod" (10)
  logic = "∏" pttrn[0] "←" logic[51] "." any[10] => "_listprod" (10)
  logic = "PROD" pttrn[0] ":" logic[51] "." any[10] => "_setprod" (10)
  logic = "PROD" pttrn[0] "|" logic[0] "." any[10] => "_qsetprod" (10)
  logic = "PROD" idt[0] "<=" any[0] "." any[10] => "_upto_setprod" (10)
  logic = "PROD" idt[0] "<" any[0] "." any[10] => "_upt_setprod" (10)
  logic = "PROD" idt[0] "=" any[0] "..<" any[0] "." any[10] => "_from_upto_setprod"
    (10)
  logic = "PROD" idt[0] "=" any[0] ".." any[0] "." any[10] => "_from_to_setprod"
    (10)
  logic = "PROD" pttrn[0] "<-" logic[51] "." any[10] => "_listprod" (10)
  logic = "ℤ" => "\<^const>Int.ring_1_class.Ints" (1000)
  logic = "⨅⇩f⇩i⇩n" logic[900]
    => "\<^const>Lattices_Big.semilattice_inf_class.Inf_fin" (900)
  logic = "⨆⇩f⇩i⇩n" logic[900]
    => "\<^const>Lattices_Big.semilattice_sup_class.Sup_fin" (900)
  logic = "{..<" any[0] "}" => "\<^const>Set_Interval.ord_class.lessThan" (1000)
  logic = "{.." any[0] "}" => "\<^const>Set_Interval.ord_class.atMost" (1000)
  logic = "[]" => "\<^const>List.list.Nil" (1000)
  logic = "[" args[0] "]" => "_list" (1000)
  logic = "[" pttrn[0] "<-" logic[0] "." logic[0] "]" => "_filter" (1000)
  logic = "[" pttrn[0] "←" logic[0] "." logic[0] "]" => "_filter" (1000)
  logic = "[" logic[0] "..<" logic[0] "]" => "\<^const>List.upt" (1000)
  logic = "[" any[0] "." List.lc_qual[0] List.lc_quals[0] => "_listcompr" (1000)
  logic = "[" logic[0] ".." logic[0] "]" => "\<^const>List.upto" (1000)
  logic = "[" Map.maplets[0] "]" => "_Map" (1000)
  logic = "CHR" str_position[0] => "_Char" (1000)
  logic = str_position[0] => "_String" (1000)
  logic = "TYPEREP" "(" type[0] ")" => "_TYPEREP" (1000)
  logic = "(|" Record.fields[0] "," "..." "=" any[0] "|)" => "_record_scheme"
    (1000)
  logic = "(|" Record.fields[0] "|)" => "_record" (1000)
  logic = "⦇" Record.fields[0] "," "…" "=" any[0] "⦈" => "_record_scheme" (1000)
  logic = "⦇" Record.fields[0] "⦈" => "_record" (1000)
  logic = "∀⇩F" pttrn[0] "in" logic[0] "." logic[10] => "_eventually" (10)
  logic = "∃⇩F" pttrn[0] "in" logic[0] "." logic[10] => "_frequently" (10)
  logic = "INFM" idts[0] "." logic[10] => "\<^const>Filter.Inf_many_binder" (10)
  logic = "MOST" idts[0] "." logic[10] => "\<^const>Filter.Alm_all_binder" (10)
  logic = "∀⇩∞" idts[0] "." logic[10] => "\<^const>Filter.Alm_all_binder" (10)
  logic = "∃⇩∞" idts[0] "." logic[10] => "\<^const>Filter.Inf_many_binder" (10)
  logic = "LIM" pttrns[1000] any[10] "." any[0] ":>" any[10] => "_LIM" (10)
  logic = "ℚ" => "\<^const>Rat.field_char_0_class.Rats" (1000)
  logic = float_const[0] => "_Float" (1000)
  logic = "at" any[1000] "within" logic[60]
    => "\<^const>Topological_Spaces.topological_space_class.at_within" (60)
  logic = "at" => "\<^const>Topological_Spaces.topological_space_class.at" (1000)
  logic = "ℝ" => "\<^const>Real_Vector_Spaces.Reals" (1000)
  logic = "FDERIV" logic[1000] any[1000] ":>" logic[60] => "\<^const>Deriv.FDERIV"
    (60)
  logic = "DERIV" logic[1000] any[1000] ":>" any[60] => "\<^const>Deriv.DERIV" (60)
  logic = "⌊" any[0] "⌋" => "\<^const>Option.option.Some" (1000)
  logic = "⌈" logic[0] "⌉" => "\<^const>UML_Types.drop" (1000)
  logic = "I⟦" any[0] "⟧" => "\<^const>UML_Types.Sem" (1000)
  logic = "υ" logic[100] => "\<^const>UML_Logic.valid" (100)
  logic = "δ" logic[100] => "\<^const>UML_Logic.defined" (100)
  logic = "not" => "\<^const>UML_Logic.OclNot" (1000)
  logic = "⊥" => "\<^const>UML_Types.bot_class.bot" (1000)
  logic = "⊥" => "\<^const>Option.option.None" (1000)
  logic = "Pair{" logic[0] "," logic[0] "}" => "\<^const>UML_Pair.OclPair" (1000)
  logic = "𝟬" => "\<^const>UML_Integer.OclInt0" (1000)
  logic = "𝟭" => "\<^const>UML_Integer.OclInt1" (1000)
  logic = "𝟮" => "\<^const>UML_Integer.OclInt2" (1000)
  logic = "𝟯" => "\<^const>UML_Integer.OclInt3" (1000)
  logic = "𝟰" => "\<^const>UML_Integer.OclInt4" (1000)
  logic = "𝟱" => "\<^const>UML_Integer.OclInt5" (1000)
  logic = "𝟲" => "\<^const>UML_Integer.OclInt6" (1000)
  logic = "𝟳" => "\<^const>UML_Integer.OclInt7" (1000)
  logic = "𝟴" => "\<^const>UML_Integer.OclInt8" (1000)
  logic = "𝟵" => "\<^const>UML_Integer.OclInt9" (1000)
  logic = "𝟭𝟬" => "\<^const>UML_Integer.OclInt10" (1000)
  logic = "Bag{}" => "\<^const>UML_Bag.mtBag" (1000)
  logic = "Bag{" args[0] "}" => "_OclFinbag" (1000)
  logic = "𝖺" => "\<^const>UML_String.OclStringa" (1000)
  logic = "𝖻" => "\<^const>UML_String.OclStringb" (1000)
  logic = "𝖼" => "\<^const>UML_String.OclStringc" (1000)
  logic = "𝟬.𝟬" => "\<^const>UML_Real.OclReal0" (1000)
  logic = "𝟭.𝟬" => "\<^const>UML_Real.OclReal1" (1000)
  logic = "𝟮.𝟬" => "\<^const>UML_Real.OclReal2" (1000)
  logic = "𝟯.𝟬" => "\<^const>UML_Real.OclReal3" (1000)
  logic = "𝟰.𝟬" => "\<^const>UML_Real.OclReal4" (1000)
  logic = "𝟱.𝟬" => "\<^const>UML_Real.OclReal5" (1000)
  logic = "𝟲.𝟬" => "\<^const>UML_Real.OclReal6" (1000)
  logic = "𝟳.𝟬" => "\<^const>UML_Real.OclReal7" (1000)
  logic = "𝟴.𝟬" => "\<^const>UML_Real.OclReal8" (1000)
  logic = "𝟵.𝟬" => "\<^const>UML_Real.OclReal9" (1000)
  logic = "𝟭𝟬.𝟬" => "\<^const>UML_Real.OclReal10" (1000)
  logic = "π" => "\<^const>UML_Real.OclRealpi" (1000)
  logic = "Set{}" => "\<^const>UML_Set.mtSet" (1000)
  logic = "Set{" args[0] "}" => "_OclFinset" (1000)
  logic = "Sequence{}" => "\<^const>UML_Sequence.mtSequence" (1000)
  logic = "Sequence{" args[0] "}" => "_OclFinsequence" (1000)
  logic = cartouche_position[0] => "_cartouche_oclstring" (1000)
  logic = "_'" => "_ocl_denotation" (1000)
  logic = logic[0] "->asSequence⇩P⇩a⇩i⇩r()"
    => "\<^const>UML_Library.OclAsSeq⇩P⇩a⇩i⇩r" (1000)
  logic = logic[0] "->asSequence⇩S⇩e⇩t()" => "\<^const>UML_Library.OclAsSeq⇩S⇩e⇩t"
    (1000)
  logic = logic[0] "->asSet⇩P⇩a⇩i⇩r()" => "\<^const>UML_Library.OclAsSet⇩P⇩a⇩i⇩r"
    (1000)
  logic = logic[0] "->asSet⇩S⇩e⇩q()" => "\<^const>UML_Library.OclAsSet⇩S⇩e⇩q"
    (1000)
  logic = logic[0] "->asPair⇩S⇩e⇩t()" => "\<^const>UML_Library.OclAsPair⇩S⇩e⇩t"
    (1000)
  logic = logic[0] "->asPair⇩S⇩e⇩q()" => "\<^const>UML_Library.OclAsPair⇩S⇩e⇩q"
    (1000)
  logic = logic[0] "->asReal⇩I⇩n⇩t()" => "\<^const>UML_Library.OclAsReal⇩I⇩n⇩t"
    (1000)
  logic = logic[0] "->asInteger⇩R⇩e⇩a⇩l()"
    => "\<^const>UML_Library.OclAsInteger⇩R⇩e⇩a⇩l" (1000)
  logic = logic[0] "->asBoolean⇩R⇩e⇩a⇩l()"
    => "\<^const>UML_Library.OclAsBoolean⇩R⇩e⇩a⇩l" (1000)
  logic = logic[0] "->asBoolean⇩I⇩n⇩t()"
    => "\<^const>UML_Library.OclAsBoolean⇩I⇩n⇩t" (1000)
  logic = logic[0] "->any⇩S⇩e⇩q()" => "\<^const>UML_Sequence.OclANY" (1000)
  logic = logic[0] "->notEmpty⇩S⇩e⇩q()" => "\<^const>UML_Sequence.OclNotEmpty"
    (1000)
  logic = logic[0] "->isEmpty⇩S⇩e⇩q()" => "\<^const>UML_Sequence.OclIsEmpty" (1000)
  logic = logic[0] "->size⇩S⇩e⇩q()" => "\<^const>UML_Sequence.OclSize" (1000)
  logic = logic[0] "->select⇩S⇩e⇩q(" id "|" logic[0] ")" => "_OclSelectSeq" (1000)
  logic = logic[0] "->collect⇩S⇩e⇩q(" id "|" logic[0] ")" => "_OclCollectSeq"
    (1000)
  logic = logic[0] "->exists⇩S⇩e⇩q(" id "|" logic[0] ")" => "_OclExistSeq" (1000)
  logic = logic[0] "->forAll⇩S⇩e⇩q(" id "|" logic[0] ")" => "_OclForallSeq" (1000)
  logic = logic[0] "->iterate⇩S⇩e⇩q(" idt[0] ";" idt[0] "=" any[0] "|" any[0] ")"
    => "_OclIterateSeq" (1000)
  logic = logic[0] "->last⇩S⇩e⇩q(" logic[0] ")" => "\<^const>UML_Sequence.OclLast"
    (1000)
  logic = logic[0] "->first⇩S⇩e⇩q(" logic[0] ")"
    => "\<^const>UML_Sequence.OclFirst" (1000)
  logic = logic[0] "->at⇩S⇩e⇩q(" logic[0] ")" => "\<^const>UML_Sequence.OclAt"
    (1000)
  logic = logic[0] "->union⇩S⇩e⇩q(" logic[0] ")"
    => "\<^const>UML_Sequence.OclUnion" (1000)
  logic = logic[0] "->append⇩S⇩e⇩q(" logic[0] ")"
    => "\<^const>UML_Sequence.OclAppend" (1000)
  logic = logic[0] "->excluding⇩S⇩e⇩q(" logic[0] ")"
    => "\<^const>UML_Sequence.OclExcluding" (1000)
  logic = logic[0] "->including⇩S⇩e⇩q(" logic[0] ")"
    => "\<^const>UML_Sequence.OclIncluding" (1000)
  logic = logic[0] "->prepend⇩S⇩e⇩q(" logic[0] ")"
    => "\<^const>UML_Sequence.OclPrepend" (1000)
  logic = logic[0] "->sum⇩S⇩e⇩t()" => "\<^const>UML_Set.OclSum" (1000)
  logic = logic[0] "->count⇩S⇩e⇩t(" logic[0] ")" => "\<^const>UML_Set.OclCount"
    (1000)
  logic = logic[0] "->intersection⇩S⇩e⇩t(" logic[0] ")"
    => "\<^const>UML_Set.OclIntersection" (1000)
  logic = logic[0] "->union⇩S⇩e⇩t(" logic[0] ")" => "\<^const>UML_Set.OclUnion"
    (1000)
  logic = logic[0] "->excludesAll⇩S⇩e⇩t(" logic[0] ")"
    => "\<^const>UML_Set.OclExcludesAll" (1000)
  logic = logic[0] "->includesAll⇩S⇩e⇩t(" logic[0] ")"
    => "\<^const>UML_Set.OclIncludesAll" (1000)
  logic = logic[0] "->reject⇩S⇩e⇩t(" id "|" logic[0] ")" => "_OclRejectSet" (1000)
  logic = logic[0] "->select⇩S⇩e⇩t(" id "|" logic[0] ")" => "_OclSelectSet" (1000)
  logic = logic[0] "->iterate⇩S⇩e⇩t(" idt[0] ";" idt[0] "=" any[0] "|" any[0] ")"
    => "_OclIterateSet" (1000)
  logic = logic[0] "->exists⇩S⇩e⇩t(" id "|" logic[0] ")" => "_OclExistSet" (1000)
  logic = logic[0] "->forAll⇩S⇩e⇩t(" id "|" logic[0] ")" => "_OclForallSet" (1000)
  logic = logic[0] "->any⇩S⇩e⇩t()" => "\<^const>UML_Set.OclANY" (1000)
  logic = logic[0] "->notEmpty⇩S⇩e⇩t()" => "\<^const>UML_Set.OclNotEmpty" (1000)
  logic = logic[0] "->isEmpty⇩S⇩e⇩t()" => "\<^const>UML_Set.OclIsEmpty" (1000)
  logic = logic[0] "->size⇩S⇩e⇩t()" => "\<^const>UML_Set.OclSize" (1000)
  logic = logic[0] "->excludes⇩S⇩e⇩t(" logic[0] ")"
    => "\<^const>UML_Set.OclExcludes" (1000)
  logic = logic[0] "->includes⇩S⇩e⇩t(" logic[0] ")"
    => "\<^const>UML_Set.OclIncludes" (1000)
  logic = logic[0] "->excluding⇩S⇩e⇩t(" logic[0] ")"
    => "\<^const>UML_Set.OclExcluding" (1000)
  logic = logic[0] "->including⇩S⇩e⇩t(" logic[0] ")"
    => "\<^const>UML_Set.OclIncluding" (1000)
  logic = logic[36] "≤⇩r⇩e⇩a⇩l" logic[36] => "\<^const>UML_Real.OclLe⇩R⇩e⇩a⇩l" (35)
  logic = logic[36] "<⇩r⇩e⇩a⇩l" logic[36] => "\<^const>UML_Real.OclLess⇩R⇩e⇩a⇩l"
    (35)
  logic = logic[46] "mod⇩r⇩e⇩a⇩l" logic[46]
    => "\<^const>UML_Real.OclModulus⇩R⇩e⇩a⇩l" (45)
  logic = logic[46] "div⇩r⇩e⇩a⇩l" logic[46]
    => "\<^const>UML_Real.OclDivision⇩R⇩e⇩a⇩l" (45)
  logic = logic[46] "*⇩r⇩e⇩a⇩l" logic[46] => "\<^const>UML_Real.OclMult⇩R⇩e⇩a⇩l"
    (45)
  logic = logic[42] "-⇩r⇩e⇩a⇩l" logic[42] => "\<^const>UML_Real.OclMinus⇩R⇩e⇩a⇩l"
    (41)
  logic = logic[41] "+⇩r⇩e⇩a⇩l" logic[41] => "\<^const>UML_Real.OclAdd⇩R⇩e⇩a⇩l"
    (40)
  logic = logic[41] "+⇩s⇩t⇩r⇩i⇩n⇩g" logic[41]
    => "\<^const>UML_String.OclAdd⇩S⇩t⇩r⇩i⇩n⇩g" (40)
  logic = logic[0] "->sum⇩B⇩a⇩g()" => "\<^const>UML_Bag.OclSum" (1000)
  logic = logic[0] "->count⇩B⇩a⇩g(" logic[0] ")" => "\<^const>UML_Bag.OclCount"
    (1000)
  logic = logic[0] "->intersection⇩B⇩a⇩g(" logic[0] ")"
    => "\<^const>UML_Bag.OclIntersection" (1000)
  logic = logic[0] "->union⇩B⇩a⇩g(" logic[0] ")" => "\<^const>UML_Bag.OclUnion"
    (1000)
  logic = logic[0] "->excludesAll⇩B⇩a⇩g(" logic[0] ")"
    => "\<^const>UML_Bag.OclExcludesAll" (1000)
  logic = logic[0] "->includesAll⇩B⇩a⇩g(" logic[0] ")"
    => "\<^const>UML_Bag.OclIncludesAll" (1000)
  logic = logic[0] "->reject⇩B⇩a⇩g(" id "|" logic[0] ")" => "_OclRejectBag" (1000)
  logic = logic[0] "->select⇩B⇩a⇩g(" id "|" logic[0] ")" => "_OclSelectBag" (1000)
  logic = logic[0] "->iterate⇩B⇩a⇩g(" idt[0] ";" idt[0] "=" any[0] "|" any[0] ")"
    => "_OclIterateBag" (1000)
  logic = logic[0] "->exists⇩B⇩a⇩g(" id "|" logic[0] ")" => "_OclExistBag" (1000)
  logic = logic[0] "->forAll⇩B⇩a⇩g(" id "|" logic[0] ")" => "_OclForallBag" (1000)
  logic = logic[0] "->any⇩B⇩a⇩g()" => "\<^const>UML_Bag.OclANY" (1000)
  logic = logic[0] "->notEmpty⇩B⇩a⇩g()" => "\<^const>UML_Bag.OclNotEmpty" (1000)
  logic = logic[0] "->isEmpty⇩B⇩a⇩g()" => "\<^const>UML_Bag.OclIsEmpty" (1000)
  logic = logic[0] "->size⇩B⇩a⇩g()" => "\<^const>UML_Bag.OclSize" (1000)
  logic = logic[0] "->excludes⇩B⇩a⇩g(" logic[0] ")"
    => "\<^const>UML_Bag.OclExcludes" (1000)
  logic = logic[0] "->includes⇩B⇩a⇩g(" logic[0] ")"
    => "\<^const>UML_Bag.OclIncludes" (1000)
  logic = logic[0] "->excluding⇩B⇩a⇩g(" logic[0] ")"
    => "\<^const>UML_Bag.OclExcluding" (1000)
  logic = logic[0] "->including⇩B⇩a⇩g(" logic[0] ")"
    => "\<^const>UML_Bag.OclIncluding" (1000)
  logic = logic[36] "≤⇩i⇩n⇩t" logic[36]
    => "\<^const>UML_Integer.OclLe⇩I⇩n⇩t⇩e⇩g⇩e⇩r" (35)
  logic = logic[36] "<⇩i⇩n⇩t" logic[36]
    => "\<^const>UML_Integer.OclLess⇩I⇩n⇩t⇩e⇩g⇩e⇩r" (35)
  logic = logic[46] "mod⇩i⇩n⇩t" logic[46]
    => "\<^const>UML_Integer.OclModulus⇩I⇩n⇩t⇩e⇩g⇩e⇩r" (45)
  logic = logic[46] "div⇩i⇩n⇩t" logic[46]
    => "\<^const>UML_Integer.OclDivision⇩I⇩n⇩t⇩e⇩g⇩e⇩r" (45)
  logic = logic[46] "*⇩i⇩n⇩t" logic[46]
    => "\<^const>UML_Integer.OclMult⇩I⇩n⇩t⇩e⇩g⇩e⇩r" (45)
  logic = logic[42] "-⇩i⇩n⇩t" logic[42]
    => "\<^const>UML_Integer.OclMinus⇩I⇩n⇩t⇩e⇩g⇩e⇩r" (41)
  logic = logic[41] "+⇩i⇩n⇩t" logic[41]
    => "\<^const>UML_Integer.OclAdd⇩I⇩n⇩t⇩e⇩g⇩e⇩r" (40)
  logic = logic[0] ".Second()" => "\<^const>UML_Pair.OclSecond" (1000)
  logic = logic[0] ".First()" => "\<^const>UML_Pair.OclFirst" (1000)
  logic = logic[41] "<>" logic[41] => "notequal" (40)
  logic = logic[30] "≐" logic[31] => "\<^const>UML_Logic.StrictRefEq" (30)
  logic = logic[0] "|≠" logic[0] => "OclNonValid" (50)
  logic = logic[0] "⊨" logic[0] => "\<^const>UML_Logic.OclValid" (50)
  logic = logic[25] "implies" logic[26] => "\<^const>UML_Logic.OclImplies" (25)
  logic = logic[25] "or" logic[26] => "\<^const>UML_Logic.OclOr" (25)
  logic = logic[30] "and" logic[31] => "\<^const>UML_Logic.OclAnd" (30)
  logic = logic[30] "≜" logic[31] => "\<^const>UML_Logic.StrongEq" (30)
  logic = logic[51] "has_real_derivative" logic[51]
    => "\<^const>Deriv.has_real_derivative" (50)
  logic = logic[51] "differentiable" logic[51] => "\<^const>Deriv.differentiable"
    (50)
  logic = logic[51] "has_vector_derivative" any[51]
    => "\<^const>Deriv.has_vector_derivative" (50)
  logic = logic[51] "has_field_derivative" any[51]
    => "\<^const>Deriv.has_field_derivative" (50)
  logic = logic[51] "has_derivative" logic[51] => "\<^const>Deriv.has_derivative"
    (50)
  logic = logic[81] "sums" any[80] => "\<^const>Series.sums" (80)
  logic = logic[76] "*⇩R" any[75]
    => "\<^const>Real_Vector_Spaces.scaleR_class.scaleR" (75)
  logic = logic[60] "--" any[0] "-->" any[60] => "\<^const>Topological_Spaces.LIM"
    (60)
  logic = logic[60] "---->" any[60]
    => "\<^const>Topological_Spaces.topological_space_class.LIMSEQ" (60)
  logic = logic[56] "--->" any[55]
    => "\<^const>Topological_Spaces.topological_space_class.tendsto" (55)
  logic = logic[65] "choose" logic[66] => "\<^const>Binomial.binomial" (65)
  logic = logic[900] "(" Map.maplets[0] ")" => "_MapUpd" (900)
  logic = logic[51] "⊆⇩m" logic[51] => "\<^const>Map.map_le" (50)
  logic = logic[110] "|`" logic[111] => "\<^const>Map.restrict_map" (110)
  logic = logic[100] "++" logic[101] => "\<^const>Map.map_add" (100)
  logic = logic[55] "∘⇩m" logic[56] => "\<^const>Map.map_comp" (55)
  logic = logic[55] "o_m" logic[56] => "\<^const>Map.map_comp" (55)
  logic = logic[100] "!" logic[101] => "\<^const>List.nth" (100)
  logic = logic[66] "@" logic[65] => "\<^const>List.append" (65)
  logic = logic[81] "respects2" logic[80] => "\<^const>Equiv_Relations.RESPECTS2"
    (80)
  logic = logic[81] "respects" logic[80] => "\<^const>Equiv_Relations.RESPECTS"
    (80)
  logic = logic[90] "//" logic[91] => "\<^const>Equiv_Relations.quotient" (90)
  logic = logic[56] "initial_segment_of" logic[56]
    => "\<^const>Zorn.initialSegmentOf" (55)
  logic = logic[81] "<*mlex*>" logic[80] => "\<^const>Wellfounded.mlex_prod" (80)
  logic = logic[81] "<*lex*>" logic[80] => "\<^const>Wellfounded.lex_prod" (80)
  logic = logic[1000] "⇧*⇧*" => "\<^const>Transitive_Closure.rtranclp" (1000)
  logic = logic[1000] "⇧+⇧+" => "\<^const>Transitive_Closure.tranclp" (1000)
  logic = logic[1000] "⇧=⇧=" => "\<^const>Transitive_Closure.reflclp" (1000)
  logic = logic[1000] "⇧*" => "\<^const>Transitive_Closure.rtrancl" (999)
  logic = logic[1000] "⇧+" => "\<^const>Transitive_Closure.trancl" (999)
  logic = logic[1000] "⇧=" => "\<^const>Transitive_Closure.reflcl" (999)
  logic = logic[1000] "^=" => "\<^const>Transitive_Closure.reflcl" (999)
  logic = logic[1000] "^==" => "\<^const>Transitive_Closure.reflclp" (1000)
  logic = logic[1000] "^**" => "\<^const>Transitive_Closure.rtranclp" (1000)
  logic = logic[1000] "^++" => "\<^const>Transitive_Closure.tranclp" (1000)
  logic = logic[1000] "^+" => "\<^const>Transitive_Closure.trancl" (999)
  logic = logic[1000] "^*" => "\<^const>Transitive_Closure.rtrancl" (999)
  logic = logic[91] "``" logic[90] => "\<^const>Relation.Image" (90)
  logic = logic[1000] "¯¯" => "\<^const>Relation.conversep" (1000)
  logic = logic[1000] "^--1" => "\<^const>Relation.conversep" (1000)
  logic = logic[1000] "¯" => "\<^const>Relation.converse" (999)
  logic = logic[1000] "^-1" => "\<^const>Relation.converse" (999)
  logic = logic[76] "OO" logic[75] => "\<^const>Relation.relcompp" (75)
  logic = logic[76] "O" logic[75] => "\<^const>Relation.relcomp" (75)
  logic = logic[66] "<+>" logic[65] => "\<^const>Sum_Type.Plus" (65)
  logic = logic[81] "×" logic[80] => "\<^const>Product_Type.Times" (80)
  logic = logic[81] "<*>" logic[80] => "\<^const>Product_Type.Times" (80)
  logic = logic[55] "∘" logic[56] => "\<^const>Fun.comp" (55)
  logic = logic[55] "o" logic[56] => "\<^const>Fun.comp" (55)
  logic = logic[91] "-`" logic[90] => "\<^const>Set.vimage" (90)
  logic = logic[91] "`" logic[90] => "\<^const>Set.image" (90)
  logic = logic[65] "∪" logic[66] => "\<^const>Set.union" (65)
  logic = logic[65] "Un" logic[66] => "\<^const>Set.union" (65)
  logic = logic[70] "∩" logic[71] => "\<^const>Set.inter" (70)
  logic = logic[70] "Int" logic[71] => "\<^const>Set.inter" (70)
  logic = logic[51] "⊃" logic[51] => "\<^const>Set.supset" (50)
  logic = logic[51] "⊇" logic[51] => "\<^const>Set.supset_eq" (50)
  logic = logic[51] "⊂" logic[51] => "\<^const>Set.subset" (50)
  logic = logic[51] "⊆" logic[51] => "\<^const>Set.subset_eq" (50)
  logic = logic[26] "⟷" logic[25] => "\<^const>HOL.iff" (25)
  logic = logic[26] "<->" logic[25] => "\<^const>HOL.iff" (25)
  logic = logic[36] "∧" logic[35] => "\<^const>HOL.conj" (35)
  logic = logic[31] "∨" logic[30] => "\<^const>HOL.disj" (30)
  logic = logic[26] "⟶" logic[25] => "\<^const>HOL.implies" (25)
  logic = logic[36] "&" logic[35] => "\<^const>HOL.conj" (35)
  logic = logic[31] "|" logic[30] => "\<^const>HOL.disj" (30)
  logic = logic[26] "-->" logic[25] => "\<^const>HOL.implies" (25)
  logic = logic[4] "∷" type[0] => "_constrain" (3)
  logic = logic[1000] cargs[1000] => "_applC" (999)
  logic = logic[4] "::" type[0] => "_constrain" (3)
  logic = any[81] "powr" any[80] => "\<^const>Transcendental.powr" (80)
  logic = any[70] "/⇩R" logic[71]
    => "\<^const>Real_Vector_Spaces.scaleR_class.divideR" (70)
  logic = any[65] "gchoose" logic[66] => "\<^const>Binomial.gbinomial" (65)
  logic = any[900] "⦇" Record.field_updates[0] "⦈" => "_record_update" (900)
  logic = any[900] "(|" Record.field_updates[0] "|)" => "_record_update" (900)
  logic = any[900] "[" List.lupdbinds[0] "]" => "_LUpdate" (900)
  logic = any[66] "#" logic[65] => "\<^const>List.list.Cons" (65)
  logic = any[70] "mod" any[71] => "\<^const>Divides.div_class.mod" (70)
  logic = any[70] "div" any[71] => "\<^const>Divides.div_class.div" (70)
  logic = any[1000] "⇧2" => "\<^const>Power.power_class.power2" (999)
  logic = any[81] "^" logic[80] => "\<^const>Power.power_class.power" (80)
  logic = any[81] "^^" logic[80] => "\<^const>Nat.compower" (80)
  logic = any[70] "/" any[71] => "\<^const>Fields.inverse_class.divide" (70)
  logic = any[51] "dvd" any[51] => "\<^const>Rings.dvd_class.dvd" (50)
  logic = any[1000] "(" Fun.updbinds[0] ")" => "_Update" (900)
  logic = any[51] "∈" logic[51] => "\<^const>Set.member" (50)
  logic = any[51] "∉" logic[51] => "\<^const>Set.not_member" (50)
  logic = any[51] "~:" logic[51] => "\<^const>Set.not_member" (50)
  logic = any[51] ":" logic[51] => "\<^const>Set.member" (50)
  logic = any[70] "*" any[71] => "\<^const>Groups.times_class.times" (70)
  logic = any[65] "-" any[66] => "\<^const>Groups.minus_class.minus" (65)
  logic = any[65] "+" any[66] => "\<^const>Groups.plus_class.plus" (65)
  logic = any[51] ">" any[51] => "\<^const>Orderings.ord_class.greater" (50)
  logic = any[51] "≥" any[51] => "\<^const>Orderings.ord_class.greater_eq" (50)
  logic = any[51] ">=" any[51] => "\<^const>Orderings.ord_class.greater_eq" (50)
  logic = any[51] "≤" any[51] => "\<^const>Orderings.ord_class.less_eq" (50)
  logic = any[51] "<=" any[51] => "\<^const>Orderings.ord_class.less_eq" (50)
  logic = any[51] "<" any[51] => "\<^const>Orderings.ord_class.less" (50)
  logic = any[50] "≠" any[51] => "\<^const>HOL.not_equal" (50)
  logic = any[50] "~=" any[51] => "\<^const>HOL.not_equal" (50)
  logic = any[50] "=" any[51] => "\<^const>HOL.eq" (50)
  logic = logic[0] ".allInstances()"
    => "\<^const>UML_State.OclAllInstances_at_post" (1000)
  logic = logic[0] ".allInstances@pre()"
    => "\<^const>UML_State.OclAllInstances_at_pre" (1000)
  logic = logic[0] ".oclIsNew()" => "\<^const>UML_State.OclIsNew" (1000)
  logic = logic[0] ".oclIsDeleted()" => "\<^const>UML_State.OclIsDeleted" (1000)
  logic = logic[0] ".oclIsMaintained()" => "\<^const>UML_State.OclIsMaintained"
    (1000)
  logic = logic[0] ".oclIsAbsent()" => "\<^const>UML_State.OclIsAbsent" (1000)
  logic = logic[0] "->oclIsModifiedOnly()"
    => "\<^const>UML_State.OclIsModifiedOnly" (1000)
  logic = logic[0] "@pre" logic[0] => "\<^const>UML_State.OclSelf_at_pre" (1000)
  logic = logic[0] "@post" logic[0] => "\<^const>UML_State.OclSelf_at_post" (1000)
  logic = var_position[-1] (-1)
  logic = longid_position[-1] (-1)
  logic = id_position[-1] (-1)
  longid_position = longid => "_position" (1000)
  num_const = num_position[0] => "_constify" (1000)
  num_position = num_token => "_position" (1000)
  prop = logic[0] => "\<^const>HOL.Trueprop" (5)
  prop = prop'[-1] (-1)
  prop' = "TERM" logic[0] => "\<^const>Pure.term" (1000)
  prop' = "SORT_CONSTRAINT" "(" type[0] ")" => "_sort_constraint" (1000)
  prop' = "OFCLASS" "(" type[0] "," logic[0] ")" => "_ofclass" (1000)
  prop' = "[|" asms[0] "|]" "==>" prop[1] => "_bigimpl" (1)
  prop' = "PROP" aprop[0] => "_aprop" (1000)
  prop' = "(" prop'[0] ")" (1000)
  prop' = "⟦" asms[0] "⟧" "⟹" prop[1] => "_bigimpl" (1)
  prop' = "⋀" idts[0] "." prop[0] => "\<^const>Pure.all_binder" (0)
  prop' = "!!" idts[0] "." prop[0] => "\<^const>Pure.all_binder" (0)
  prop' = any[3] "==" any[3] => "\<^const>Pure.eq" (2)
  prop' = any[3] "≡" any[3] => "\<^const>Pure.eq" (2)
  prop' = prop[2] "==>" prop[1] => "\<^const>Pure.imp" (1)
  prop' = prop[2] "⟹" prop[1] => "\<^const>Pure.imp" (1)
  prop' = prop[3] "&&&" prop[2] => "\<^const>Pure.conjunction" (2)
  prop' = prop[2] "=simp=>" prop[1] => "\<^const>HOL.simp_implies" (1)
  prop' = prop'[4] "::" type[0] => "_constrain" (3)
  prop' = prop'[4] "∷" type[0] => "_constrain" (3)
  pttrn = "(" pttrn[0] "," Product_Type.patterns[0] ")" => "_pattern" (1000)
  pttrn = idt[-1] (-1)
  pttrns = pttrn[1] pttrns[0] => "_pttrns" (0)
  pttrns = pttrn[-1] (-1)
  sort = "{" classes[0] "}" => "_sort" (1000)
  sort = "{}" => "_topsort" (1000)
  sort = class_name[-1] (-1)
  str_position = str_token => "_position" (1000)
  string_position = string_token => "_position" (1000)
  tid_position = tid => "_position_sort" (1000)
  tvar_position = tvar => "_position_sort" (1000)
  type = "_" => "\<^type>dummy" (1000)
  type = "_" "::" sort[0] => "_dummy_ofsort" (1000)
  type = "(" type[0] ")" (1000)
  type = "(" type[0] "," types[0] ")" type_name[0] => "_tappl" (1000)
  type = "[" types[0] "]" "=>" type[0] => "_bracket" (0)
  type = "[" types[0] "]" "⇒" type[0] => "_bracket" (0)
  type = tvar_position[1000] "::" sort[0] => "_ofsort" (1000)
  type = tid_position[1000] "::" sort[0] => "_ofsort" (1000)
  type = tid_position[1000] "∷" sort[0] => "_ofsort" (1000)
  type = "(|" Record.field_types[0] "," "..." "::" type[0] "|)"
    => "_record_type_scheme" (1000)
  type = "(|" Record.field_types[0] "|)" => "_record_type" (1000)
  type = "⦇" Record.field_types[0] "," "…" "::" type[0] "⦈"
    => "_record_type_scheme" (1000)
  type = "⦇" Record.field_types[0] "⦈" => "_record_type" (1000)
  type = "⟨" type[0] "⟩⇩⊥" => "\<^type>Option.option" (1000)
  type = "Pair(" type[0] "," type[0] ")" => "\<^type>UML_Types.Pair⇩b⇩a⇩s⇩e" (1000)
  type = "Set(" type[0] ")" => "\<^type>UML_Types.Set⇩b⇩a⇩s⇩e" (1000)
  type = "Bag(" type[0] ")" => "\<^type>UML_Types.Bag⇩b⇩a⇩s⇩e" (1000)
  type = "Sequence(" type[0] ")" => "\<^type>UML_Types.Sequence⇩b⇩a⇩s⇩e" (1000)
  type = type[1] "⇀" type[0] => "\<^type>Map.map" (0)
  type = type[1] "~=>" type[0] => "\<^type>Map.map" (0)
  type = type[11] "+" type[10] => "\<^type>Sum_Type.sum" (10)
  type = type[21] "×" type[20] => "\<^type>Product_Type.prod" (20)
  type = type[21] "*" type[20] => "\<^type>Product_Type.prod" (20)
  type = type[1] "⇒" type[0] => "\<^type>fun" (0)
  type = type[1000] type_name[0] => "_tapp" (1000)
  type = type[1] "=>" type[0] => "\<^type>fun" (0)
  type = type_name[-1] (-1)
  type = tvar_position[-1] (-1)
  type = tid_position[-1] (-1)
  type_name = longid => "_type_name" (1000)
  type_name = id => "_type_name" (1000)
  types = type[0] "," types[0] => "_types" (1000)
  types = type[-1] (-1)
  var_position = var => "_position" (1000)
print modes: "HOL" "HTML" "epsilon" "iff" "input" "latex" "latex_prod" "latex_sum"
  "xsymbols"
consts: "OclNonValid" "\<^const>Filter.Alm_all_binder"
  "\<^const>Filter.Inf_many_binder" "\<^const>HOL.All_binder"
  "\<^const>HOL.Ex1_binder" "\<^const>HOL.Ex_binder"
  "\<^const>Hilbert_Choice.Greatest_binder"
  "\<^const>Orderings.ord_class.Least_binder" "\<^const>Pure.all_binder"
  "\<^const>Series.suminf_binder" "_All_greater" "_All_greater_eq" "_All_less"
  "_All_less_eq" "_Ball" "_Bex" "_Bex1" "_Bleast" "_Char" "_Coll" "_Collect"
  "_Csum" "_DDDOT" "_Eps" "_Ex_greater" "_Ex_greater_eq" "_Ex_less" "_Ex_less_eq"
  "_Finset" "_Float" "_GreatestM" "_INF" "_INF1" "_INTER" "_INTER1" "_INTER_le"
  "_INTER_less" "_LIM" "_LUpdate" "_LeastM" "_Let" "_Map" "_MapUpd" "_Maplets"
  "_Numeral" "_OclCollectSeq" "_OclExistBag" "_OclExistSeq" "_OclExistSet"
  "_OclFinbag" "_OclFinsequence" "_OclFinset" "_OclForallBag" "_OclForallSeq"
  "_OclForallSet" "_OclIterateBag" "_OclIterateSeq" "_OclIterateSet"
  "_OclRejectBag" "_OclRejectSet" "_OclSelectBag" "_OclSelectSeq" "_OclSelectSet"
  "_SUP" "_SUP1" "_Setcompr" "_Sigma" "_String" "_TYPE" "_TYPEREP" "_The" "_UNION"
  "_UNION1" "_UNION_le" "_UNION_less" "_Update" "_abs" "_applC" "_aprop" "_args"
  "_asm" "_asms" "_bigimpl" "_bind" "_binds" "_bound" "_bracket" "_cargs"
  "_cartouche_oclstring" "_case1" "_case2" "_case_syntax" "_class_name" "_classes"
  "_constify" "_constrain" "_constrainAbs" "_context_const" "_context_xconst"
  "_dummy_ofsort" "_eventually" "_field" "_field_type" "_field_types"
  "_field_update" "_field_updates" "_fields" "_filter" "_free" "_frequently"
  "_from_to_setprod" "_from_to_setsum" "_from_upto_setprod" "_from_upto_setsum"
  "_idtdummy" "_idts" "_idtyp" "_idtypdummy" "_ignore_type" "_index"
  "_indexdefault" "_indexvar" "_inner_string" "_lam_pats_syntax" "_lambda"
  "_lc_abs" "_lc_end" "_lc_gen" "_lc_quals" "_lc_test" "_list" "_listcompr"
  "_listprod" "_listsum" "_loose" "_lupdbind" "_lupdbinds" "_maplet" "_maplets"
  "_mk_ofclass" "_numeral" "_ocl_denotation" "_ofclass" "_ofsort" "_pattern"
  "_patterns" "_position" "_position_sort" "_pttrns" "_qsetprod" "_qsetsum"
  "_record" "_record_scheme" "_record_type" "_record_type_scheme" "_record_update"
  "_setleAll" "_setleEx" "_setleEx1" "_setlessAll" "_setlessEx" "_setprod"
  "_setsum" "_sort" "_sort_constraint" "_strip_positions" "_struct" "_tapp"
  "_tappl" "_tfree" "_topsort" "_tuple" "_tuple_arg" "_tuple_args" "_tvar"
  "_type_constraint_" "_type_name" "_type_prop" "_types" "_update_name" "_updbind"
  "_updbinds" "_upt_setprod" "_upt_setsum" "_upto_setprod" "_upto_setsum" "_var"
  "notequal"
parse_ast_translation: "_Char" "_String" "_appl" "_applC" "_bigimpl" "_bracket"
  "_constify" "_context_const" "_context_xconst" "_idtyp" "_indexdefault"
  "_indexvar" "_lambda" "_strip_positions" "_struct" "_tapp" "_tappl"
parse_rules:
    ("_Bex" x A P)  ->  ("\<^const>Set.Bex" A ("_abs" x P))
    ("_Eps" x P)  ->  ("\<^const>Hilbert_Choice.Eps" ("_abs" x P))
    ("_INF" x A B)  ->
      ("\<^const>Complete_Lattices.Inf_class.INFIMUM" A ("_abs" x B))
    ("_LIM" x F1 f F2)  ->  ("\<^const>Filter.filterlim" ("_abs" x f) F2 F1)
    ("_Let" ("_binds" b bs) e)  ->  ("_Let" b ("_Let" bs e))
    ("_Let" ("_bind" x a) e)  ->  ("\<^const>HOL.Let" a ("_abs" x e))
    ("_Map" ms)  ->  ("_MapUpd" "\<^const>Map.empty" ms)
    ("_SUP" x A B)  ->
      ("\<^const>Complete_Lattices.Sup_class.SUPREMUM" A ("_abs" x B))
    ("_The" x P)  ->  ("\<^const>HOL.The" ("_abs" x P))
    ("_abs" ("_pattern" x ("_patterns" y zs)) b)  ->
      ("\<^const>Product_Type.prod.case_prod"
        ("_abs" x ("_abs" ("_pattern" y zs) b)))
    ("_abs" ("_pattern" x y) b)  ->
      ("\<^const>Product_Type.prod.case_prod" ("_abs" x ("_abs" y b)))
    ("_abs" ("\<^const>Product_Type.Pair" x y) t)  ->  ("_abs" ("_pattern" x y) t)
    ("_Ball" x A P)  ->  ("\<^const>Set.Ball" A ("_abs" x P))
    ("_Bex1" x A P)  ->
      ("\<^const>HOL.Ex1_binder" x
        ("\<^const>HOL.conj" ("\<^const>Set.member" x A) P))
    ("_Coll" x P)  ->  ("\<^const>Set.Collect" ("_abs" x P))
    ("_Csum" i r rs)  ->  ("\<^const>BNF_Cardinal_Arithmetic.Csum" r ("_abs" i rs))
    ("_INF1" ("_pttrns" x y) B)  ->  ("_INF1" x ("_INF1" y B))
    ("_INF1" x B)  ->
      ("\<^const>Complete_Lattices.Inf_class.INFIMUM" "\<^const>Set.UNIV"
        ("_abs" x B))
    ("_INF1" x B)  ->  ("_INF" x "\<^const>Set.UNIV" B)
    ("_SUP1" ("_pttrns" x y) B)  ->  ("_SUP1" x ("_SUP1" y B))
    ("_SUP1" x B)  ->
      ("\<^const>Complete_Lattices.Sup_class.SUPREMUM" "\<^const>Set.UNIV"
        ("_abs" x B))
    ("_SUP1" x B)  ->  ("_SUP" x "\<^const>Set.UNIV" B)
    ("_list" ("_args" x xs))  ->  ("\<^const>List.list.Cons" x ("_list" xs))
    ("_list" x)  ->  ("\<^const>List.list.Cons" x "\<^const>List.list.Nil")
    ("_INTER" x A B)  ->  ("\<^const>Complete_Lattices.INTER" A ("_abs" x B))
    ("_Sigma" x A B)  ->  ("\<^const>Product_Type.Sigma" A ("_abs" x B))
    ("_UNION" x A B)  ->  ("\<^const>Complete_Lattices.UNION" A ("_abs" x B))
    ("_tuple" x ("_tuple_arg" y))  ->  ("\<^const>Product_Type.Pair" x y)
    ("_tuple" x ("_tuple_args" y z))  ->
      ("_tuple" x ("_tuple_arg" ("_tuple" y z)))
    ("_Bleast" x A P)  ->
      ("\<^const>Orderings.ord_class.Least_binder" x
        ("\<^const>HOL.conj" ("\<^const>Set.member" x A) P))
    ("_Finset" ("_args" x xs))  ->  ("\<^const>Set.insert" x ("_Finset" xs))
    ("_Finset" x)  ->  ("\<^const>Set.insert" x "\<^const>Set.empty")
    ("_INTER1" ("_pttrns" x y) B)  ->  ("_INTER1" x ("_INTER1" y B))
    ("_INTER1" x B)  ->
      ("\<^const>Complete_Lattices.INTER" "\<^const>Set.UNIV" ("_abs" x B))
    ("_INTER1" x B)  ->  ("_INTER" x "\<^const>Set.UNIV" B)
    ("_LeastM" x m P)  ->  ("\<^const>Hilbert_Choice.LeastM" m ("_abs" x P))
    ("_MapUpd" m ("_maplets" x y))  ->  ("\<^const>Map.map_upds" m x y)
    ("_MapUpd" m ("_Maplets" xy ms))  ->  ("_MapUpd" ("_MapUpd" m xy) ms)
    ("_MapUpd" m ("_maplet" x y))  ->
      ("_Update" m ("_updbind" x ("\<^const>Option.option.Some" y)))
    ("_UNION1" ("_pttrns" x y) B)  ->  ("_UNION1" x ("_UNION1" y B))
    ("_UNION1" x B)  ->
      ("\<^const>Complete_Lattices.UNION" "\<^const>Set.UNIV" ("_abs" x B))
    ("_UNION1" x B)  ->  ("_UNION" x "\<^const>Set.UNIV" B)
    ("_Update" f ("_updbinds" b bs))  ->  ("_Update" ("_Update" f b) bs)
    ("_Update" f ("_updbind" x y))  ->  ("\<^const>Fun.fun_upd" f x y)
    ("_filter" x xs P)  ->  ("\<^const>List.filter" ("_abs" x P) xs)
    ("_setsum" i A b)  ->
      ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" i b) A)
    ("_Collect" p A P)  ->
      ("\<^const>Set.Collect"
        ("_abs" p ("\<^const>HOL.conj" ("\<^const>Set.member" p A) P)))
    ("_Ex_less" x y P)  ->
      ("\<^const>HOL.Ex_binder" x
        ("\<^const>HOL.conj" ("\<^const>Orderings.ord_class.less" x y) P))
    ("_LUpdate" xs ("_lupdbinds" b bs))  ->  ("_LUpdate" ("_LUpdate" xs b) bs)
    ("_LUpdate" xs ("_lupdbind" i x))  ->  ("\<^const>List.list_update" xs i x)
    ("_listsum" x xs b)  ->
      ("\<^const>Groups_List.monoid_add_class.listsum"
        ("\<^const>List.list.map" ("_abs" x b) xs))
    ("_pattern" x y)  ->  ("\<^const>Product_Type.Pair" x y)
    ("_qsetsum" x P t)  ->
      ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" x t)
        ("_Coll" x P))
    ("_setleEx" A B P)  ->
      ("\<^const>HOL.Ex_binder" A
        ("\<^const>HOL.conj" ("\<^const>Set.subset_eq" A B) P))
    ("_setprod" i A b)  ->
      ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" i b) A)
    ("notequal" a b)  ->
      ("\<^const>UML_Logic.OclNot" ("\<^const>UML_Logic.StrictRefEq" a b))
    ("_All_less" x y P)  ->
      ("\<^const>HOL.All_binder" x
        ("\<^const>HOL.implies" ("\<^const>Orderings.ord_class.less" x y) P))
    ("_INTER_le" i n A)  ->
      ("_INTER" i ("\<^const>Set_Interval.ord_class.atMost" n) A)
    ("_UNION_le" i n A)  ->
      ("_UNION" i ("\<^const>Set_Interval.ord_class.atMost" n) A)
    ("_listprod" x xs b)  ->
      ("\<^const>Groups_List.monoid_mult_class.listprod"
        ("\<^const>List.list.map" ("_abs" x b) xs))
    ("_patterns" x y)  ->  ("\<^const>Product_Type.Pair" x y)
    ("_qsetprod" x P t)  ->
      ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" x t)
        ("_Coll" x P))
    ("_setleAll" A B P)  ->
      ("\<^const>HOL.All_binder" A
        ("\<^const>HOL.implies" ("\<^const>Set.subset_eq" A B) P))
    ("_setleEx1" A B P)  ->
      ("\<^const>HOL.Ex1_binder" A
        ("\<^const>HOL.conj" ("\<^const>Set.subset_eq" A B) P))
    ("_GreatestM" x m P)  ->  ("\<^const>Hilbert_Choice.GreatestM" m ("_abs" x P))
    ("_OclFinbag" ("_args" x xs))  ->
      ("\<^const>UML_Bag.OclIncluding" ("_OclFinbag" xs) x)
    ("_OclFinbag" x)  ->
      ("\<^const>UML_Bag.OclIncluding" "\<^const>UML_Bag.mtBag" x)
    ("_OclFinset" ("_args" x xs))  ->
      ("\<^const>UML_Set.OclIncluding" ("_OclFinset" xs) x)
    ("_OclFinset" x)  ->
      ("\<^const>UML_Set.OclIncluding" "\<^const>UML_Set.mtSet" x)
    ("_setlessEx" A B P)  ->
      ("\<^const>HOL.Ex_binder" A
        ("\<^const>HOL.conj" ("\<^const>Set.subset" A B) P))
    ("OclNonValid" τ P)  ->
      ("\<^const>HOL.Not" ("\<^const>UML_Logic.OclValid" τ P))
    ("_Ex_greater" x y P)  ->
      ("\<^const>HOL.Ex_binder" x
        ("\<^const>HOL.conj" ("\<^const>Orderings.ord_class.greater" x y) P))
    ("_Ex_less_eq" x y P)  ->
      ("\<^const>HOL.Ex_binder" x
        ("\<^const>HOL.conj" ("\<^const>Orderings.ord_class.less_eq" x y) P))
    ("_INTER_less" i n A)  ->
      ("_INTER" i ("\<^const>Set_Interval.ord_class.lessThan" n) A)
    ("_UNION_less" i n A)  ->
      ("_UNION" i ("\<^const>Set_Interval.ord_class.lessThan" n) A)
    ("_eventually" x F P)  ->  ("\<^const>Filter.eventually" ("_abs" x P) F)
    ("_frequently" x F P)  ->  ("\<^const>Filter.frequently" ("_abs" x P) F)
    ("_setlessAll" A B P)  ->
      ("\<^const>HOL.All_binder" A
        ("\<^const>HOL.implies" ("\<^const>Set.subset" A B) P))
    ("_upt_setsum" i n t)  ->
      ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" i t)
        ("\<^const>Set_Interval.ord_class.lessThan" n))
    ("_All_greater" x y P)  ->
      ("\<^const>HOL.All_binder" x
        ("\<^const>HOL.implies" ("\<^const>Orderings.ord_class.greater" x y) P))
    ("_All_less_eq" x y P)  ->
      ("\<^const>HOL.All_binder" x
        ("\<^const>HOL.implies" ("\<^const>Orderings.ord_class.less_eq" x y) P))
    ("_OclExistBag" X x P)  ->  ("\<^const>UML_Bag.OclExists" X ("_abs" x P))
    ("_OclExistSeq" X x P)  ->  ("\<^const>UML_Sequence.OclExists" X ("_abs" x P))
    ("_OclExistSet" X x P)  ->  ("\<^const>UML_Set.OclExists" X ("_abs" x P))
    ("_upt_setprod" i n t)  ->
      ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" i t)
        ("\<^const>Set_Interval.ord_class.lessThan" n))
    ("_upto_setsum" i n t)  ->
      ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" i t)
        ("\<^const>Set_Interval.ord_class.atMost" n))
    ("_OclForallBag" X x P)  ->  ("\<^const>UML_Bag.OclForall" X ("_abs" x P))
    ("_OclForallSeq" X x P)  ->  ("\<^const>UML_Sequence.OclForall" X ("_abs" x P))
    ("_OclForallSet" X x P)  ->  ("\<^const>UML_Set.OclForall" X ("_abs" x P))
    ("_OclRejectBag" X x P)  ->  ("\<^const>UML_Bag.OclReject" X ("_abs" x P))
    ("_OclRejectSet" X x P)  ->  ("\<^const>UML_Set.OclReject" X ("_abs" x P))
    ("_OclSelectBag" X x P)  ->  ("\<^const>UML_Bag.OclSelect" X ("_abs" x P))
    ("_OclSelectSeq" X x P)  ->  ("\<^const>UML_Sequence.OclSelect" X ("_abs" x P))
    ("_OclSelectSet" X x P)  ->  ("\<^const>UML_Set.OclSelect" X ("_abs" x P))
    ("_upto_setprod" i n t)  ->
      ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" i t)
        ("\<^const>Set_Interval.ord_class.atMost" n))
    ("_Ex_greater_eq" x y P)  ->
      ("\<^const>HOL.Ex_binder" x
        ("\<^const>HOL.conj" ("\<^const>Orderings.ord_class.greater_eq" x y) P))
    ("_OclCollectSeq" X x P)  ->
      ("\<^const>UML_Sequence.OclCollect" X ("_abs" x P))
    ("_OclIterateBag" X a x A P)  ->
      ("\<^const>UML_Bag.OclIterate" X A ("_abs" a ("_abs" x P)))
    ("_OclIterateSeq" X a x A P)  ->
      ("\<^const>UML_Sequence.OclIterate" X A ("_abs" a ("_abs" x P)))
    ("_OclIterateSet" X a x A P)  ->
      ("\<^const>UML_Set.OclIterate" X A ("_abs" a ("_abs" x P)))
    ("_All_greater_eq" x y P)  ->
      ("\<^const>HOL.All_binder" x
        ("\<^const>HOL.implies" ("\<^const>Orderings.ord_class.greater_eq" x y) P))
    ("_OclFinsequence" ("_args" x xs))  ->
      ("\<^const>UML_Sequence.OclPrepend" ("_OclFinsequence" xs) x)
    ("_OclFinsequence" x)  ->
      ("\<^const>UML_Sequence.OclPrepend" "\<^const>UML_Sequence.mtSequence" x)
    ("_from_to_setsum" x a b t)  ->
      ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" x t)
        ("\<^const>Set_Interval.ord_class.atLeastAtMost" a b))
    ("_from_to_setprod" x a b t)  ->
      ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" x t)
        ("\<^const>Set_Interval.ord_class.atLeastAtMost" a b))
    ("_from_upto_setsum" x a b t)  ->
      ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" x t)
        ("\<^const>Set_Interval.ord_class.atLeastLessThan" a b))
    ("_from_upto_setprod" x a b t)  ->
      ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" x t)
        ("\<^const>Set_Interval.ord_class.atLeastLessThan" a b))
parse_translation: "\<^const>Filter.Alm_all_binder"
  "\<^const>Filter.Inf_many_binder" "\<^const>HOL.All_binder"
  "\<^const>HOL.Ex1_binder" "\<^const>HOL.Ex_binder"
  "\<^const>Hilbert_Choice.Greatest_binder"
  "\<^const>Orderings.ord_class.Least_binder" "\<^const>Pure.all_binder"
  "\<^const>Series.suminf_binder" "_DDDOT" "_Float" "_Numeral" "_Setcompr" "_TYPE"
  "_TYPEREP" "_abs" "_aprop" "_cartouche_oclstring" "_case_syntax" "_index"
  "_lam_pats_syntax" "_listcompr" "_ofclass" "_record" "_record_scheme"
  "_record_type" "_record_type_scheme" "_record_update" "_sort_constraint"
  "_struct" "_update_name"
print_translation: "\<^const>Complete_Lattices.INTER"
  "\<^const>Complete_Lattices.Inf_class.INFIMUM"
  "\<^const>Complete_Lattices.Sup_class.SUPREMUM"
  "\<^const>Complete_Lattices.UNION" "\<^const>Ctr_Sugar.case_guard"
  "\<^const>Filter.Alm_all" "\<^const>Filter.Inf_many"
  "\<^const>Groups.one_class.one" "\<^const>Groups.zero_class.zero"
  "\<^const>Groups_Big.comm_monoid_add_class.setsum" "\<^const>HOL.All"
  "\<^const>HOL.All_binder" "\<^const>HOL.Ex" "\<^const>HOL.Ex1"
  "\<^const>HOL.Ex_binder" "\<^const>HOL.The" "\<^const>Hilbert_Choice.Eps"
  "\<^const>Hilbert_Choice.Greatest" "\<^const>Num.numeral_class.numeral"
  "\<^const>Orderings.ord_class.Least" "\<^const>Product_Type.prod.case_prod"
  "\<^const>Pure.all" "\<^const>Pure.type" "\<^const>Series.suminf"
  "\<^const>Set.Ball" "\<^const>Set.Bex" "\<^const>Set.Collect"
  "\<^const>Typerep.typerep_class.typerep" "\<^const>UML_Types.state.assocs_update"
  "\<^const>UML_Types.state.heap_update" "\<^const>UML_Types.state.more_update"
  "\<^const>UML_Types.state.state_ext" "\<^type>UML_Types.state.state_ext"
  "_type_constraint_" "_type_prop"
print_rules:
    ("_INF" x "\<^const>Set.UNIV" B)  ->  ("_INF1" x B)
    ("_Let" b ("_Let" bs e))  ->  ("_Let" ("_binds" b bs) e)
    ("_SUP" x "\<^const>Set.UNIV" B)  ->  ("_SUP1" x B)
    ("_INF1" x ("_INF1" y B))  ->  ("_INF1" ("_pttrns" x y) B)
    ("_SUP1" x ("_SUP1" y B))  ->  ("_SUP1" ("_pttrns" x y) B)
    ("_INTER" i ("\<^const>Set_Interval.ord_class.atMost" n) A)  ->
      ("_INTER_le" i n A)
    ("_INTER" i ("\<^const>Set_Interval.ord_class.lessThan" n) A)  ->
      ("_INTER_less" i n A)
    ("_INTER" x "\<^const>Set.UNIV" B)  ->  ("_INTER1" x B)
    ("_UNION" i ("\<^const>Set_Interval.ord_class.atMost" n) A)  ->
      ("_UNION_le" i n A)
    ("_UNION" i ("\<^const>Set_Interval.ord_class.lessThan" n) A)  ->
      ("_UNION_less" i n A)
    ("_UNION" x "\<^const>Set.UNIV" B)  ->  ("_UNION1" x B)
    ("_tuple" x ("_tuple_arg" ("_tuple" y z)))  ->
      ("_tuple" x ("_tuple_args" y z))
    ("_INTER1" x ("_INTER1" y B))  ->  ("_INTER1" ("_pttrns" x y) B)
    ("_MapUpd" ("_MapUpd" m xy) ms)  ->  ("_MapUpd" m ("_Maplets" xy ms))
    ("_MapUpd" "\<^const>Map.empty" ms)  ->  ("_Map" ms)
    ("_MapUpd" ("_Map" ms1) ms2)  ->  ("_Map" ("_Maplets" ms1 ms2))
    ("_UNION1" x ("_UNION1" y B))  ->  ("_UNION1" ("_pttrns" x y) B)
    ("_Update" m ("_updbind" x ("\<^const>Option.option.Some" y)))  ->
      ("_MapUpd" m ("_maplet" x y))
    ("_Update" ("_Update" f b) bs)  ->  ("_Update" f ("_updbinds" b bs))
    ("_LUpdate" ("_LUpdate" xs b) bs)  ->  ("_LUpdate" xs ("_lupdbinds" b bs))
    ("_Maplets" ("_Maplets" ms1 ms2) ms3)  ->
      ("_Maplets" ms1 ("_Maplets" ms2 ms3))
    ("\<^const>HOL.Let" a ("_abs" x e))  ->  ("_Let" ("_bind" x a) e)
    ("\<^const>HOL.Not" ("\<^const>UML_Logic.OclValid" τ P))  ->
      ("OclNonValid" τ P)
    ("\<^const>HOL.The" ("_abs" x P))  ->  ("_The" x P)
    ("\<^const>Set.Bex" A ("_abs" x P))  ->  ("_Bex" x A P)
    ("\<^const>Set.Ball" A ("_abs" x P))  ->  ("_Ball" x A P)
    ("\<^const>Set.insert" x ("_Finset" xs))  ->  ("_Finset" ("_args" x xs))
    ("\<^const>Set.insert" x "\<^const>Set.empty")  ->  ("_Finset" x)
    ("\<^const>Fun.fun_upd" f x y)  ->  ("_Update" f ("_updbind" x y))
    ("\<^const>List.filter" ("_abs" x P) xs)  ->  ("_filter" x xs P)
    ("\<^const>Set.Collect" ("_abs" x P))  ->  ("_Coll" x P)
    ("\<^const>Map.map_upds" m x y)  ->  ("_MapUpd" m ("_maplets" x y))
    ("\<^const>HOL.not_equal" ("\<^const>Set.range" f) "\<^const>Set.UNIV")  ->
      ("\<^const>HOL.Not" ("\<^const>Fun.surj" f))
    ("\<^const>List.list.Cons" x ("_list" xs))  ->  ("_list" ("_args" x xs))
    ("\<^const>List.list.Cons" x "\<^const>List.list.Nil")  ->  ("_list" x)
    ("\<^const>Filter.filterlim" ("_abs" x f) F2 F1)  ->  ("_LIM" x F1 f F2)
    ("\<^const>List.list_update" xs i x)  ->  ("_LUpdate" xs ("_lupdbind" i x))
    ("\<^const>UML_Logic.OclNot" ("\<^const>UML_Logic.StrictRefEq" a b))  ->
      ("notequal" a b)
    ("\<^const>Filter.eventually" ("_abs" x P) F)  ->  ("_eventually" x F P)
    ("\<^const>Filter.frequently" ("_abs" x P) F)  ->  ("_frequently" x F P)
    ("\<^const>Product_Type.Pair" x y)  ->  ("_tuple" x ("_tuple_arg" y))
    ("\<^const>UML_Bag.OclExists" X ("_abs" x P))  ->  ("_OclExistBag" X x P)
    ("\<^const>UML_Bag.OclForall" X ("_abs" x P))  ->  ("_OclForallBag" X x P)
    ("\<^const>UML_Bag.OclReject" X ("_abs" x P))  ->  ("_OclRejectBag" X x P)
    ("\<^const>UML_Bag.OclSelect" X ("_abs" x P))  ->  ("_OclSelectBag" X x P)
    ("\<^const>UML_Set.OclExists" X ("_abs" x P))  ->  ("_OclExistSet" X x P)
    ("\<^const>UML_Set.OclForall" X ("_abs" x P))  ->  ("_OclForallSet" X x P)
    ("\<^const>UML_Set.OclReject" X ("_abs" x P))  ->  ("_OclRejectSet" X x P)
    ("\<^const>UML_Set.OclSelect" X ("_abs" x P))  ->  ("_OclSelectSet" X x P)
    ("\<^const>Hilbert_Choice.Eps" ("_abs" x P))  ->  ("_Eps" x P)
    ("\<^const>Product_Type.Sigma" A ("_abs" x B))  ->  ("_Sigma" x A B)
    ("\<^const>UML_Bag.OclIterate" X A ("_abs" a ("_abs" x P)))  ->
      ("_OclIterateBag" X a x A P)
    ("\<^const>UML_Set.OclIterate" X A ("_abs" a ("_abs" x P)))  ->
      ("_OclIterateSet" X a x A P)
    ("\<^const>UML_Bag.OclIncluding" ("_OclFinbag" xs) x)  ->
      ("_OclFinbag" ("_args" x xs))
    ("\<^const>UML_Bag.OclIncluding" "\<^const>UML_Bag.mtBag" x)  ->
      ("_OclFinbag" x)
    ("\<^const>UML_Set.OclIncluding" ("_OclFinset" xs) x)  ->
      ("_OclFinset" ("_args" x xs))
    ("\<^const>UML_Set.OclIncluding" "\<^const>UML_Set.mtSet" x)  ->
      ("_OclFinset" x)
    ("\<^const>Hilbert_Choice.LeastM" m ("_abs" x P))  ->  ("_LeastM" x m P)
    ("\<^const>UML_Sequence.OclExists" X ("_abs" x P))  ->  ("_OclExistSeq" X x P)
    ("\<^const>UML_Sequence.OclForall" X ("_abs" x P))  ->  ("_OclForallSeq" X x P)
    ("\<^const>UML_Sequence.OclSelect" X ("_abs" x P))  ->  ("_OclSelectSeq" X x P)
    ("\<^const>Complete_Lattices.INTER" "\<^const>Set.UNIV" ("_abs" x B))  ->
      ("_INTER1" x B)
    ("\<^const>Complete_Lattices.INTER" A ("_abs" x B))  ->  ("_INTER" x A B)
    ("\<^const>Complete_Lattices.UNION" "\<^const>Set.UNIV" ("_abs" x B))  ->
      ("_UNION1" x B)
    ("\<^const>Complete_Lattices.UNION" A ("_abs" x B))  ->  ("_UNION" x A B)
    ("\<^const>UML_Sequence.OclCollect" X ("_abs" x P))  ->
      ("_OclCollectSeq" X x P)
    ("\<^const>UML_Sequence.OclIterate" X A ("_abs" a ("_abs" x P)))  ->
      ("_OclIterateSeq" X a x A P)
    ("\<^const>UML_Sequence.OclPrepend" ("_OclFinsequence" xs) x)  ->
      ("_OclFinsequence" ("_args" x xs))
    ("\<^const>UML_Sequence.OclPrepend" "\<^const>UML_Sequence.mtSequence" x)  ->
      ("_OclFinsequence" x)
    ("\<^const>Hilbert_Choice.GreatestM" m ("_abs" x P))  ->  ("_GreatestM" x m P)
    ("\<^const>Product_Type.prod.case_prod"
      ("_abs" x ("_abs" ("_pattern" y zs) b)))  ->
      ("_abs" ("_pattern" x ("_patterns" y zs)) b)
    ("\<^const>Product_Type.prod.case_prod" ("_abs" x ("_abs" y b)))  ->
      ("_abs" ("_pattern" x y) b)
    ("\<^const>BNF_Cardinal_Arithmetic.Csum" r ("_abs" i rs))  ->  ("_Csum" i r rs)
    ("\<^const>Complete_Lattices.Inf_class.INFIMUM" "\<^const>Set.UNIV"
      ("_abs" x B))  ->
      ("_INF1" x B)
    ("\<^const>Complete_Lattices.Inf_class.INFIMUM" A ("_abs" x B))  ->
      ("_INF" x A B)
    ("\<^const>Complete_Lattices.Sup_class.SUPREMUM" "\<^const>Set.UNIV"
      ("_abs" x B))  ->
      ("_SUP1" x B)
    ("\<^const>Complete_Lattices.Sup_class.SUPREMUM" A ("_abs" x B))  ->
      ("_SUP" x A B)
    ("\<^const>Groups_List.monoid_add_class.listsum"
      ("\<^const>List.list.map" ("_abs" x b) xs))  ->
      ("_listsum" x xs b)
    ("\<^const>Groups_List.monoid_mult_class.listprod"
      ("\<^const>List.list.map" ("_abs" x b) xs))  ->
      ("_listprod" x xs b)
    ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" x t)
      ("\<^const>Set_Interval.ord_class.atLeastAtMost" a b))  ->
      ("_from_to_setsum" x a b t)
    ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" x t)
      ("\<^const>Set_Interval.ord_class.atLeastLessThan" a b))  ->
      ("_from_upto_setsum" x a b t)
    ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" i t)
      ("\<^const>Set_Interval.ord_class.atMost" n))  ->
      ("_upto_setsum" i n t)
    ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" i t)
      ("\<^const>Set_Interval.ord_class.lessThan" n))  ->
      ("_upt_setsum" i n t)
    ("\<^const>Groups_Big.comm_monoid_add_class.setsum" ("_abs" i b) A)  ->
      ("_setsum" i A b)
    ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" x t)
      ("\<^const>Set_Interval.ord_class.atLeastAtMost" a b))  ->
      ("_from_to_setprod" x a b t)
    ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" x t)
      ("\<^const>Set_Interval.ord_class.atLeastLessThan" a b))  ->
      ("_from_upto_setprod" x a b t)
    ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" i t)
      ("\<^const>Set_Interval.ord_class.atMost" n))  ->
      ("_upto_setprod" i n t)
    ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" i t)
      ("\<^const>Set_Interval.ord_class.lessThan" n))  ->
      ("_upt_setprod" i n t)
    ("\<^const>Groups_Big.comm_monoid_mult_class.setprod" ("_abs" i b) A)  ->
      ("_setprod" i A b)
print_ast_translation: "\<^const>Pure.imp" "\<^const>String.char.Char"
  "\<^type>fun" "_abs" "_idts" "_index" "_list" "_pttrns" "_struct"