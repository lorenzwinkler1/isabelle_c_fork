\part{A Formal Semantics of OCL 2.3 in Isabelle/HOL}

\section{Object-oriented Data Structures}%
Now we turn to several families of operations that the user implicitly defines
when stating a class model as logical context of a specification. This is the
part of the language where object-oriented features such as type casts, accessor
functions, and tests for dynamic types come into play. Syntactically, a class
model provides a collection of classes ($C_1$, \ldots, $C_n$),
an inheritance relation $\_ < \_$ on
classes and a collection of attributes $A_{C_i}$ associated to classes.  Semantically,
a class model means a collection of accessor functions (denoted $\_\text{.a}::C_i
\rightarrow B$ and $\getAttrib{\_}{a\isasymOclATpre}::C_i \rightarrow B$ for
$\text{a}\in A_{C_i}$ and $B\in \{\V{}{\up{\ldots}}, C_1, \ldots, C_n\}$),
type casts that can change the static type of an object of a class
(denoted $\typeCast{\_}{\text{$C_i$}}$ of type $C_j \rightarrow C_i$) and
two dynamic type tests
(denoted $\isType{\text{$C_i$}}{\_}$ and $\isKind{\text{$C_i$}}{\_}$ ).
A precise formal definition can be found in~\cite{brucker.ea:semantics:2009}.

\subsection{Class models: A simplified semantics.}
In this section, we will have to clarify the notions of \emph{object
  identifiers}, \emph{object representations}, \emph{class types} and
\emph{state}. We will give a formal model for this, that will satisfy all
properties discussed in the subsequent section except one
(see~\cite{brucker.ea:extensible:2008-b} for the complete model).

First, object identifiers are captured by an abstract type $\oid$ comprising
countably many elements and a special element $\nullid$.
%
Second, object representations model ``a piece of typed memory,'' \ie, a kind of
record comprising administration information and the information for all
attributes of an object; here, the primitive types as well as collections over
them are stored directly in the object representations, class types and
collections over them are represented by $\oid$'s (respectively lifted
collections over them).
%
Third, the class type $C$ will be the type of such an object representation: $C
\defeq (\oid \times \Tag{C} \times A_1 \times \cdots \times A_k )$ where a
unique tag-type $\Tag{C}$ (ensuring type-safety) is created for each class type,
where the types $A_1$, \ldots, $A_k$ are the attribute types (including
inherited attributes) with class types substituted by $\oid$. The function
$\HolOclOidOf$ projects the first component, the $\oid$, out of an object
representation.
%
Fourth,
for a  class model $M$ with the classes $C_1$, \ldots, $C_n$, we
define states as partial functions from $\oid$'s to object representations
satisfying a \emph{state invariant} $\inv_\sigma$:
\begin{gather*}
  \state{} \defeq \{ f :: \oid \isasymrightharpoonup (C_1 + \ldots +
  C_n) \ap|\ap \inv_\sigma(f) \}
\end{gather*}
where $\inv_\sigma(f)$ states two conditions:
\begin{enumerate}
\item there is no object representation for $\nullid$: $\nullid \notin (\dom\ap f)$.
\item there is a``one-to-one'' correspondence between object representations and
  $\oid$'s: $\forall \mathit{oid} \in \dom\ap f\spot oid = \HolOclOidOf\ap
  \drop{f(\mathit{oid})}$.
\end{enumerate}
The latter condition is also mentioned in~\cite[Annex A]{omg:ocl:2003} and
goes back to Mark Richters~\cite{richters:precise:2002}.

\section{The Accessors}
On states built over object universes, we can now define accessors, casts, and
type tests of an object model. We consider the case of an attribute $\mathrm{a}$
of class $C$ which has the simple class type $D$ (not a primitive type, not a
collection):
\begin{gather*}
  I\semantics{\getAttrib[]{\self}{a}} (\sigma, \sigma')   \equiv
  \begin{cases}
\bottom & \text{if $O = \bottom \lor \HolOclOidOf\ap\drop{O}\notin \dom~\sigma'$} \\
    \getType[]{D} \mathit{u}
    & \text{if $\sigma' (\getAttrib[0]{\getType[]{C}\drop{\sigma'(\HolOclOidOf\ap\drop{O})}}{a})
      = \lift{\mathit{u}}$,}\\
\bottom & \text{otherwise.}
\end{cases}
\end{gather*}
\begin{gather*}
I\semantics{\getAttrib[]{\self}{a@pre}} (\sigma, \sigma')   \equiv
  \begin{cases}
   \bottom & \text{if $O = \bottom\lor \HolOclOidOf\ap\drop{O}\notin \dom~\sigma$} \\
    \getType[]{D} \mathit{u}
    & \text{if $\sigma (\getAttrib[]{\getType[]{C}\drop{\sigma(\HolOclOidOf\ap\drop{O})}}{a})
      = \lift{\mathit{u}}$,}\\
\bottom & \text{otherwise.}
  \end{cases}
\end{gather*}
where $O = I\semantics{\self}(\sigma, \sigma')$.  Here, $\getType[]{D}$ is the
projection function from the object universe to $\up{D}$, and
$\getAttrib[]{x}{a}$ is the projection of the attribute from the class type (the
Cartesian product). For simple class types, we have to evaluate expression
$\self$, get an object representation (or undefined), project the attribute,
de-reference it in the pre or post state and project the class object from the
object universe ($\getType[]{D}$ may yield $\bottom$ if the element in the
universe does not correspond to a $D$ object representation.)  In the case for a
primitive type attribute, the de-referentiation step is left out, and in the
case of a collection over class types, the elements of the collection have to be
point-wise de-referenced and smashed.

In our model accessors always yield (type-safe) object representations; not
$\oid$'s. Thus, a dangling reference, \ie, one that is \emph{not} in $\dom~
\sigma$, results in $\isasymOclUndefined$ (this is a subtle
difference to~\cite[Annex A]{omg:ocl:2003} where the undefinedness is detected
one de-referentiation step later). The strict equality $\_
\isasymMathOclStrictEq \_$ must be defined via $\HolOclOidOf$ when applied to
objects. It satisfies $(\isasymOclInvalid \isasymMathOclStrictEq X)
\isasymMathOclStrongEq \isasymOclInvalid$.

The definitions of casts and type tests can be found
in~\cite{brucker.ea:extensible:2008-b}, together with other details of the
construction above and its automation in \holocl.

\chapter{A Proposal for an OCL 2.3 Semantics}\label{sec:hol-ocl2-semantics}
In this section, we describe our OCL 2.1 semantics proposal as an increment to
the OCL 2.0 semantics (underlying \holocl and essentially formalizing
\cite[Annex A]{omg:ocl:2003}). In later versions of the
standard~\cite{omg:ocl:2006,omg:ocl:2012} the formal semantics appendix reappears although
being incompatible with the normative parts of the standard.  Not all rules
shown here are formally proven; technically, these are informal proofs ``with a
glance'' on the formal proofs shown in the previous section.

\section{Other Operations on States}
Defining $\_\isasymOclAllInstances$
is straight-forward; the only difference is the property
$T\isasymOclAllInstances\isasymOclExcludes(\isasymOclNull)$ which is a
consequence of the fact that $\Null{}$'s are values and do not ``live'' in the
state.  In our semantics which admits states with ``dangling references,'' it is
possible to define a counterpart to \inlineocl+_.oclIsNew()+ called
\inlineocl+_.oclIsDeleted()+ which asks if an object id (represented by an object
representation) is contained in the pre-state, but not the post-state.

OCL does not guarantee that an operation only modifies the path-expressions
mentioned in the postcondition, \ie, it allows arbitrary relations from
pre-states to post-states.  This framing problem is well-known (one of the
suggested solutions is~\cite{kosiuczenko:specification:2006}). We define
\begin{ocl}
 (S:Set(OclAny))->oclIsModifiedOnly():Boolean
\end{ocl}
where \inlineocl|S| is a set of object representations, encoding
a set of $\oid$'s. The semantics of this operator is defined such that
for any object whose $\oid$ is \emph{not }represented in \inlineocl|S|
and that is defined in pre and post state, the corresponding object representation will not change
in the state transition:
\begin{gather*}
I\semantics{X\isasymMathOclIsModifiedOnly} (\sigma, \sigma')  \equiv
  \begin{cases}
    \isasymbottom & \text{if $X' = \bottom$}  \\
     \lift{\isasymforall i \isasymin M\spot
        \sigma~i = \sigma'~i} & \text{otherwise}\mi{.}
   \end{cases}
\end{gather*}
where $X' = I\semantics{X} (\sigma, \sigma')$ and $M=
(\dom~\sigma\cap\dom~\sigma') - \{ \HolOclOidOf x |~x \in\drop{X'}\}$.  Thus, if
we require in a postcondition \inlineocl|Set{}->oclIsModifiedOnly()| and exclude via
\inlineocl+_.oclIsNew()+ and \inlineocl+_.oclIsDeleted()+ the existence of new
or deleted objects, the operation is a query in the sense of the OCL standard, \ie,
the \inlineocl|isQuery| property is true. So, whenever we have $ \tau
\isasymMathOclValid X\isasymMathOclIsModifiedOnly$ and $ \tau
\isasymMathOclValid X\isasymOclExcludes(s.a)$, we can infer that $\tau
\isasymMathOclValid s.a = s.a\isasymOclATpre$ (if they are valid).

\chapter{Attribute Values}\label{sec:multiplicities}
Depending on the specified multiplicity, the evaluation of an attribute can
yield a value or a collection of values. A multiplicity defines a lower bound as
well as a possibly infinite upper bound on the cardinality of the attribute's
values.

\section{Single-Valued Attributes}\label{sec:single-valued-properties}
If the upper bound specified by the attribute's multiplicity is one, then an
evaluation of the attribute yields a single value. Thus, the evaluation result
is not a collection. If the lower bound specified by the multiplicity is zero,
the evaluation is not required to yield a non-null value. In this case an
evaluation of the attribute can return $\isasymOclNull$ to indicate an
absence of value.

To facilitate accessing attributes with multiplicity \inlineocl{0..1}, the OCL
standard states that single values can be used as sets by calling collection
operations on them. This implicit conversion of a value to a
\inlineocl{Set} is not defined by the standard. We argue that the resulting set
cannot be constructed the same way as when evaluating a \inlineocl{Set}
literal. Otherwise, $\isasymOclNull$ would be mapped to the singleton set
containing $\isasymOclNull$, but the standard demands that
the resulting set is empty in this case. The conversion should instead
be defined as follows:
\begin{ocl}
context OclAny::asSet():T
  post: if self $\isasymMathOclStrictEq$ null then result $\isasymMathOclStrictEq$ Set{}
        else result $\isasymMathOclStrictEq$ Set{self} endif
\end{ocl}
% Changed self.isTypeOf(OCLVoid) to self = null to make it easier for the superficial reader

\section{Collection-Valued Attributes}\label{sec:collection-valued-properties}
If the upper bound specified by the attribute's multiplicity is larger than one,
then an evaluation of the attribute yields a collection of values.  This raises
the question whether $\isasymOclNull$ can belong to this collection. The OCL
standard states that $\isasymOclNull$ can be owned by collections. However, if
an attribute can evaluate to a collection containing $\isasymOclNull$, it is not
clear how multiplicity constraints should be interpreted for this attribute. The
question arises whether the $\isasymOclNull$ element should be counted or not
when determining the cardinality of the collection. Recall that $\isasymOclNull$
denotes the absence of value in the case of a cardinality upper bound of one, so
we would assume that $\isasymOclNull$ is not counted. On the other hand, the
operation \inlineocl{size} defined for collections in OCL does count
$\isasymOclNull$.

We propose to resolve this dilemma by regarding multiplicities as optional. This
point of view complies with the UML standard, that does not require lower and
upper bounds to be defined for multiplicities.\footnote{We are however aware
  that a well-formedness rule of the UML standard does define a default bound
  of one in case a lower or upper bound is not specified.} In case a
multiplicity is specified for an attribute, \ie, a lower and an upper bound
are provided, we require any collection the attribute evaluates to to not
contain $\isasymOclNull$. This allows for a straightforward interpretation of
the multiplicity constraint. If bounds are not provided for an attribute, we
consider the attribute values to not be restricted in any way. Because in
particular the cardinality of the attribute's values is not bounded, the result
of an evaluation of the attribute is of collection type. As the range of values
that the attribute can assume is not restricted, the attribute can evaluate to a
collection containing $\isasymOclNull$. The attribute can also evaluate to
$\isasymOclInvalid$. Allowing multiplicities to be optional in this way gives
the modeler the freedom to define attributes that can assume the full ranges of
values provided by their types. However, we do not permit the omission of
multiplicities for association ends, since the values of association ends are
not only restricted by multiplicities, but also by other constraints enforcing
the semantics of associations. Hence, the values of association ends cannot be
completely unrestricted.

\section{The Precise Meaning of Multiplicity Constraints}
We are now ready to define the meaning of multiplicity constraints by giving
equivalent invariants written in OCL. Let \inlineocl{a} be an attribute of a
class \inlineocl{C} with a multiplicity specifying a lower bound $m$ and an
upper bound $n$. Then we can define the multiplicity constraint on the values of
attribute \inlineocl{a} to be equivalent to the following invariants written in
OCL:
\begin{ocl}
context C inv lowerBound: a->size() >= m
          inv upperBound: a->size() <= n
          inv notNull: not a->includes(null)
\end{ocl}
If the upper bound $n$ is infinite, the second invariant is omitted. For the
definition of these invariants we are making use of the conversion of single
values to sets described in \autoref{sec:single-valued-properties}. If $n
\leq 1$, the attribute \inlineocl{a} evaluates to a single value, which is then
converted to a \inlineocl{Set} on which the \inlineocl{size} operation is
called.

If a value of the attribute \inlineocl{a} includes a reference to a non-existent
object, the attribute call evaluates to $\isasymOclInvalid$. As a result, the
entire expressions evaluate to $\isasymOclInvalid$, and the invariants are not
satisfied. Thus, references to non-existent objects are ruled out by these
invariants. We believe that this result is appropriate, since we argue that the
presence of such references in a system state is usually not intended and likely
to be the result of an error. If the modeler wishes to allow references to
non-existent objects, she can make use of the possibility described above to
omit the multiplicity.



\input{session}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End:
