\documentclass[11pt,a4paper]{scrartcl}
\usepackage{isabelle,isabellesym}
\usepackage[nocolortable, noaclist]{hol-ocl-isar}
\usepackage{fmde-acronyms}
\usepackage{paralist}
% further packages required for unusual symbols (see also
% isabellesym.sty), use only when needed

\usepackage{amssymb}
  %for \<leadsto>, \<box>, \<diamond>, \<sqsupset>, \<mho>, \<Join>,
  %\<lhd>, \<lesssim>, \<greatersim>, \<lessapprox>, \<greaterapprox>,
  %\<triangleq>, \<yen>, \<lozenge>

%\usepackage[greek,english]{babel}
  %option greek for \<euro>
  %option english (default language) for \<guillemotleft>, \<guillemotright>

%\usepackage[latin1]{inputenc}
  %for \<onesuperior>, \<onequarter>, \<twosuperior>, \<onehalf>,
  %\<threesuperior>, \<threequarters>, \<degree>

%\usepackage[only,bigsqcap]{stmaryrd}
  %for \<Sqinter>

%\usepackage{eufrak}
  %for \<AA> ... \<ZZ>, \<aa> ... \<zz> (also included in amssymb)

%\usepackage{textcomp}
  %for \<cent>, \<currency>

% this should be the last package used
\usepackage{pdfsetup}

% urls in roman style, theory text in math-similar italics
\urlstyle{rm}
\isabellestyle{it}
\newcommand{\ie}{i.\,e.\xspace}
\newcommand{\eg}{e.\,g.\xspace}
\renewcommand{\isamarkupheader}[1]{}
\renewcommand{\isamarkupsection}[1]{\subsection{#1}}
\renewcommand{\isamarkupsubsection}[1]{\subsubsection{#1}}
\renewcommand{\isamarkupsubsubsection}[1]{\paragraph{#1}}
\renewcommand{\isamarkupsect}[1]{\subsection{#1}}
\renewcommand{\isamarkupsubsect}[1]{\subsubsection{#1}}
\renewcommand{\isamarkupsubsubsect}[1]{\paragraph{#1}}
\newcommand{\testgen}{HOL-TestGen}

\begin{document}

\title{Featherweight OCL}
\subtitle{A Study for a Consistent Semantics of UML/OCL 2.3 in HOL}
\subject{Extended Version}
\author{Achim D. Brucker \and Burkhart Wolff}

\maketitle

\begin{abstract}
  At its origins, \OCL was conceived as a strict semantics for
  undefinedness, with the exception of the logical connectives of type
  \inlineocl{Boolean} that constitute a three-valued propositional
  logic.  Recent versions of the \OCL standard added a second
  exception element, which, similar to the null references in
  programming languages, is given a non-strict semantics.

  In this paper, we report on our results in formalizing the core of
  \acs{ocl} in \acf{hol}. This formalization revealed several
  inconsistencies and contradictions in the current version of the
  \acs{ocl} standard.  These inconsistencies and contradictions are
  reflected in the challenge to define and implement \OCL tools in a
  uniform manner.

  \noindent{\textbf{Further readings:}} This theory extends the paper
  ``Featherweight OCL: A study for the consistent semantics of OCL 2.3
  in \HOL''~\cite{brucker.ea:featherweight:2012} that is published as
  part of the proceedings of the \OCL workshop 2012.
\end{abstract}



\tableofcontents


\section{Introduction}
At its origins~\cite{richters:precise:2002,omg:ocl:1997}, \OCL was
conceived as a strict semantics for undefinedness, with the exception
of the logical connectives of type \inlineocl{Boolean} that constitute
a three-valued propositional logic.  Recent versions of the \OCL
standard~\cite{omg:ocl:2006,omg:ocl:2012} added a second exception
element, which is given a non-strict semantics.  Unfortunately, this
extension results in several inconsistencies and contradictions. These
problems are reflected in difficulties to define interpreters,
code-generators, specification animators or theorem provers for \OCL
in a uniform manner and resulting incompatibilities of various
tools. For the \OCL community, this results in the challenge to define
a new formal semantics definition \OCL that could replace the ``Annex
A'' of the \acs{ocl} standard~\cite{omg:ocl:2012}.

In the paper ``Extending \OCL with
Null-References''~\cite{brucker.ea:ocl-null:2009} we explored---based
on mathematical arguments and paper and pencil proofs---a consistent
formal semantics that comprises two exception elements:
\inlineocl{invalid} (``bottom'' in semantics terminology) and
\inlineocl{null} (for ``non-existing element'').

This short paper is based on a formalization
of~\cite{brucker.ea:ocl-null:2009}, called ``Featherweight \OCL,'' in
Isabelle/\acs{hol}~\cite{nipkow.ea:isabelle:2002}.  This formalization
is in its present form merely a semantical study and a proof of
technology than a real tool. It focuses on the formalization of the
key semantical constructions, \ie, the type \inlineocl{Boolean} and
the logic, the type \inlineocl{Integer} and a standard strict operator
library, and the collection type \inlineocl{Set(A)} with quantifiers,
iterators and key operators.



% sane default for proof documents
\parindent 0pt\parskip 0.5ex

\section{Featherweight OCL}
% generated text of all theories
Featherweight \acs{ocl} is a formalization of the core of \acs{ocl}
aiming at formally investigation the relationship between the
different notions of ``undefinedness,'' \ie, \inlineocl{invalid} and

\inlineocl{null}. As such, it does not attempt to define the complete
\acs{ocl} library. Instead, it concentrates on the core concepts of
\acs{ocl} as well as the types \inlineocl{Boolean},
\inlineocl{Integer}, and typed sets (\inlineocl|Set(T)|).  Following
the tradition of
\holocl~\cite{brucker.ea:hol-ocl:2008,brucker.ea:hol-ocl-book:2006},
Featherweight \OCL is based on the following principles:
\begin{compactenum}
\item It is an embedding into a powerful semantic meta-language and
  environment, namely
  Isabelle/\acs{hol}~\cite{nipkow.ea:isabelle:2002}.
\item It is a \emph{shallow embedding} in \acs{hol}; types
  in \OCL were injectively mapped to types in Featherweight
  \OCL. Ill-typed \OCL specifications cannot be represented in
  Featherweight \OCL and a type in Featherweight \OCL contains exactly
  the values that are possible in \OCL. Thus, sets may contain
  \inlineocl{null} (\inlineocl|Set{null}| is a defined set) but not
  \inlineocl{invalid} (\inlineocl|Set{invalid}| is just
  \inlineocl{invalid}).
\item Any Featherweight \OCL type contains at least
  \inlineocl{invalid} and \inlineocl{null} (the type \inlineocl{Void}
  contains only these instances). The logic is consequently
  four-valued, and there is a \inlineocl{null}-element in the type
  \inlineocl{Set(A)}.
\item It is a strongly typed language in the Hindley-Milner tradition.
  We assume that a pre-process eliminates all implicit conversions due
  to subtyping by introducing explicit casts (\eg,
  \inlineocl{oclAsType()}). The details of such a pre-processing are
  described in~\cite{brucker:interactive:2007}.  Casts are semantic
  functions, typically injections, that may convert data between the
  different Featherweight \OCL types.
\item All objects are represented in an object universe in the \holocl
  tradition~\cite{brucker.ea:extensible:2008-b} the universe
  construction also gives semantics to type casts, dynamic type
  tests, as well as functions such as \inlineocl{oclAllInstances()},
  or \inlineocl{isNewInState()}.
\item Featherweight \OCL types may be arbitrarily nested:
  \inlineocl|Set{Set{1,2}} = Set{Set{2,1}}| is legal and true.
\item For demonstration purposes, the set-type in Featherweight \OCL
  may be infinite, allowing infinite quantification and a constant
  that contains the set of all Integers.  Arithmetic laws like
  commutativity may therefore expressed in \OCL itself.  The
  iterator is only defined on finite sets.
\item It supports equational reasoning and congruence reasoning, but
  this requires a differentiation of the different equalities like
  strict equality, strong equality, meta-equality (\acs{hol}). Strict
  equality and strong equality require a subcalculus, ``cp'' (a
  detailed discussion of the different equalities as well the
  subcalculus ``cp''---for three-valued \acs{ocl} 2.0---is given
  in~\cite{brucker.ea:semantics:2009}), which is nasty but can be
  hidden from the user inside tools.
\end{compactenum}






\input{session}


\section{Lessons Learned}
While our paper and pencil arguments, given
in~\cite{brucker.ea:ocl-null:2009}, turned out to be essentially
correct, there had also been a lesson to be learned: If the logic is
not defined as a Kleene-Logic, having a structure similar to a
\acf{cpo}, reasoning becomes complicated: several important algebraic laws break down
which makes reasoning in \OCL inherent messy and a semantically clean
compilation of \OCL formulae to a two-valued presentation, that is
amenable to animators like KodKod~\cite{torlak.ea:kodkod:2007} or
\acs{smt}-solvers like Z3~\cite{moura.ea:z3:2008} completely
impractical. Concretely, if the expression \inlineocl{not(null)}
is defined \inlineocl{invalid} (as is the case in the
present standard~\cite{omg:ocl:2012}), than standard involution does
not hold, \ie, \inlineocl{not(not(A))} = \inlineocl{A} does not hold
universally. Similarly, if
% \begin{ocl}
%      null and null  
% \end{ocl}
\inlineocl{null and null} is \inlineocl{invalid}, then not even
idempotence \inlineocl{X and X} = \inlineocl{X} holds. We strongly argue in favor of a lattice-like
organization, where \inlineocl{null} represents ``more information''
than \inlineocl{invalid} and the logical operators are monotone with
respect to this semantical ``information ordering.''
%(as in classical Scott \acs{cpo}'s).

Featherweight \OCL makes these two deviations from the standard,
builds all logical operators on Kleene-\inlineocl{not} and
Kleene-\inlineocl{and}, and shows that the entire construction of our
paper ``Extending \OCL with
Null-References''~\cite{brucker.ea:ocl-null:2009} is then correct, and
the \acs{dnf}-normaliation as well as $\delta$-closure laws (necessary
for a transition into a two-valued presentation of \OCL specifications
ready for interpretation in \acs{smt} solvers
(see~\cite{brucker.ea:ocl-testing:2010} for details) are valid in
Featherweight \OCL.

\section{Conclusion and Future Work}
Featherweight \OCL concentrates on formalizing the semantics of a core
subset of \OCL in general and in particular on formalizing the
consequences of a four-valued logic (\ie, \OCL versions that support,
besides the truth values \inlineocl{true} and \inlineocl{false} also
the two exception values \inlineocl{invalid} and \inlineocl{null}).

In the following, we outline the necessary steps for turning
Featherweight \OCL into a fully fledged tool for \OCL, \eg, similar to
\holocl as well as for supporting test case generation similar to
\acs{hol}-TestGen~\cite{brucker.ea:hol-testgen:2009}.  There are
essentially five extensions necessary:
\begin{compactitem}
\item extension of  the library to support all \OCL data types, \eg,
  \inlineocl{Sequence(T)}, \inlineocl{OrderedSet(T)}. % This is
  % essentially a student-project given the sample proofs already there,
  % that have to be adapted to similar types.
  This formalization of the \OCL standard library can be used for
  checking the consistency of the formal semantics (known as ``Annex
  A'') with the informal and semi-formal requirements in the normative
  part of the \OCL standard.
\item development of a compiler that compiles a textual or \acs{case}
  tool representation (\eg, using \acs{xmi} or the textual syntax of
  the \acs{use} tool~\cite{richters:precise:2002}) of class
  models. Such compiler could also generate the necessary casts when
  converting standard \OCL to Featherweight \OCL as well as providing
  ``normalizations'' such as converting multiplicities of class
  attributes to into \OCL class invariants.
\item a setup for translating Featherweight \OCL into a two-valued
  representation as described
  in~\cite{brucker.ea:ocl-testing:2010}. As, in real-world scenarios,
  large parts of \acs{uml}/\acs{ocl} specifications are defined (\eg,
  from the default multiplicity \inlineocl{1} of an attributes
  \inlineocl{x}, we can directly infer that for all valid states
  \inlineocl{x} is neither \inlineocl{invalid} nor \inlineocl{null}),
  such a translation enables an efficient test case generation
  approach.
\item a setup in Featherweight \OCL of the Nitpick
  animator~\cite{blanchette.ea:nitpick:2010}. It remains to be shown
  that the standard, Kodkod~\cite{torlak.ea:kodkod:2007} based
  animator in Isabelle can give a similar quality of animation as the
  OCLexec Tool~\cite{krieger.ea:generative:2010}
\item a code-generator setup for Featherweight \OCL for Isabelle's
  code generator. For example, the Isabelle code generator supports
  the generation of F\#, which would allow to use \acs{ocl}
  specifications for testing arbitrary .net-based applications.
\end{compactitem}
The first two extensions are sufficient to provide a formal proof
environment for \OCL 2.3 similar to \holocl while the remaining
extensions are geared towards increasing the degree of proof
automation and usability as well as providing a tool-supported test
methodology for \acs{uml}/\acs{ocl}.


Our work shows that developing a machine-checked formal semantics of
recent \acs{ocl} standards still reveals significant
inconsistencies---even though this type of research is not new. In
fact, we started our work already with the 1.x series of
\acs{ocl}. The reasons for this ongoing consistency problems of
\acs{ocl} standard are manifold. For example, the consequences of
adding an additional exception value to \OCL 2.2 are widespread across
the whole language and many of them are also quite subtle. Here, a
machine-checked formal semantics is of great value, as one is forced
to formalize all details and subtleties.  Moreover, the
standardization process of the \acs{omg}, in which standards (\eg, the
\acs{uml} infrastructure and the \acs{ocl} standard) that need to be
aligned closely are developed quite independently, are prone to ad-hoc
changes that attempt to align these standards. And, even worse,
updating a standard document by voting on the acceptance (or
rejection) of isolated text changes does not help either. Here, a tool
for the editor of the standard that helps to check the consistency of
the whole standard after each and every modifications can be of great
value as well.


% optional bibliography
\bibliographystyle{abbrv}
\bibliography{adb-long,root}
\listofacronyms{}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
