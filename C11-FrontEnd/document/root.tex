\documentclass[fontsize=11pt,paper=a4,open=right,twoside,abstract=true]{scrreprt}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[numbers, sort&compress, sectionbib]{natbib}
\usepackage{isabelle,isabellesym}
\usepackage{ifthen}
\IfFileExists{railsetup.sty}{\usepackage{railsetup}}{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% command

\newenvironment{matharray}[1]{\[\begin{array}{#1}}{\end{array}\]} % from 'iman.sty'
\newcommand{\indexdef}[3]%
{\ifthenelse{\equal{}{#1}}{\index{#3 (#2)|bold}}{\index{#3 (#1\ #2)|bold}}} % from 'isar.sty'
\newcommand{\isactrlurl}{$\oplus$}
\newcommand{\isactrlC}{{\bf C}}

%%

\newcommand\inputif[1]{\IfFileExists{./#1}{\input{#1}}{}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% fix for package declaration to be at the end
\usepackage[pdfpagelabels, pageanchor=false, plainpages=false]{hyperref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% document

\urlstyle{rm}
\isabellestyle{it}

\begin{document}

\title{Isabelle/C}
\author{%
  \href{https://www.lri.fr/~ftuong/}{Fr\'ed\'eric Tuong}
  \and
  \href{https://www.lri.fr/~wolff/}{Burkhart Wolff}}
\publishers{%
  \mbox{LRI, Univ. Paris-Sud, CNRS, CentraleSup\'elec, Universit\'e Paris-Saclay} \\
  b\^at. 650 Ada Lovelace, 91405 Orsay, France \texorpdfstring{\\}{}
    \href{mailto:"Frederic Tuong"
    <frederic.tuong@lri.fr>}{frederic.tuong@lri.fr} \hspace{4.5em}
    \href{mailto:"Burkhart Wolff"
    <burkhart.wolff@lri.fr>}{burkhart.wolff@lri.fr}
}

\maketitle

\begin{abstract}
Isabelle/C is a particular infrastructure composed of a \emph{syntax front-end} accepting C text in
input (currently C11), with together a way to ``hot-plug'' and run \emph{semantic back-ends} in
output.

Isabelle/C and Isabelle/ML have several characteristics in common, but instead of proceeding to the
compilation of a ML code and by default starting to execute it, within Isabelle/C the user can at
any time define how a C code in input will be semantically interpreted (or translated to a
well-defined language). Also, multiple semantic back-ends can be selected to be independently run in
parallel.

Ultimately, the language(s) in which semantic back-ends are written is arbitrary: our back-ends are
currently implemented in some fine-grain combination of HOL and ML --- and with this work, a next
typical implementation of choice would include C itself.

In return, theorems and proofs generated by semantic back-ends get ultimately evaluated in ML, with
a performance close to native (by only considering standard Isabelle
versions).\cite{brucker.ea:featherweight:2014}
\end{abstract}
\tableofcontents

\parindent 0pt\parskip 0.5ex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\inputif{1/document/C_Ast.tex}
\inputif{1/document/C_Lexer.tex}
\inputif{1/document/C_Environment.tex}
\inputif{1/document/C_Parser_Annotation.tex}
\inputif{1/document/C_Parser_Language.tex}
\inputif{1/document/C_Eval.tex}
\inputif{1/document/C_Command.tex}
\inputif{1/document/C_Document.tex}
\inputif{1/document/C_Main.tex}
\inputif{2/document/C1.tex}
\inputif{2/document/C2.tex}
\inputif{2/document/C3.tex}
\inputif{2/document/C_paper.tex}
\inputif{3/document/C_Intro.tex}
\inputif{3/document/C_Conclusion.tex}
\inputif{3/document/C_Appendices.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{abbrvnat}
\bibliography{root}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
